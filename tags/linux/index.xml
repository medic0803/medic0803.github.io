<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>linux on Under The Ginkgo</title>
        <link>https://ginkgo.org.cn/tags/linux/</link>
        <description>Recent content in linux on Under The Ginkgo</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-uk</language>
        <lastBuildDate>Mon, 26 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ginkgo.org.cn/tags/linux/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>CASPP Chapter 11 Network Programming 学习笔记（不定期更新）</title>
        <link>https://ginkgo.org.cn/posts/csapp_chapter11_learning_notes/</link>
        <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate>
        
        <guid>https://ginkgo.org.cn/posts/csapp_chapter11_learning_notes/</guid>
        <description>&lt;h2 id=&#34;caspp-chapter-11-network-programming-学习笔记-不定期更新&#34;&gt;CASPP Chapter 11 Network Programming 学习笔记（不定期更新）&lt;/h2&gt;
&lt;h3 id=&#34;学习进度&#34;&gt;学习进度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Socket 套接字： 11.3.3，11.4 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; Web Servers: 11.5 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;socket套接字--11-dot-3-dot-3-11-dot-4&#34;&gt;Socket套接字 (11.3.3, 11.4)&lt;/h3&gt;
&lt;h4 id=&#34;学习契机&#34;&gt;学习契机&lt;/h4&gt;
&lt;p&gt;学习Java内存马之前，想再看看Tomcat服务器的总体框架，其中有提到socket的内容，之前学nc的时候，也提到了socket的方法，感觉不是特别熟悉，看来还得是CSAPP！ &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;什么是socket套接字&#34;&gt;什么是socket套接字？&lt;/h4&gt;
&lt;p&gt;什么是socket套接字？我们经常能在网络编程，客户端与服务器的通信这样的话题中聊到socket套接字，以及其相关的方法，那么存在即有意义，我们就一起来看看什么是scoket套接字以及为什么需要socket套接字。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;我们都熟悉OSI七层模型或者TCP/IP模型，知道在双方通信的过程中，数据在应用层或者高层发出之后，需要经过层层打包封装后再通过物理层发送给对方，之后再层层解析拆包，最终使接收方获取到真实的数据。以上场景是非常宏观的以及抽象的描述，简单来说，socket套接字就是其中一个环节的具体实现！ &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;我们知道在Internet通信的双方是可以建立连接的，这样的连接是 &lt;code&gt;point-to-point&lt;/code&gt; 点对点的，而这个点 &lt;code&gt;endpoint&lt;/code&gt; 就是 &lt;code&gt;socket&lt;/code&gt; ，所以我们现在可以说socket就是用来帮助通信的双方建立连接，接收，以及发送数据的。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;那我们刚才将socket是通信的具体实现又是连接的端点，那么每一个socket是首先是由 &lt;code&gt;socket address&lt;/code&gt; 即套接字地址唯一标识的（待确认），其中： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;socket address又两部分组成(address:port)： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IP address &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Port &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么一个连接，就是由一对 &lt;code&gt;socket address&lt;/code&gt; 组成：(cliaddr:cliport, servaddr:servport) (客户端地址：客户端端口，服务端地址：服务端端口) &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;其中客户端的端口是由 &lt;code&gt;kernel&lt;/code&gt; 自动分配的,我们叫做 &lt;code&gt;ephemeral port&lt;/code&gt; (临时端口？)；同时服务端的端口就是预留端口用来表明特定的服务，比如Web服务器使用80端口，邮箱服务器使用25端口，相信大家应该对此都已经非常熟悉了。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-09-26_15-48-42_screenshot.png&#34;
         alt=&#34;Figure 1: 一对socket address (address:port)唯一标识一个连接&#34; width=&#34;700px&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 1: &lt;!-- raw HTML omitted --&gt;一对socket address (address:port)唯一标识一个连接&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;socket套接字具体的功能&#34;&gt;socket套接字具体的功能&lt;/h4&gt;
&lt;p&gt;在上一小节中我们提到了socket可以帮助建立连接以及接收和发送数据，那么具体是如何实现的呢？ &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;说到实现，我们就可以想到Java中的实现接口，在这里也是一样，socket套接字其实就是一个Interface 接口，那么在不同的编程语言之间都用不同的实现以及API，我们在这里就从socket interface来介绍一下socket的功能 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-09-26_17-45-13_screenshot.png&#34;
         alt=&#34;Figure 2: Socket Interface&#34; width=&#34;700px&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 2: &lt;!-- raw HTML omitted --&gt;Socket Interface&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;观察上图我们可以发现，通信的双方被定义为 &lt;code&gt;Client&lt;/code&gt; 客户端以及 &lt;code&gt;Server&lt;/code&gt; 服务端，同时 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;open_clientfd被定义为：getaddrinfo -&amp;gt; socket -&amp;gt; connect &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;open_listenfd被定义为：getaddrinfo -&amp;gt; socket -&amp;gt; bind -listen &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Section 10.2的学习中，我们知道了 &lt;code&gt;socket&lt;/code&gt; 也是Linux中的一种文件类型，我们也知道了打开文件意味着分配到一个 &lt;code&gt;descriptor&lt;/code&gt; 描述符，由此我们可以理解为，打开一个可以用于通信的 socket 文件需要满足以上步骤，接下来我们就来具体看看这些方法 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;getaddrinfo(&amp;hellip; &amp;hellip;)&lt;/dt&gt;
&lt;dd&gt;用于帮助转换hostnames, host addresses, service names, and port numbers等参数的结构，以供后面的方法使用，这里暂时不展开了 &lt;!-- raw HTML omitted --&gt;&lt;/dd&gt;
&lt;dt&gt;socket(&amp;hellip; &amp;hellip;)&lt;/dt&gt;
&lt;dd&gt;无论是客户端还是服务端，都需要先用 socket 方法来完成打开一个文件（详见10.1的opening files操作），同时返回一个 &lt;code&gt;socket decriptor&lt;/code&gt; socket描述符来供应用使用 &lt;!-- raw HTML omitted --&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端socket&lt;/p&gt;
&lt;p&gt;完成一个客户端socket需要执行 &lt;code&gt;connect(int sockfd, const struct scokaddr *addr, ...)&lt;/code&gt; 方法，该方法会尝试与服务端socket的地址建立连接，并且该方法会block阻塞直到连接成功或者发生错误。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务端socket&lt;/p&gt;
&lt;p&gt;剩下的所有 socket 方法都是给服务端socket用的，包括 bind, listen, accept &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
: -   &lt;code&gt;bind()&lt;/code&gt; 方法会将我们之前用socket()方法创建的 socket descriptor 与 socket address地址关联起来 &lt;!-- raw HTML omitted --&gt;
-   有一个问题就是为什么client socket不需要呢？ &lt;!-- raw HTML omitted --&gt;
-   因为不使用 bind() 方法socket address的(IP address : port number)就会由kernel自动分配，也就是我们常见的客户端了 &lt;!-- raw HTML omitted --&gt;
-   而使用了 bind() 方法就意味着我们可以指定其 socket address，也就是我们所说的服务端了 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;我们说Client socket是active主动的，是主动发起来连接的（connect()）;而Server socket则是被动的,是被动地等待有client等待连接的。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Kernel默认将由 &lt;code&gt;socket()&lt;/code&gt; 方法创建的socket descriptor当作主动的socket（client），直到listen方法的出现，则会帮助kernel认出server socket &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;listen(int sockfd, int backlog)
: -   listen()方法将有一个active的socket转换为passive的socket（sockfd）来监听来自客户端的连接，而backlog则代表可以连接的数量（这里我猜测nc中如果开启了-k持续连接可能与这个参数也有关系？） &lt;!-- raw HTML omitted --&gt;
-   也就是将原本的 &lt;code&gt;socket()&lt;/code&gt; 方法返回的 sockfd 转化为 &lt;code&gt;listening socket&lt;/code&gt;, 以此来等待来自client socket的连接 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;int accept(int listenfd, struct sockaddr *addr, int *addrlen)
: -   当server socket来自client socket发起的连接（connect()）时，就会触发accept()方法 &lt;!-- raw HTML omitted --&gt;
-   &lt;code&gt;accept()&lt;/code&gt; 方法将会接收之前 &lt;code&gt;listen()&lt;/code&gt; 方法返回的listenfd，并且绑定发起连接的client socket的地址，最后返回 &lt;code&gt;connected descriptor&lt;/code&gt; 来与client socket之间使用I/O操作进行通信 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;各个file descriptors之间的关系&lt;/p&gt;
&lt;p&gt;上面的各种方法，都会使用以及返回各种file descriptor，是不是已经有点绕了，最后我们就一起来通过一个例子辨析一下吧 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-09-27_16-28-43_screenshot.png&#34;
             alt=&#34;Figure 3: 各个file descriptors之间的关系&#34; width=&#34;700px&#34;/&gt;&lt;figcaption&gt;
                &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 3: &lt;!-- raw HTML omitted --&gt;各个file descriptors之间的关系&lt;/p&gt;
            &lt;/figcaption&gt;
    &lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过socket方法创建Server socket，得到sockfd，在完成了listen()方法之后，返回得到listenfd，之后进入阻塞，等待客户端连接 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;通过socket方法创建Client socket，得到clientfd，使用connect()方法发起连接请求 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Server socket收到连接，调用 accept 方法，返回 connfd &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;最终建立起 clientfd 与 connfd 两个文件之间的连接以及通信，所有的数据的传递都通过双方对于clientfd以及connfd两个文件的读写来完成 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接着我们再来辨析一下由listen()方法所返回的 listening descriptor &lt;code&gt;listenfd&lt;/code&gt; 与 accept()方法返回得到的connected descriptor &lt;code&gt;connfd&lt;/code&gt; 之间的关系： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;listening descriptor是由server建立，为了client的connect()方法所服务的，一旦创建就会一直存在 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;connected descriptor是由server建立了，是为了直接与client的clientfd之间通过I/O操作进行通信的，每当server接受一个连接就会创建直到服务结束 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后我们以一个问题结束这一小节的学习，为什么要区分listening以及connected descriptors？ 为什么不直接用listenfd来监听连接，同时建立连接一步到位呢？ &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;乍一看connected descriptor多次一举，但是这个分离的设计却使一个多线程并行的服务器成为可能，server只需要使用一个listenfd来处理所有client发起的连接请求，再独立的开启 connected descriptor来进行通信即可。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;web-servers-web服务器&#34;&gt;&lt;!-- raw HTML omitted --&gt;TODO&lt;!-- raw HTML omitted --&gt; Web Servers Web服务器&lt;/h3&gt;
&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;
&lt;p&gt;Randal E. Bryant, David R. O’Hallaron - Computer Systems. A Programmer’s Perspective [3rd ed.] (2016, Pearson) &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CSAPP Chapter 10 System-Level I/O 学习笔记（不定期更新）</title>
        <link>https://ginkgo.org.cn/posts/csapp_chapter10_learning_notes/</link>
        <pubDate>Mon, 26 Sep 2022 00:00:00 +0000</pubDate>
        
        <guid>https://ginkgo.org.cn/posts/csapp_chapter10_learning_notes/</guid>
        <description>&lt;h2 id=&#34;csapp-chapter-10-system-level-i-o-学习笔记-不定期更新&#34;&gt;CSAPP Chapter 10 System-Level I/O 学习笔记（不定期更新）&lt;/h2&gt;
&lt;h3 id=&#34;学习进度&#34;&gt;学习进度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 10.1 Unix I/O &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 10.2 Files &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;10-dot-1-unix-i-o&#34;&gt;10.1 Unix I/O&lt;/h3&gt;
&lt;h4 id=&#34;学习契机&#34;&gt;学习契机&lt;/h4&gt;
&lt;p&gt;在学习CSAPP第11章的socket套接字接口的时候，在介绍相关的方法时，提到了大量的 &lt;code&gt;file descriptor&lt;/code&gt; 的参数，发现这个概念有点陌生了，就来复习巩固一下。这么说来我对于各种语言的文件读写一直都有一种望而却步能用就行的感觉，没有好好的学习使用过，从Unix I/O开始也可以打下一个良好的基础。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;什么是i-o&#34;&gt;什么是I/O&lt;/h4&gt;
&lt;p&gt;I/O就是Input和Output，是对于 &lt;code&gt;main memory&lt;/code&gt; 主存与 &lt;code&gt;external devices&lt;/code&gt; 外部设备（e.g., 硬盘，终端以及网络）之间数据的输入与输出： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input：将数据从从I/O设备中拷贝到主存中 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Output：将数据从内存中拷贝到外部设备上 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;unix中的i-o&#34;&gt;Unix中的I/O&lt;/h4&gt;
&lt;p&gt;关于Unix中I/O的具体实现，首先我们要了解的两个很重要的结论： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Unix中，所有的I/O设备都是以 &lt;code&gt;文件&lt;/code&gt; 的形式存储和操作 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;那么所有这些I/O操作都是通过读写这些文件来实现的 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其中，Wikipedia对于I/O 设备的定义如下： &lt;!-- raw HTML omitted --&gt;
&amp;ldquo;I/O devices are the pieces of hardware used by a human (or other system) to communicate with a computer &amp;hellip; Devices for communication between computers, such as modems and network cards, typically perform both input and output operations.&amp;rdquo; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;了解到了这两点之后, &lt;code&gt;所有&lt;/code&gt; 的I/O操作就可以规范地定义为对于 &lt;code&gt;文件&lt;/code&gt; 的几个规范性操作，也就是Interface接口: &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Opening files, 打开文件&lt;/dt&gt;
&lt;dd&gt;&lt;ul&gt;
&lt;li&gt;触发：当一个应用想要访问操作一个I/O设备（想要输入或者输出）的时候，就会要求kernel去打开对应的代表I/O设备的文件 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;结果：Kernel内核会返回一个很小的正整数，我们叫做 &lt;code&gt;descriptor&lt;/code&gt; 描述符，用来在之后对于该I/O设备文件的所有操作中，唯一标识该文件 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Kernel内核会持续跟踪该打开文件的所有的信息；而应用只会跟踪返回的 &lt;code&gt;descriptor&lt;/code&gt; 描述符 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;每一个运行的进程会由Linux shell通过打开三个文件开启（个人认为就是启动一个进程需要用到三种I/O设备，因此开启了这三个文件，并返回了三个描述符）： &lt;!-- raw HTML omitted --&gt;
&lt;ol&gt;
&lt;li&gt;standard input (descriptor 0) 标准输入 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;standard output (descriptor 1) 标准输出 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;standard error (descriptor 2) 标准错误 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;Changing the current file position 改变当前文件（内容）位置&lt;/dt&gt;
&lt;dd&gt;&lt;ul&gt;
&lt;li&gt;File position文件位置表示文件中下一个将要被读写的字符的位置 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Kernel会维护每一个打开的文件的file position &lt;code&gt;k&lt;/code&gt; &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;k的初始值为0，每次有字符的读写，file position都会自增 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;应用也可以通过 &lt;code&gt;seek&lt;/code&gt; 操作来显示地修改file position &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;Reading and writing files 读写文件&lt;/dt&gt;
&lt;dd&gt;&lt;ul&gt;
&lt;li&gt;Read 读文件：从一个文件中读取n bytes的数据，从该文件当前的file position k开始读，并且递增n &lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;如果读文件超过文件的size m，则会触发 &lt;code&gt;end-of-file (EOF)&lt;/code&gt;, 值得注意的是，这是由应用自动检测到的，而不是真的有一个字符叫做EOF符 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Write 写文件，同样也会递增file position k文件位置 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;Closing files 关闭文件&lt;/dt&gt;
&lt;dd&gt;&lt;ul&gt;
&lt;li&gt;触发：当应用结束访问一个文件的时候，就会要求kernel去 &lt;code&gt;close&lt;/code&gt; 关闭这个文件 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;结果：kernel会释放所有的所有该文件创建的数据结构；并且将该文件的 &lt;code&gt;descriptor&lt;/code&gt; 描述符归还到可用的描述符池中去 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;当一个进程结束时，kernel会关闭所有打开的文件并且释放他们的内存资源，比如之前提到的标准输入/输出/错误文件，都会被关闭 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3 id=&#34;10-dot-2-files-文件&#34;&gt;10.2 Files 文件&lt;/h3&gt;
&lt;h4 id=&#34;学习契机&#34;&gt;学习契机&lt;/h4&gt;
&lt;p&gt;跟随10.1顺便看看 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;文件分类&#34;&gt;文件分类&lt;/h4&gt;
&lt;p&gt;Linux中对于不同的文件都有其所对应的分类 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;regular file 常规文件&lt;/dt&gt;
&lt;dd&gt;一个普通文件中可以包含任意数据，根据内容存储形式的不同，我们还可以再细化为： &lt;!-- raw HTML omitted --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;text files, 文本文件，即只包含ASCII或者Unicode字符的文件 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;其中文本文件包含一串 &lt;code&gt;text lines&lt;/code&gt; 文件行，每一行都由 &lt;code&gt;newline&lt;/code&gt; 符号 &lt;code&gt;&#39;\n&#39;&lt;/code&gt; 结尾（Linux, Mac OSX） &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再Ms Windows以及Internet协议例如HTTP中，则是使用  &lt;code&gt;&#39;\r\n&#39;&lt;/code&gt; （0xd 0xa）表示的 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此当我们在Linux以及Mac OSX环境下阅读由MS Windows编辑的文本文件时，每行后面都会出现 &amp;lsquo;^M&amp;rsquo;，可以使用一下命令来进行清理 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;linux&amp;gt; perl -pi -e &lt;span class=&#34;s2&#34;&gt;&amp;#34;s/\r\n/\n/g&amp;#34;&lt;/span&gt; foo.txt
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;binary files，二进制文件， &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;dt&gt;directory 目录&lt;/dt&gt;
&lt;dd&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目录时一个包含一组 &lt;code&gt;links&lt;/code&gt; 链接的文件，每一个链接都对应一个文件（常规文件或者目录） &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一个目录文件至少包含两个默认链接 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;. (dot), 该链接指向该目录文件本身 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;.. (dot-dot)，该链接指向 &lt;code&gt;parent directory&lt;/code&gt;  &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt; 创建目录文件， &lt;code&gt;ls&lt;/code&gt; 查看内容， &lt;code&gt;rmdir&lt;/code&gt; 删除目录 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;socket 套接字&lt;/dt&gt;
&lt;dd&gt;&lt;ul&gt;
&lt;li&gt;套接字文件用来与其他进程进行网络通信（详见11.4） &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;h4 id=&#34;文件目录结构&#34;&gt;文件目录结构&lt;/h4&gt;
&lt;p&gt;Linux内核通过唯一一个目录结构来管理所有的文件，该结构是由 &lt;code&gt;root directory&lt;/code&gt; 根目录开始的一个树状结构，用 &lt;code&gt;/&lt;/code&gt; 来表示，因此我们在一个文件路径中开头看到 &lt;code&gt;/&lt;/code&gt; 要知道，这是一个目录文件，和后面使用到的 &lt;code&gt;/&lt;/code&gt; 用作分隔符的概念时不一样的 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-09-27_11-09-45_screenshot.png&#34;
         alt=&#34;Figure 1: Linux目录结构&#34; width=&#34;700px&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 1: &lt;!-- raw HTML omitted --&gt;Linux目录结构&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;每一个进程都有一个 &lt;code&gt;current working directory&lt;/code&gt; 用来表示其在这个目录结构中的位置，通过 &lt;code&gt;cd&lt;/code&gt; 命令可以改变shell的 &lt;code&gt;current working directory&lt;/code&gt; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;那么对应Linux目录结构，有两种形式来表达一个文件的位置（Location）： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Absolute pathname, 绝对路径，表示从根目录（/）开始的路径（之后的/表示路径的分割），例如上图中的hello.c文件的绝对路径就是/home/droh/hello.c &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;Relative pathname，相对路径，表示从一个文件名（./..也是文件名）开始，表示一个文件对于当前工作路径的相对路径，例如在上图中，我们当前的工作路径为 /home/droh,那么文件 hello.c的相对路径就是./hello.c &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;
&lt;p&gt;Randal E. Bryant, David R. O’Hallaron - Computer Systems. A Programmer’s Perspective [3rd ed.] (2016, Pearson) &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/koktlzz/p/16569288.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CSAPP 读书笔记：系统级 I/O&lt;/a&gt;  &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.gnu.org/software/libc/manual/html_node/File-Position.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GNU: File Position&lt;/a&gt; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>浅谈Shell中的小知识</title>
        <link>https://ginkgo.org.cn/posts/shell_introduction/</link>
        <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
        
        <guid>https://ginkgo.org.cn/posts/shell_introduction/</guid>
        <description>&lt;h2 id=&#34;浅谈shell中的小知识&#34;&gt;浅谈Shell中的小知识&lt;/h2&gt;
&lt;h3 id=&#34;什么是交互式shell和非交互式shell&#34;&gt;什么是交互式shell和非交互式shell？&lt;/h3&gt;
&lt;p&gt;我们在进行渗透测试的时候，往往需要自己构造一个 &lt;code&gt;Interactive&lt;/code&gt; 可交互的shell，那么什么是可交互？原本的shell也可以执行命令，为什么不能用，非得想办法构造一个可交互的shell呢？ &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;interactive-shell-交互式shell&#34;&gt;Interactive shell 交互式shell&lt;/h4&gt;
&lt;dl&gt;
&lt;dt&gt;我们先来看一下Bash对于 &lt;code&gt;Interactive Shell&lt;/code&gt; 的定义:&lt;/dt&gt;
&lt;dd&gt;&amp;ldquo;An interactive shell is one started without non-option arguments, unless -s is specified, without specifying the -c option, and whose input and error output are both connected to terminals (as determined by isatty(3)), or one started with the -i option. &lt;!-- raw HTML omitted --&gt;
&lt;p&gt;An interactive shell generally reads from and writes to a user’s terminal. &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;The -s invocation option may be used to set the positional parameters when an interactive shell is started.&amp;rdquo; [1]. &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;这里提到了两个概念， &lt;code&gt;option&lt;/code&gt;, &lt;code&gt;argument&lt;/code&gt;; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;介绍前先说结论: argument包含option &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;如果大家尝试过使用C语言与shell交互，应该就会用到如下的代码来对输入的参数进行利用 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;The argument supplied is %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Too many arguments supplied.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;One argument expected.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;argc&lt;/code&gt; 表示输入参数的数量， &lt;code&gt;*argv[]&lt;/code&gt; 就表示包含输入参数的数组 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;这里为了一劳永逸，我们再插一嘴，再辨析一下英文文档中的 &lt;code&gt;parameter&lt;/code&gt; &amp;amp; &lt;code&gt;argument&lt;/code&gt; 的区别： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;parameter指的是在 &lt;code&gt;定义&lt;/code&gt; 函数时的所申明的变量名 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;argument指的是在 &lt;code&gt;调用&lt;/code&gt; 函数时，实际传入的值 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如在下面的例子中，在函数 &lt;code&gt;MyMethod&lt;/code&gt; 中所定义的 &lt;code&gt;myParam&lt;/code&gt; 就是parameter,而在下面实际调用使用中，将要传入的真实数据就叫做 argument [2]. &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;MyMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myParam&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myArg1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;this is my argument&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;myClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myArg1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;好，我们赶紧回来shell中的option和argument的定义： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt; 就是包含整一串shell命令的数组，每一个string都可以称为 &lt;code&gt;argument&lt;/code&gt;, 和调用c语言脚本时一个道理，第一个参数（0）就是命令的名字，例如&amp;rsquo;ls&amp;rsquo;,同时也被称为 &lt;code&gt;positional parameters&lt;/code&gt;; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;option&lt;/code&gt; 同样也是一个argument，但是它们的特殊之处在于option会改变第一个argument的命令的行为，例如 ls -la 中的 &amp;lsquo;-la&amp;rsquo; 就会改变ls的行为 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;parameter&lt;/code&gt; 也是一个argument,其作用时为命令或者其选项提供信息 [3]. &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -la /tmp /var/tmp
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# parameter1= /tmp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# parameter2= /var/tmp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ ls -l -- -a
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# option1    = -l&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# parameter1 = -a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;更多关于 &lt;code&gt;shell parameter&lt;/code&gt; 以及 &lt;code&gt;subcommands&lt;/code&gt; 的解释也可以参考 [3]. &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;了解这些内容之后，我们再回过头来解释 Interactive shell的定义，也就是说一个可交互的shell，就是在启动的时候命令后面跟的只有option类型的argument，除非用了 &lt;code&gt;-s&lt;/code&gt; 选项并且没有使用 &lt;code&gt;-c&lt;/code&gt;, 或者直接使用了 &lt;code&gt;-i&lt;/code&gt; 开启了交互模式 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;-c &amp;lt;string&amp;gt; If the -c option is present, then commands are read from string.  If there are arguments after the string, they are assigned to the positional parameters, starting with $0. &lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;如果出现option -c，那么要执行的指令就从-c后面的string中读取，如果string之后还有参数，那么就当作是一条完整的命令来执行 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-i        If the -i option is present, the shell is interactive. &lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;如果出现-i则开启一个可交互的shell &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-s        If the -s option is present, or if no arguments remain after option processing,  then commands are read from the standard input. This option allows the positional parameters to be set when invoking an interactive shell. &lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;如果出现-s，则从标准输入中读取 &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;-s&lt;/code&gt; ，就可以从stdin读取需要执行的命令，这么说有一点抽象，难以和-c区分开来，我们来看一个例子 [4]： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;curl -L https://chef.io/chef/install.sh &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sudo bash -s -- -P chefdk
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一般来说 &lt;code&gt;-s&lt;/code&gt; 选项都以 &lt;code&gt;curl $script_url | bash&lt;/code&gt; 的形式来配合使用，目的是为了 &lt;code&gt;执行&lt;/code&gt; 下载到的shell; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;这里 &lt;code&gt;--&lt;/code&gt; 表示，将后面所有的string都当作要执行的命令（bash -s所下载的install.sh）的argument，而不是当前命令的option,而 &lt;code&gt;-s&lt;/code&gt; 则会负责执行下载到的install.sh; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;顺便也翻译一下，使用 &lt;code&gt;-c&lt;/code&gt; 选项后面需要跟一个string，来表示将要执行的命令，并且后面还有其他的字符串，都会被当作是命令（前面的string）的其他argument(从$0开始)。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;总结一下，启动一个交互式的shell，需要命令的argument全部都为option，而不能有parameter，除非使用了 &lt;code&gt;-s&lt;/code&gt; (而没有-c) 或者 &lt;code&gt;-i&lt;/code&gt; 的情况,并且交互式shell可以接受来自用户的输入和读取,即这个shell需要用户与其互动，输入命令来决定其行动 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;non-interactive-shell-非交互式shell&#34;&gt;Non-Interactive shell 非交互式shell&lt;/h4&gt;
&lt;p&gt;非交互式的shell就正好相反，其不会与用户进行交互，即标准输入和错误流都没有连接到终端（即用户不可见），往往用于脚本的自动化执行，输入则进入专门的log文件中，同时配置文件例如.bashrc, .profile, .zshrc 都不会被执行 [5]. &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;因此我们在渗透的过程中时常需要去获得一个交互式的shell来看到我们所执行命令的回显信息。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;如何区分交互式shell和非交互式shell&#34;&gt;如何区分交互式shell和非交互式shell&lt;/h4&gt;
&lt;p&gt;我们可以通过交互式shell中所定义的两个变量来进行区分 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;$PS1&lt;/code&gt; 在交互式shell中被定义，有输出的内容，而在非交互式shell中没有被定义，没有输出； &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$-&lt;/code&gt; 在交互式的shell中，输出的字符串包含字符 &lt;code&gt;&#39;i&#39;&lt;/code&gt;, 非交互式shell中，则不包含&amp;rsquo;i&amp;rsquo; [6]； &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（如果不明白这两个变量是干什么的也不用着急，我们下面会讲） &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;可以用下列代码来进行测试 [5]: &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;[[&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$-&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; *i* &lt;span class=&#34;o&#34;&gt;]]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; ‘Interactive’ &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; ‘not-interactive’
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;bash中的特殊变量&#34;&gt;Bash中的特殊变量&lt;/h4&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$PS*&lt;/p&gt;
&lt;p&gt;那到底什么是 &lt;code&gt;$PS1&lt;/code&gt;,看起来像一个变量，叫做 &lt;code&gt;Bash Prompt&lt;/code&gt;, 其代表的是命令行的提示符，即我们看到的终端呈现的shell每一行的开头，例如在下面这个shell中，就由三个内容组成： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\s = bash, the name of the shell &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;\v = 3.2, the version of bash &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;$ &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有类似的： &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$PS1, primary prompt string, shell界面每次换行后的开头标识符（如果使用了插件进行美化之后，就会发现这个值特别长，就是因为开头标识符变化了）; &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;$PS2, 表示次级的标识符，secondary prompt string，通常为 &amp;gt;; &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;$PS3, 用来指示选中的命令; &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;$PS4, 表示命令在执行的过程中，每一行的输出都会输出 $PS4 的值 [7]; &lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-07-21_22-05-03_screenshot.png&#34;
             alt=&#34;Figure 1: $PS in Bash&#34; width=&#34;150px&#34;/&gt;&lt;figcaption&gt;
                &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 1: &lt;!-- raw HTML omitted --&gt;$PS in Bash&lt;/p&gt;
            &lt;/figcaption&gt;
    &lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;知道了这个之后，我们也就能理解为什么我们通过msf拿到的shell的每一行开头什么都没有，因此被称为非交互式的shell，因为其$PS1没有被定义，也就没有内容可以显示； &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;我们平时利用一些工具对终端进行自定义美化的时候，应该也是对这些内容进行修改来实现的，大家可以试试看在自己的终端中输出这些内容，可能都是很长的输出； &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$-&lt;/p&gt;
&lt;p&gt;$-
: $-, dollar hyphen, 将会返回当前shell（bash）在开启时，所设定的option，例如当返回是himBH，就表示bash启动时设定了[8]： &lt;!-- raw HTML omitted --&gt;
-   H - histexpand: when history expansion is enabled &lt;!-- raw HTML omitted --&gt;
-   m - monitor: when job control is enabled &lt;!-- raw HTML omitted --&gt;
-   h - hashall: Locate and remember (hash) commands as they are looked up for execution &lt;!-- raw HTML omitted --&gt;
-   B - braceexpand: when brace expansion is enabled &lt;!-- raw HTML omitted --&gt;
-   i - interactive: when current shell is interactive &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;这样也就不难理解我们为什么在进行shell是否可交互时可以查看 &lt;code&gt;$-&lt;/code&gt; 的值中是否包含i了； &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;$$
: $$会输出当前shell的进程ID或者说PID，每当新开启一个shell的时候，就会产生一个新的进程 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;$#
: $#用来表示一个bash命令的argument数量，例如下面的例子[9]: &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ```shell
 $ bash -c ‘echo $#’ _ 1 2 3
 ```

 这里的 `_` 下划线表示一个占位符，表示后面的string为命令的arguments，要主要的是，#表示的数字并不会被算进去，因此上面指令的输出为3 &amp;lt;br/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$0
: 显示出当前运行脚本的名字，也就是第一个argument的值； &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;$?
: $?表示的是上一条命令的exit code，如果成功执行则为0，如果出现错误，就回事1； &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;$!
: $!，dollar exclamation,表示上一个最近一个被执行的任务的PID； &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;$_
: $_表示最近一条指令的最后一个argument； &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-07-21_23-10-43_screenshot.png&#34;
             alt=&#34;Figure 2: $_指示上一条指令的最后一个argument&#34; width=&#34;200px&#34;/&gt;&lt;figcaption&gt;
                &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 2: &lt;!-- raw HTML omitted --&gt;$_指示上一条指令的最后一个argument&lt;/p&gt;
            &lt;/figcaption&gt;
    &lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区分-terminal-shell-tty-以及-console&#34;&gt;区分&amp;rsquo;terminal&amp;rsquo;, &amp;lsquo;shell&amp;rsquo;, &amp;rsquo;tty&amp;rsquo; 以及 &amp;lsquo;console&amp;rsquo;&lt;/h3&gt;
&lt;p&gt;我们通过msf获得了一个非交互式的shell之后，很多walkthrough都会教我们将其转换为完全交互式的TTY，那么这个TTY是什么呢？它和shell，console，terminal这些名词到底是什么关系呢？我们就在这里搞搞清楚。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;tty-and-terminal&#34;&gt;tty &amp;amp; terminal&lt;/h4&gt;
&lt;p&gt;tty是一种实现了除了读写以外额外命令 &lt;code&gt;device file&lt;/code&gt; 的设备文件，一般来说，terminal等价于tty。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;一些tty是由kernel内核为了硬件设备所提供的，例如键盘输入，在屏幕上输出文字，或者是对输入输出进行传输。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;另一种tty被称为 &lt;code&gt;pseudo-ttys&lt;/code&gt;, 通常由软件所提供，被称为终端仿真器，例如Xterm，Screen，SSH，等等 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;Terminal也有一种更为传统的含义，即一个提供人们与电脑进行交互的设备，通常配备键盘以及显示器。 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;什么是login-shell和non-login-shell&#34;&gt;什么是Login Shell和Non-Login Shell?&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;A login shell is one whose first character of argument zero is a -, or one started with the &amp;ndash;login option.&amp;rdquo; [10]. &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;如何判断&#34;&gt;如何判断？&lt;/h4&gt;
&lt;p&gt;判断一个shell是否是login shell的标准就是$0的输出字符串，其第一个字符是否是&amp;rsquo;-&amp;rsquo;，如果是，则是一个login shell; &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-07-22_23-14-23_screenshot.png&#34;
         alt=&#34;Figure 3: 判断Login shell&#34; width=&#34;700px&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 3: &lt;!-- raw HTML omitted --&gt;判断Login shell&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;我们也可以通过输入logout命令来进行判断其是否用了 &amp;ndash;login选项，如果可以正常退出，则表示这是一个login shell，如果只能用&amp;rsquo;exit&amp;rsquo; 退出，则表示不是一个login shell &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://ginkgo.org.cn/ox-hugo/2022-07-22_23-14-48_screenshot.png&#34;
         alt=&#34;Figure 4: Logout&#34; width=&#34;700px&#34;/&gt;&lt;figcaption&gt;
            &lt;p&gt;&lt;!-- raw HTML omitted --&gt;Figure 4: &lt;!-- raw HTML omitted --&gt;Logout&lt;/p&gt;
        &lt;/figcaption&gt;
&lt;/figure&gt;
 &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;login-shell&#34;&gt;Login shell&lt;/h4&gt;
&lt;p&gt;Login shell在启动的时候，会传递$0, 通常就是带&amp;rsquo;-&amp;lsquo;的shell名，例如 &amp;lsquo;-bash&amp;rsquo;, &amp;lsquo;-zsh&amp;rsquo;, &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;
&lt;p&gt;[1] ‘What is an Interactive Shell? (Bash Reference Manual)’. &lt;a class=&#34;link&#34; href=&#34;https://www.gnu.org/software/bash/manual/html_node/What-is-an-Interactive-Shell_003f.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.gnu.org/software/bash/manual/html_node/What-is-an-Interactive-Shell_003f.html&lt;/a&gt; (accessed Jul. 21, 2022). &lt;!-- raw HTML omitted --&gt;
[2] T. Hansson, ‘Answer to “What’s the difference between an argument and a parameter?”’, Stack Overflow, Oct. 01, 2008. &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/a/156787/17534765&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/a/156787/17534765&lt;/a&gt; (accessed Jul. 21, 2022). &lt;!-- raw HTML omitted --&gt;
[3] jlliagre, ‘Answer to “Difference between terms: ‘option’, ‘argument’, and ‘parameter’?”’, Stack Overflow, Apr. 08, 2016. &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/a/36495940/17534765&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/a/36495940/17534765&lt;/a&gt; (accessed Jul. 21, 2022). &lt;!-- raw HTML omitted --&gt;
[4] navigaid, ‘Answer to “What does bash -s do?”’, Stack Overflow, Aug. 15, 2018. &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/a/51854728/17534765&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/a/51854728/17534765&lt;/a&gt; (accessed Jul. 22, 2022). &lt;!-- raw HTML omitted --&gt;
[5] ‘Shell Scripting - Interactive and Non-Interactive Shell’, GeeksforGeeks, Jan. 23, 2022. &lt;a class=&#34;link&#34; href=&#34;https://www.geeksforgeeks.org/shell-scripting-interactive-and-non-interactive-shell/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.geeksforgeeks.org/shell-scripting-interactive-and-non-interactive-shell/&lt;/a&gt; (accessed Jul. 22, 2022). &lt;!-- raw HTML omitted --&gt;
[6] 毛英东, ‘什么是交互式shell和非交互式shell?’, 毛英东的个人博客, May 30, 2020. &lt;a class=&#34;link&#34; href=&#34;https://www.maoyingdong.com/what_is_a_interactive_shell/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.maoyingdong.com/what_is_a_interactive_shell/index.html&lt;/a&gt; (accessed Jul. 22, 2022). &lt;!-- raw HTML omitted --&gt;
[7] V. Gite, ‘How to Change / Set up bash custom prompt (PS1) in Linux’, nixCraft, Jun. 02, 2007. &lt;a class=&#34;link&#34; href=&#34;https://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html&lt;/a&gt; (accessed Jul. 22, 2022). &lt;!-- raw HTML omitted --&gt;
[8] anubhava, ‘Answer to “What does $- mean in Bash?”’, Stack Overflow, Mar. 13, 2017. &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/a/42757277/17534765&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://stackoverflow.com/a/42757277/17534765&lt;/a&gt; (accessed Jul. 22, 2022). &lt;!-- raw HTML omitted --&gt;
[9] S. Ganguly, ‘How to Use Special Variables in Bash’. &lt;a class=&#34;link&#34; href=&#34;https://linuxhint.com/use-special-variables-in-bash/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://linuxhint.com/use-special-variables-in-bash/&lt;/a&gt; (accessed Jul. 22, 2022). &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
